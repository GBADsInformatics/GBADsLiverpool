#%% Contents
# -----------------------------------------------------------------------------------------------
# ### Framework
# 1. Startup & Imports
# 2. Initialize App (i.e., the web app)
# 3. Global Program Elements (e.g. read in data and prep it)
# 4. Layout (i.e, the UI layout)
# 5. Callbacks (functions that respond to UI)
# 6. Run App
# -----------------------------------------------------------------------------------------------

#%% 1. STARTUP & IMPORTS

# standard library packages (included with python and always available)
import os, sys, datetime as dt
from pathlib import Path
import inspect
import requests
import io

print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] Starting {__name__}")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] cwd = {os.getcwd()}")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] {sys.path[:2] = }")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] {sys.version = }")

# Third party packages (ie, those installed with pip )
# NO NEED to import Dash or JupyterDash here.  That is done within fa.instantiate_app

from dash import html, dcc, Input, Output, State, dash_table, ctx
import dash_bootstrap_components as dbc  # Allows easy access to all bootstrap themes
import dash_daq as daq
import dash_auth
import numpy as np
import scipy as sp
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import geopandas as gpd
from flask import Flask, redirect
# private (fa) libraries
import lib.fa_dash_utils as fa
import lib.bod_calcs as bod
import lib.ga_ahle_calcs as ga

#### PARAMETERS
prod                         = False   # Use when testing/dev mode to remove auth

#%% 2. INITIALIZE APP
###############################################################################################
# - App named here... if name is changed here, must also be changed elsewhere below
# - Either JupyterDash or just Dash for traditional .py program in Spyder. (Latter requires: 'from dash import Dash' above)
# - There are other dbc.themes (e.g. "SANDSTONE") and other options besides dash_bootstrap_components
###############################################################################################
app_title = 'Global Burden of Animal Disease'
external_stylesheets=[dbc.themes.BOOTSTRAP]
flask_server, app = fa.instantiate_app(app_title, external_stylesheets) # dont change name "flask_server".  Gunicorn expects to find it
gbadsDash = app  # an alias for app; the app name used within this program

if prod:
    ## USERNAMES AND PASSWORDS
    # Keep this out of source code repository - save in a file or a database
    VALID_USERNAME_PASSWORD_PAIRS = {
        'gbads': 'welcometogbads',
        'GBADS': "welcometogbads",
        'GBADs': "welcometogbads"
    }

    # BASIC AUTHORIZATION:  USERNAME:PASSWORD
    auth = dash_auth.BasicAuth(
        gbadsDash,
        VALID_USERNAME_PASSWORD_PAIRS
        )


app.config.suppress_callback_exceptions = True    # Use to remove warnings when assigning callbacks to components that are generated by other callbacks (and therefore not in the initial layout)

#%% 3. GLOBAL PROGRAM ELEMENTS
###############################################################################################
# - Global variables and functions that aren't directly involved in the UI interactivity (Callbacks)
# - Typical example would be functions that read, store, and prep data to be used in the app
###############################################################################################
# Define tab styles

# Tab colors based on grouping
global_tab_style = {
    'backgroundColor': '#aacce3',
    'border-color': 'grey',
    'fontWeight': 'bold'
}
global_tab_selected_style = {
    'backgroundColor': '#aacce3',
    'border-color': 'grey',
    'fontWeight': 'bold'
}

major_producers_tab_style = {
    'backgroundColor': '#abebc5',
    'border-color': 'grey',
    'fontWeight': 'bold'
}
major_producers_tab_selected_style = {
    'backgroundColor': '#abebc5',
    'border-color': 'grey',
    'fontWeight': 'bold'
}

ecs_tab_style = {
    'backgroundColor': '#d7bce1',
    'border-color': 'grey',
    'fontWeight': 'bold'
}
ecs_tab_selected_style = {
    'backgroundColor': '#d7bce1',
    'border-color': 'grey',
    'fontWeight': 'bold'
}

user_guide_tab_style ={
    'border-color': 'grey',
    'fontWeight': 'bold'
}

user_guide_tab_selected_style ={
    'border-color': 'grey',
    'fontWeight': 'bold'
}


# =============================================================================
# # For reference, the first version of the plots was based on Excel files
#
# # Data for the waterfall chart
# waterfall_df = pd.read_excel("data/chickens_bod_plotdata.xls", header=0,sheet_name="Waterfall")
#
# # Data for the sankey diagram
# sankey_df = pd.read_excel("data/chickens_bod_plotdata.xls", header=0,sheet_name="Sankey")
#
# # Data for the data table
# background_df = pd.read_excel('data/chickens_bod_backgrounddata.xls')
#
# =============================================================================

# =============================================================================
#### Read data
# =============================================================================
# Define folder location
CWD = os.getcwd()
DASH_DATA_FOLDER = os.path.join(CWD ,'data')

# Folder location for ethiopia case study
GBADsLiverpool=Path(os.getcwd()).parent.parent
Ethiopia_Workspace = "Ethiopia Workspace"

# Folder location for global aggregate
Global_Agg_Workspace = "Global Aggregate workspace"
if prod:
    # Output folders:
    ECS_PROGRAM_OUTPUT_FOLDER = os.path.join(CWD, Ethiopia_Workspace, "Program outputs")
    GA_DATA_FOLDER = os.path.join(CWD, Global_Agg_Workspace, "Data")
else:
    # Output folders:
    ECS_PROGRAM_OUTPUT_FOLDER = os.path.join(GBADsLiverpool, Ethiopia_Workspace, "Program outputs")
    GA_DATA_FOLDER = os.path.join(GBADsLiverpool, Global_Agg_Workspace, "Data")

# -----------------------------------------------------------------------------
# Poultry
# -----------------------------------------------------------------------------
# Main table
gbads_chickens_merged_fordash = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'gbads_chickens_merged_fordash.pkl.gz'))

# Breed Standards
poultrybreedstd_ross308 = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'poultrybreedstd_ross308.pkl.gz'))
poultrybreedstd_ross708 = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'poultrybreedstd_ross708.pkl.gz'))
poultrybreedstd_cobb500 = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'poultrybreedstd_cobb500.pkl.gz'))
poultrybreedstd_vencobb400 = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'poultrybreedstd_vencobb400.pkl.gz'))
poultrybreedstd_liverpool_model = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'poultrybreedstd_liverpool_model.pkl.gz'))

# -----------------------------------------------------------------------------
# Swine
# -----------------------------------------------------------------------------
# Main table
gbads_pigs_merged_fordash = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'gbads_pigs_merged_fordash.pkl.gz'))

# Breed Standards
swinebreedstd_pic_growthandfeed = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'swinebreedstd_pic_growthandfeed.pkl.gz'))
swinebreedstd_liverpool_model3 = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'swinebreedstd_liverpool_model3.pkl.gz'))

# -----------------------------------------------------------------------------
# Ethiopia Case Study
# -----------------------------------------------------------------------------
# Compartmental model results summary
ecs_ahle_summary = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_summary.csv'))
## Using alternative data which summarizes results from age/sex specific scenarios
ahle_all_scensmry = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_scensmry.csv'))

# Compartmental model results summary with AHLE calculated
# for stacked bar
ecs_ahle_summary2 = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_summary2.csv'))

# Attribution Summary
# ecs_ahle_all_withattr = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_withattr.csv'))
## Using data with disease-specific attribution
ecs_ahle_all_withattr = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_withattr_disease.csv'))

# JR 2023-4-19: added regional results. Testing with Nationl level (should be same as before).
# ahle_all_scensmry = ahle_all_scensmry.query("region == 'National'").copy()
ecs_ahle_summary2 = ecs_ahle_summary2.query("region == 'National'")
# ecs_ahle_all_withattr = ecs_ahle_all_withattr.query("region == 'National'")

# Ethiopia geojson files from S3
# Regional level
url = 'https://gbads-data-repo.s3.ca-central-1.amazonaws.com/shape-files/eth_admbnda_adm1_csa_bofedb_2021.geojson'
r = requests.get(url, allow_redirects=True)
geojson_ecs = r.json()

# Alternative: read from local copy
# geojson_ecs = gpd.read_file(os.path.join(DASH_DATA_FOLDER ,'eth_admbnda_adm1_csa_bofedb_2021.geojson'))

# Expert opinion files
ecs_expertattr_smallrum = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_smallruminants.csv'))
ecs_expertattr_cattle = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_cattle.csv'))
ecs_expertattr_poultry = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_chickens.csv'))

# Economic data is very simple. From Dashboard WEI 08082023.xlsx shared by Tom Marsh
wei_ethiopia_raw = pd.DataFrame({
    'species':'Cattle and Small Ruminants'
    ,'scenario':['Current' ,'Zero Mortality' ,'Ideal']
    ,'scenario_numeric':[0 ,0.5 ,1]
    ,'production_change_pct':[0 ,.402 ,1.8048]
    ,'gdp_change_pct':[0 ,.0251 ,.0357]
    ,'economic_surplus_mlnusd':[0 ,1760.050 ,2452.180]
})

# -----------------------------------------------------------------------------
# Global Aggregate
# -----------------------------------------------------------------------------
# Biomass FAOSTAT
ga_countries_biomass = pd.read_pickle(os.path.join(DASH_DATA_FOLDER ,'world_ahle_abt_fordash.pkl.gz'))

# Drop unnecessary columns
ga_countries_biomass = ga_countries_biomass.drop(columns=['producing_animals_eggs_hd',
                                                          'producing_animals_hides_hd',
                                                          'producing_animals_meat_hd',
                                                          'producing_animals_milk_hd',
                                                          'producing_animals_wool_hd',
                                                          'output_live_hd',
                                                          'output_total_hd',
                                                          # 'output_live_biomass_kg',
                                                          # 'output_total_biomass_kg',
                                                          'output_value_live_2010usd',
                                                          'output_value_total_2010usd',
                                                          'output_value_meatlive_2010usd',
                                                          'producer_price_milk_usdpertonne_cnst2010',
                                                          'producer_price_wool_usdpertonne_cnst2010',
                                                          'producer_price_meat_live_usdpertonne_cnst2010',
                                                          'producer_price_eggs_usdpertonne_cnst2010',
                                                          'producer_price_meat_usdpertonne_cnst2010',
                                                          'production_eggs_kgperkgbm',
                                                          'production_hides_kgperkgbm',
                                                          'production_meat_kgperkgbm',
                                                          'production_milk_kgperkgbm',
                                                          'production_wool_kgperkgbm',
                                                          ])

# Drop species
drop_species = ['Camels',
                'Horses',
                'Buffaloes',
                'Ducks']

_drop_species = (ga_countries_biomass['species'].isin(drop_species))
ga_countries_biomass = ga_countries_biomass.loc[~ _drop_species]


# Drop countries
# Thin the regions with many countries
# ga_countries_biomass['region'].unique()
# countries_eap = list(ga_countries_biomass.query("region == 'East Asia & Pacific'")['country'].unique())
# countries_eca = list(ga_countries_biomass.query("region == 'Europe & Central Asia'")['country'].unique())
# countries_ssa = list(ga_countries_biomass.query("region == 'Sub-Saharan Africa'")['country'].unique())
# countries_lac = list(ga_countries_biomass.query("region == 'Latin America & the Caribbean'")['country'].unique())

drop_countries = [
    # Europe & Central Asia
    'Albania'
    ,'Armenia'
    # ,'Austria'
    ,'Azerbaijan'
    ,'Belarus'
    ,'Bulgaria'
    ,'Croatia'
    ,'Cyprus'
    ,'Czechia'
    # ,'Denmark'
    ,'Estonia'
    # ,'Finland'
    # ,'France'
    ,'Georgia'
    # ,'Germany'
    # ,'Greece'
    ,'Hungary'
    # ,'Iceland'
    # ,'Ireland'
    # ,'Italy'
    ,'Kazakhstan'
    ,'Kyrgyzstan'
    ,'Latvia'
    ,'Lithuania'
    # ,'Netherlands'
    ,'North Macedonia'
    # ,'Norway'
    # ,'Poland'
    ,'Portugal'
    ,'Romania'
    ,'Slovakia'
    ,'Slovenia'
    # ,'Spain'
    # ,'Sweden'
    ,'Switzerland'
    ,'Tajikistan'
    # ,'Turkey'
    ,'Turkmenistan'
    # ,'Ukraine'
    ,'Uzbekistan'

    # East Asia & Pacific
    # ,'Australia'
    ,'Cambodia'
    ,'Cook Islands'
    ,'Fiji'
    ,'French Polynesia'
    # ,'Indonesia'
    # ,'Japan'
    ,'Kiribati'
    # ,'Malaysia'
    ,'Mongolia'
    ,'Myanmar'
    ,'Nauru'
    ,'New Caledonia'
    # ,'New Zealand'
    ,'Niue'
    # ,'Papua New Guinea'
    # ,'Philippines'
    ,'Samoa'
    ,'Singapore'
    ,'Solomon Islands'
    # ,'Thailand'
    ,'Tonga'
    ,'Tuvalu'
    ,'Vanuatu'
    # ,'Viet Nam'

    # Latin America & the Caribbean
    ,'Antigua and Barbuda'
    # ,'Argentina'
    ,'Bahamas'
    ,'Barbados'
    ,'Belize'
    # ,'Bolivia'
    # ,'Brazil'
    # ,'Chile'
    # ,'Colombia'
    # ,'Costa Rica'
    # ,'Cuba'
    ,'Dominica'
    ,'Dominican Republic'
    ,'Ecuador'
    ,'El Salvador'
    ,'Grenada'
    ,'Guadeloupe'
    ,'Guatemala'
    ,'Guyana'
    # ,'Haiti'
    ,'Honduras'
    # ,'Jamaica'
    # ,'Mexico'
    # ,'Nicaragua'
    # ,'Panama'
    ,'Paraguay'
    # ,'Peru'
    # ,'Puerto Rico'
    ,'Saint Kitts and Nevis'
    ,'Saint Lucia'
    ,'Saint Vincent and the Grenadines'
    ,'Suriname'
    ,'Trinidad and Tobago'
    ,'Uruguay'

    # Sub-Saharan Africa
    ,'Angola'
    ,'Benin'
    ,'Botswana'
    ,'Burkina Faso'
    ,'Burundi'
    ,'Cameroon'
    # ,'Central African Republic'
    ,'Chad'
    ,'Comoros'
    # ,'Congo'
    ,"Côte d'Ivoire"
    # ,'Democratic Republic of the Congo'
    ,'Eritrea'
    ,'Eswatini'
    # ,'Ethiopia'
    ,'Gabon'
    ,'Gambia'
    # ,'Ghana'
    # ,'Guinea'
    ,'Guinea-Bissau'
    # ,'Kenya'
    ,'Lesotho'
    ,'Liberia'
    # ,'Madagascar'
    ,'Malawi'
    ,'Mali'
    ,'Mauritania'
    ,'Mauritius'
    # ,'Mozambique'
    # ,'Namibia'
    ,'Niger'
    # ,'Nigeria'
    # ,'Rwanda'
    ,'Sao Tome and Principe'
    ,'Senegal'
    ,'Seychelles'
    ,'Sierra Leone'
    # ,'Somalia'
    # ,'South Africa'
    ,'Togo'
    ,'Uganda'
    ,'Zambia'
    # ,'Zimbabwe'
]
drop_countries_upper = [i.upper() for i in drop_countries]
_drop_countries = (ga_countries_biomass['country'].str.upper().isin(drop_countries_upper))
ga_countries_biomass = ga_countries_biomass.loc[~ _drop_countries]

# Keep history only to 2015
# ga_countries_biomass = ga_countries_biomass.loc[ga_countries_biomass['year'] >= 2015]

# Drop missing values from species
ga_countries_biomass['species'].replace('', np.nan, inplace=True)
ga_countries_biomass.dropna(subset=['species'], inplace=True)

# -----------------------------------------------------------------------------
# Antimicrobial Usage
# -----------------------------------------------------------------------------
amu2018_combined_tall = pd.read_csv(os.path.join(DASH_DATA_FOLDER, "amu2018_combined_tall.csv"))

# Create region labels with number of countries reporting
# amu2018_combined_tall["region_with_countries_reporting"] = \
#     amu2018_combined_tall['region'] + " (" + round(amu2018_combined_tall['number_of_countries'] ,0).astype(int).astype(str) + ")"

# Create region labels with proportion of biomass represented in countries reporting
amu2018_combined_tall["region_with_countries_reporting"] = \
    amu2018_combined_tall['region'] \
        + " (" + round(amu2018_combined_tall['number_of_countries'] ,0).astype(int).astype(str) \
        + " | " + round(amu2018_combined_tall['biomass_prpn_reporting'] * 100 ,1).astype(str) + "%)"

amu_combined_regional = pd.read_csv(os.path.join(DASH_DATA_FOLDER, "amu_combined_regional.csv"))
# amu_uncertainty_data = pd.read_csv(os.path.join(DASH_DATA_FOLDER, "amu_uncertainty_data.csv"))

# Antimicrobial resistance data
amr_withsmry = pd.read_csv(os.path.join(DASH_DATA_FOLDER, "amr_withsmry.csv"))

# =============================================================================
#### User options and defaults
# =============================================================================
# -----------------------------------------------------------------------------
# All species
# -----------------------------------------------------------------------------
# Region options
region_structure_options = [{'label': i, 'value': i, 'disabled': False} for i in ["WOAH",
                                                                       "FAO",
                                                                       "World Bank",]]

# WOAH regions
WOAH_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Africa",
                                                                       "Americas",
                                                                       "Asia, Far East and Oceania",
                                                                       "Europe"
                                                                       ]]
WOAH_region_options += [{'label': "Middle East", 'value': "Middle East", 'disabled': True}]  # Include, but disable, Middle East

# WOAH region-country mapping
WOAH_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

WOAH_americas_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil",
                                                                          "United States of America"]]

WOAH_asia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India",
                                                                          "United States of America"]]

WOAH_europe_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

# FAO regions
fao_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Africa",
                                                                       "Asia",
                                                                       "Europe and Central Asia",
                                                                       "Latin America and the Caribbean",
                                                                       "South West Pacific"
                                                                       ]]

fao_region_options += [{'label': "Near East and North Africa", 'value': "Near East and North Africa", 'disabled': True}]  # Include, but disable, Middle East

# FAO region-country mapping
fao_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

fao_asia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India"]]

fao_eca_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

fao_lac_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil"]]

fao_swp_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                          "United States of America"]]

# World Bank regions
wb_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Sub-Saharan Africa",
                                                                       "Europe & Central Asia",
                                                                       "Latin America & the Caribbean",
                                                                       "North America",
                                                                       "South Asia"
                                                                       ]]

wb_region_options += [{'label': i, 'value': i, 'disabled': True} for i in ["East Asia & Pacific",
                                                                       "Middle East & North Africa"
                                                                       ]]

# World Bank region-country mapping

wb_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

wb_eca_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

wb_lac_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil"]]

wb_na_options = [{'label': i, 'value': i, 'disabled': False} for i in ["United States of America"]]

wb_southasia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India"]]


# Define country shortnames
# These taken from https://en.wikipedia.org/wiki/List_of_alternative_country_names
# Keys in this dictionary must match country names in data
# Should include superset of countries from all species
country_shortnames = {
   'Brazil':'BRA'
   ,'China':'CHN'
   ,'Denmark':'DNK'
   ,'France':'FRA'
   ,'Germany':'DEU'
   ,'India':'IND'
   ,'Italy':'ITA'
   ,'Netherlands':'NLD'
   ,'Poland':'POL'
   ,'Russia':'RUS'
   ,'Spain':'ESP'
   ,'United Kingdom':'GBR'
   ,'United States of America':'USA'
}

# Metrics
# Labels are shown in dropdown, Values are shown in plot titles
# Values must match column names created in prep_bod_forwaterfall()
metric_options = [
   {'label':"Tonnes", 'value':"tonnes", 'disabled':False}
   ,{'label':"US Dollars", 'value':"US dollars", 'disabled':False}
   ,{'label':"Percent of GDP", 'value':"percent of GDP", 'disabled':False}
   ,{'label':"Percent of Breed Standard", 'value':"percent of breed standard", 'disabled':False}
   ,{'label':"Percent of Realised Production", 'value':"percent of realised production", 'disabled':False}
]

# -----------------------------------------------------------------------------
# Poultry
# -----------------------------------------------------------------------------
country_options_poultry = []
for i in np.sort(gbads_chickens_merged_fordash['country'].unique()) :
   country_shortname = country_shortnames[i]
   compound_label = f"{i} ({country_shortname})"
   str(country_options_poultry.append({'label':compound_label,'value':(i)}))

year_options_poultry = []
for i in np.sort(gbads_chickens_merged_fordash['year'].unique()) :
   str(year_options_poultry.append({'label':i,'value':(i)}))

# Global defaults for sliders
# Most sliders will default to a value based on data for the selected country and year
# These values are used if data is missing
dof_poultry_default = 35
achievable_pct_poultry_default = 100
producer_price_poultry_default = 1.75
ration_price_poultry_default = 200
fcr_poultry_default = 1.5

# Breed-country matchup
# Keys must match country names in data
# Values will appear in dashboard text
poultry_lookup_breed_from_country = {
   'Brazil':'Cobb 500'
   ,'China':'Cobb 500'
   ,'France':'Ross 308'
   ,'Germany':'Ross 308'
   ,'India':'Venncobb 400'
   ,'Italy':'Ross 308'
   ,'Netherlands':'Ross 308'
   ,'Poland':'Ross 308'
   ,'Spain':'Ross 308'
   ,'United Kingdom':'Ross 308'
   ,'United States of America':'Cobb 500'
}

# Breed data lookup
# Keys must match values in poultry_lookup_breed_from_country
# Values must be data frames imported above
poultry_lookup_breed_df = {
   'Cobb 500':poultrybreedstd_cobb500
   ,'Ross 308':poultrybreedstd_ross308
   ,'Ross 708':poultrybreedstd_ross708
   ,'Venncobb 400':poultrybreedstd_vencobb400
}

# -----------------------------------------------------------------------------
# Swine
# -----------------------------------------------------------------------------
country_options_swine = []
for i in np.sort(gbads_pigs_merged_fordash['country'].unique()) :
   country_shortname = country_shortnames[i]
   compound_label = f"{i} ({country_shortname})"
   str(country_options_swine.append({'label':compound_label,'value':(i)}))

year_options_swine = []
for i in np.sort(gbads_pigs_merged_fordash['year'].unique()):
   str(year_options_swine.append({'label':i,'value':(i)}))

# Global defaults for sliders
# Most sliders will default to a value based on data for the selected country and year
# These values are used if data is missing
dof_swine_default = 147
feed_swine_default = 270
achievable_weight_swine_default = 120
producer_price_swine_default = 1.75
ration_price_swine_default = 200
fcr_swine_default = 2.2

# Breed-country matchup
# Keys must match country names in data
# Values will appear in dashboard text
swine_lookup_breed_from_country = {
   'Brazil':'PIC'
   ,'China':'PIC'
   ,'Denmark':'PIC'
   ,'France':'PIC'
   ,'Germany':'PIC'
   ,'Italy':'PIC'
   ,'Netherlands':'PIC'
   ,'Poland':'PIC'
   ,'Russia':'PIC'
   ,'Spain':'PIC'
   ,'United Kingdom':'PIC'
   ,'United States of America':'PIC'
}

# Breed data lookup
# Keys must match values in swine_lookup_breed_from_country
# Values must be data frames imported above
swine_lookup_breed_df = {
   'PIC':swinebreedstd_pic_growthandfeed
}

# =============================================================================
#### Ethiopia case study options
# =============================================================================
# Species
# ecs_species_options = []
# for i in np.sort(ecs_ahle_summary['species'].unique()):
#     str(ecs_species_options.append({'label':i,'value':(i)}))
# Specify the order of the species
ecs_species_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Cattle",
                                                                             "All Small Ruminants",
                                                                             "Goat",
                                                                             "Sheep",
                                                                             "All Poultry",
                                                                             "Poultry hybrid",
                                                                             "Poultry indigenous",
                                                                             ]]

# Production system
# Rename Overall to more descriptive
ecs_ahle_summary['production_system'] = ecs_ahle_summary['production_system'].replace({'Overall': 'All Production Systems'})

# ecs_prodsys_options are now defined dynamically in a callback based on selected species
# ecs_prodsys_options = []
# for i in np.sort(ecs_ahle_summary['production_system'].unique()):
#    str(ecs_prodsys_options.append({'label':i,'value':(i)}))

# Year
# Year options are now set in a callback
# ecs_year_options=[]
# for i in np.sort(ecs_ahle_summary['year'].unique()):
#     str(ecs_year_options.append({'label':i,'value':(i)}))

# Sex
ecs_agesex_options=[]
for i in np.sort(ecs_ahle_summary['group'].unique()):
   str(ecs_agesex_options.append({'label':i,'value':(i)}))

# Currency
ecs_currency_options = [{'label': "Birr", 'value': "Birr", 'disabled': False},
                        {'label': "USD", 'value': "USD", 'disabled': False}]

# Attribution hierarchy
ecs_hierarchy_attr_options = [{'label': "Cause", 'value': "cause", 'disabled': False},
                              {'label': "Production System", 'value': "production_system", 'disabled': False},
                              {'label': "Age Group", 'value': "age_group", 'disabled': False},
                              {'label': "Sex", 'value': "sex", 'disabled': False},
                              {'label': "AHLE Component", 'value': "ahle_component", 'disabled': False},
                              {'label': "Disease", 'value': "disease", 'disabled': False}
                              ]

# Drill down options for hierarchy
ecs_hierarchy_dd_attr_options = [{'label': i, 'value': i, 'disabled': False} for i in ["None"]]
ecs_hierarchy_dd_attr_options += ecs_hierarchy_attr_options

# Region - removing 'National' from the options
ecs_region_options = []
for i in ecs_ahle_summary.query("region != 'National'").region.unique():
    str(ecs_region_options.append({'label':i,'value':(i)}))

# Display
ecs_display_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Difference",
                                                                             "Side by Side",
                                                                            ]]
# Item

# Compare
ecs_compare_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Ideal",
                                                                             "Zero Mortality",
                                                                             "Improvement"
                                                                             ]]
# August 2023: updated scenarios do not include zero mortality or improvement
ecs_compare_options_limited = [
    {'label': "Ideal", 'value': "Ideal", 'disabled': False}
    ,{'label': "Zero Mortality", 'value': "Zero Mortality", 'disabled': True}
    ,{'label': "Improvement", 'value': "Improvement", 'disabled': True}
    ]

# Factor
ecs_factor_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Mortality",
                                                                           "Live Weight",
                                                                           "Parturition Rate",
                                                                           "Lactation"
                                                                           ]]

# Reduction
ecs_improve_options = [{'label': i, 'value': i, 'disabled': True} for i in ['25%',
                                                                            '50%',
                                                                            '75%',
                                                                            '100%',
                                                                            ]]
# Map Denominator
ecs_map_denominator_options = [{'label': i, 'value': i, 'disabled': False} for i in ['Per kg biomass',
                                                                                     'Total',
                                                                                     ]]

# =============================================================================
#### Global Aggregate options
# =============================================================================
# Species
ga_species_options = []
for i in ga_countries_biomass['species'].unique():
    str(ga_species_options.append({'label':i,'value':(i)}))

country_options_ga = [{'label': "All", 'value': "All", 'disabled': False}]
for i in ga_countries_biomass['country'].unique():
    str(country_options_ga.append({'label':i,'value':(i)}))

# Income group
# Rename Overall to more descriptive
ga_countries_biomass['incomegroup'] = ga_countries_biomass['incomegroup'].replace(
    {'L': 'Low',
     'LM':'Lower Middle',
     'UM':'Upper Middle',
     'H':'High',
     'UNK':'Unassigned',
     'NaN':'Unassigned'
     })

# replacing na values in college with No college
ga_countries_biomass['incomegroup'].fillna("Unassigned", inplace = True)

incomegrp_options_ga = [{'label': "All", 'value': "All"}]
for i in ga_countries_biomass['incomegroup'].unique():
    str(incomegrp_options_ga.append({'label':i,'value':(i)}))

# Mortality rate
mortality_rate_options_ga = [{'label': f'{i*100: .0f}%', 'value': i, 'disabled': True} for i in list(np.array(range(1, 11)) / 100)]

# Year
year_options_ga = []
for i in np.sort(ga_countries_biomass['year'].unique()):
   str(year_options_ga.append({'label':i,'value':(i)}))

# AHLE elements
# Values here must match item names defined in prep_ahle_forwaterfall_ga()
item_list_ga = [
    'Biomass'
    ,'Meat'
    ,'Eggs'
    ,'Milk'
    ,'Wool'
    ,'Producers vet & med costs'
    # Update 4/5/2023: William no longer wants public expenditure to appear in calculations
    # ,'Public vet & med costs'
    ,'Antimicrobial expenditure'
    ,'Net value'
]
item_options_ga = [{'label':i,'value':(i)} for i in item_list_ga]

# Map display options
map_display_options_ga = [
    'Population'
    ,'Live Weight'
    ,'Biomass'
    ,'Animal Health Loss Envelope (AHLE)'
    ,'AHLE per kg biomass'
    ]

# Defautls for sliders
mortality_rate_ga_default = 4
morbidity_rate_ga_default = 2
live_weight_price_ga_default = 1.75

# -----------------------------------------------------------------------------
# Region - Country Alignment
# -----------------------------------------------------------------------------
# !!!: CURRENTLY DIFFERENT FROM POULTRY/SWINE TABS DUE TO DATA AVAILABILITY -eventually want these to be the same

# Region options
region_structure_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["World Bank",]]

region_structure_options_ga += [{'label': i, 'value': i, 'disabled': True} for i in ["WOAH",
                                                                                     "FAO",]]

# WOAH regions
WOAH_region_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                               "Africa",
                                                                               "Americas",
                                                                               "Asia, Far East and Oceania",
                                                                               "Europe",
                                                                               "Middle East"
                                                                               ]]
# WOAH region-country mapping
WOAH_africa_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["Ethiopia"]]

WOAH_americas_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil",
                                                                                 "United States of America"]]

WOAH_asia_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["India",
                                                                             "United States of America"]]

WOAH_europe_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                               "Germany",
                                                                               "Italy",
                                                                               "Netherlands",
                                                                               "Poland",
                                                                               "United Kingdom"]]

WOAH_me_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["TEST"]]


# FAO regions
fao_region_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                               "Africa",
                                                                               "Asia",
                                                                               "Europe and Central Asia",
                                                                               "Latin America and the Caribbean",
                                                                               "Near East and North Africa"
                                                                               "South West Pacific"
                                                                               ]]

# FAO region-country mapping
fao_africa_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["Ethiopia"]]

fao_asia_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["India"]]

fao_eca_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                            "Germany",
                                                                            "Italy",
                                                                            "Netherlands",
                                                                            "Poland",
                                                                            "United Kingdom"]]

fao_lac_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil"]]

fao_ena_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["TEST"]]


fao_swp_options_ga = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                            "United States of America"]]

# World Bank regions
ga_countries_biomass['region_label'] = ga_countries_biomass['region'].replace({'EAP': 'East Asia & Pacific',
                                                                         'ECA':'Europe & Central Asia',
                                                                         'LAC':'Latin America & the Caribbean',
                                                                         'MENA':'Middle East & North Africa',
                                                                         'NA':'North America',
                                                                         'SA':'South Asia',
                                                                         'SSA':'Sub-Saharan Africa'})

wb_region_options_ga = [{'label': "All", 'value': "All"}]
for i in ga_countries_biomass['region_label'].unique():
    str(wb_region_options_ga.append({'label':i,'value':(i)}))

# World Bank region-country mapping
# Pulled from World Bank site (https://datahelpdesk.worldbank.org/knowledgebase/articles/906519-world-bank-country-and-lending-groups)

# East Asia & Pacific options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'East Asia & Pacific')]
wb_eap_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_eap_options_ga.append({'label':i,'value':(i)}))

# Europe & Central Asia options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'Europe & Central Asia')]
wb_eca_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_eca_options_ga.append({'label':i,'value':(i)}))

# Latin America & the Caribbean options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'Latin America & the Caribbean')]
wb_lac_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_lac_options_ga.append({'label':i,'value':(i)}))

# Middle East & North Africa options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'Middle East & North Africa')]
wb_mena_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_mena_options_ga.append({'label':i,'value':(i)}))

# North America options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'North America')]
wb_na_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_na_options_ga.append({'label':i,'value':(i)}))

# South Asia options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'South Asia')]
wb_southasia_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_southasia_options_ga.append({'label':i,'value':(i)}))

# Sub-Saharan Africa options
options = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == 'Sub-Saharan Africa')]
wb_africa_options_ga = [{'label': "All", 'value': "All"}]
for i in options['country'].unique():
    str(wb_africa_options_ga.append({'label':i,'value':(i)}))


# =============================================================================
#### Antimicrobial Usage (AMU) options
# =============================================================================
# Map display
amu_map_display_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Antimicrobial usage: tonnes",
                                                                                  "Antimicrobial usage: mg per kg biomass",
                                                                                  "Biomass",
                                                                                  "Antimicrobial Resistance (country level)",
                                                                                  "Drug Resistance Index (region level)",
                                                                                  "Antimicrobial expenditure: total",
                                                                                  "Antimicrobial expenditure: per kg biomass",]]


# Antimicrobial Class
amu_antimicrobial_class_options = []
for i in np.sort(amr_withsmry['antimicrobial_class'].unique()):
    str(amu_antimicrobial_class_options.append({'label':i,'value':(i)}))

# Pathogen
amu_pathogen_options = []
for i in np.sort(amr_withsmry['pathogen'].unique()):
    str(amu_pathogen_options.append({'label':i,'value':(i)}))

# nav_btn_style = {
#      'align': 'center',
#      'color': 'black',
#      'backgroundColor': 'white',
#      'fontSize': '1rem',
#      'width': '10rem',
#      'height': '3.2rem',
#      'margin': '0rem 1rem',
#  }
# =============================================================================
#### Burden of disease calcs
# =============================================================================
# These are stored in a separate file, bod_calcs.py, imported above.

# =============================================================================
#### Prep data for plots
# =============================================================================
# Create labels for BOD components
# Used for both Waterfall and Sankey
pretty_bod_component_names = {
   "bod_referenceproduction_tonnes":"Breed Standard Potential*"
   ,"bod_gmax_tonnes":"Achievable Without Disease"
   ,"bod_efficiency_tonnes":"Effect of Feed & Practices"
   ,"bod_realizedproduction_tonnes":"Realised Production"
   ,"bod_totalburden_tonnes":"Burden of Disease"
   ,"bod_deathloss_tonnes":"Mortality & Condemns"
   ,"bod_morbidity_tonnes":"Morbidity"
}

# Waterfall chart uses same structure as Sankey but fewer rows.
# It does not display interior nodes of Sankey, only end nodes.
def prep_bod_forwaterfall(
      INPUT_DF
      ,USDPERKG        # Float (0+): Price to producers in US dollars per kg of meat
      ,BOD_COMP_NAMES=pretty_bod_component_names   # Dictionary: defining names for each component of burden of disease that will appear in plots
      ):
   OUTPUT_DF = INPUT_DF.copy()

   # Melt BOD component columns into rows
   # Ordering here determines order in plot!!!
   cols_tomelt = [
      'bod_referenceproduction_tonnes'
      ,'bod_efficiency_tonnes'
      ,'bod_deathloss_tonnes'
      ,'bod_morbidity_tonnes'
      ,'bod_realizedproduction_tonnes'
   ]
   OUTPUT_DF = OUTPUT_DF.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_tomelt
      ,var_name='bod_component'
      ,value_name='tonnes'
   )

   # Add $ value calculation
   OUTPUT_DF['usd'] = OUTPUT_DF['tonnes'] * 1000 * USDPERKG

   # Add value as percent of gdp
   OUTPUT_DF = pd.merge(   # Merge gdp from core data onto melted data
      left=OUTPUT_DF
      ,right=INPUT_DF[['country' ,'year' ,'wb_gdp_usd']]
      ,on=['country' ,'year']
      ,how='left'
   )
   OUTPUT_DF['gdp_prpn'] = OUTPUT_DF['usd'] / OUTPUT_DF['wb_gdp_usd']

   # Add value as percent of breed standard
   OUTPUT_DF = pd.merge(
      left=OUTPUT_DF
      ,right=INPUT_DF[['country' ,'year' ,'bod_referenceproduction_tonnes']]
      ,on=['country' ,'year']
      ,how='left'
   )
   OUTPUT_DF['brdstd_prpn'] = OUTPUT_DF['tonnes'] / OUTPUT_DF['bod_referenceproduction_tonnes']

   OUTPUT_DF = pd.merge(
      left=OUTPUT_DF
      ,right=INPUT_DF[['country' ,'year' ,'bod_realizedproduction_tonnes']]
      ,on=['country' ,'year']
      ,how='left'
   )
   OUTPUT_DF['rlzprod_prpn'] = OUTPUT_DF['tonnes'] / OUTPUT_DF['bod_realizedproduction_tonnes']


   # Give BOD components pretty names
   OUTPUT_DF['bod_component'] = OUTPUT_DF['bod_component'].replace(BOD_COMP_NAMES)

   # Define pretty column names
   # These are used in plot titles
   rename_cols = {
      # "country":"Country"
      # ,"year":"Year"
      "bod_component":"Component"
      ,"tonnes":"tonnes"            # Name must match to a value from metric_options
      ,"usd":"US dollars"           # Name must match to a value from metric_options
      ,"gdp_prpn":"percent of GDP"  # Name must match to a value from metric_options
      ,"brdstd_prpn":"percent of breed standard"
      ,"rlzprod_prpn":"percent of realised production"
   }
   OUTPUT_DF = OUTPUT_DF.rename(columns=rename_cols)

   return OUTPUT_DF

def prep_bod_forsankey(
      INPUT_DF
      ,BOD_COMP_NAMES=pretty_bod_component_names   # Dictionary: defining names for each component of burden of disease that will appear in plots
      ):
   OUTPUT_DF = INPUT_DF.copy()

   # If user selected an achievable proportion too low, reduced growth (morbidity) will be the wrong sign
   # For these, set reduced growth (morbidity) = 0 and add reduced growth to effect of feed
   rows_with_wrongsign_morbidity = (OUTPUT_DF['bod_morbidity_tonnes'] > 0)
   OUTPUT_DF.loc[rows_with_wrongsign_morbidity] = OUTPUT_DF.loc[rows_with_wrongsign_morbidity].eval(
       '''
       bod_efficiency_tonnes = bod_efficiency_tonnes + bod_morbidity_tonnes
       bod_morbidity_tonnes = 0
       '''
   )

   # Burden of Disease is at least equal magnitude to death loss
   # If total burden < death loss, set equal to death loss
   rows_with_burden_lt_deathloss = (np.abs(OUTPUT_DF['bod_totalburden_tonnes']) < np.abs(OUTPUT_DF['bod_deathloss_tonnes']))
   OUTPUT_DF.loc[rows_with_burden_lt_deathloss] = OUTPUT_DF.loc[rows_with_burden_lt_deathloss].eval(
      '''
      bod_totalburden_tonnes = bod_deathloss_tonnes
      '''
   )

   # Melt each BOD component column into a row
   cols_tomelt = [
      # 'bod_referenceproduction_tonnes'      # Starting node is implicit. See sankey_source_lookup.
      'bod_gmax_tonnes'
      ,'bod_efficiency_tonnes'
      ,'bod_realizedproduction_tonnes'
      ,'bod_totalburden_tonnes'
      ,'bod_deathloss_tonnes'
      ,'bod_morbidity_tonnes'
   ]
   OUTPUT_DF = OUTPUT_DF.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_tomelt
      ,var_name='bod_component'
      ,value_name='value'
   )

   # Sankey requires a Source for each Destination
   sankey_source_lookup = {
      "bod_referenceproduction_tonnes":""       # Starting node has no source
      ,"bod_gmax_tonnes":"bod_referenceproduction_tonnes"
      ,"bod_efficiency_tonnes":"bod_referenceproduction_tonnes"
      ,"bod_realizedproduction_tonnes":"bod_gmax_tonnes"
      ,"bod_totalburden_tonnes":"bod_gmax_tonnes"
      ,"bod_deathloss_tonnes":"bod_totalburden_tonnes"
      ,"bod_morbidity_tonnes":"bod_totalburden_tonnes"
   }
   OUTPUT_DF['sankey_source'] = OUTPUT_DF['bod_component'].replace(sankey_source_lookup)

   # If subopt is positive, it becomes a Source for Gmax
   rows_with_positive_subopt = ((OUTPUT_DF['bod_component'] == 'bod_efficiency_tonnes') & (OUTPUT_DF['value'] > 0))
   OUTPUT_DF.loc[rows_with_positive_subopt ,'bod_component'] = 'bod_gmax_tonnes'
   OUTPUT_DF.loc[rows_with_positive_subopt ,'sankey_source'] = 'bod_efficiency_tonnes'
   OUTPUT_DF.loc[rows_with_positive_subopt ,'value'] = OUTPUT_DF['value']

   # Sankey wants all components to be positive
   # This step must come after all other calcs!
   OUTPUT_DF['value'] = np.abs(OUTPUT_DF['value'])

   # Give BOD components pretty names
   OUTPUT_DF['bod_component'] = OUTPUT_DF['bod_component'].replace(BOD_COMP_NAMES)
   OUTPUT_DF['sankey_source'] = OUTPUT_DF['sankey_source'].replace(BOD_COMP_NAMES)

   # Define pretty column names
   rename_cols = {
      # "country":"Country"
      # ,"year":"Year"
      "bod_component":"Component"
      ,"value":"Tonnes"
      ,"sankey_source":"Component Source"
   }
   OUTPUT_DF = OUTPUT_DF.rename(columns=rename_cols)

   return OUTPUT_DF

def prep_bod_forstackedbar_poultry(INPUT_DF):
   working_df = INPUT_DF.copy()

   # Actual costs
   # Ordering here determines order in plot
   cols_actual = [
      'adjusted_feedcost_usdperkglive'   # Adjusted based on feed price slider
      ,'acc_chickcost_usdperkglive'
      ,'acc_laborcost_usdperkglive'
      ,'acc_landhousingcost_usdperkglive'
      # ,'acc_medcost_usdperkglive'
      ,'acc_othercost_usdperkglive'
   ]
   # Ideal costs
   cols_ideal = [
      'ideal_feedcost_usdperkglive'
      ,'ideal_chickcost_usdperkglive'
      ,'ideal_laborcost_usdperkglive'
      ,'ideal_landhousingcost_usdperkglive'
      # ,'ideal_medcost_usdperkglive'
      ,'ideal_othercost_usdperkglive'
   ]

   # If any costs are missing for a given country and year, fill in zero
   for COL in cols_actual + cols_ideal:
      working_df[COL] = working_df[COL].replace(np.nan ,0)

   # If actual costs are all zero, want to display a blank chart
   # In this case, set all ideal costs to zero as well
   _rows_allzero = (working_df[cols_actual].sum(axis=1) == 0)
   for COL in cols_ideal:
      working_df.loc[_rows_allzero ,COL] = 0

   # Create column for Burden of Disease as total actual minus total ideal
   working_df['bod_costs'] = working_df[cols_actual].sum(axis=1) - working_df[cols_ideal].sum(axis=1)

   # Melt actual costs into rows
   output_actual = working_df.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_actual
      ,var_name='cost_item'
      ,value_name='cost_usdperkglive'
   )
   output_actual['opt_or_act'] = 'Actual'  # Value here determines bar label in plot

   # Melt ideal costs into rows
   output_ideal = working_df.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_ideal + ['bod_costs']
      ,var_name='cost_item'
      ,value_name='cost_usdperkglive'
   )
   output_ideal['opt_or_act'] = 'Ideal + Burden of disease'  # Value here determines bar label in plot

   # Stack actual, ideal, and burden
   OUTPUT_DF = pd.concat(
      [output_actual ,output_ideal]
      ,axis=0
      ,join='outer'
      ,ignore_index=True
   )

   # Recode cost item names
   # Keys are column names
   # Values are cost items as you want them to appear in plot
   # Actual and Ideal costs should appear in pairs, except for bod_costs which only appears once
   pretty_bod_cost_names = {
      'adjusted_feedcost_usdperkglive':'Feed'
      ,'ideal_feedcost_usdperkglive':'Feed'

      ,'acc_chickcost_usdperkglive':'Chicks'
      ,'ideal_chickcost_usdperkglive':'Chicks'

      ,'acc_laborcost_usdperkglive':'Labour'
      ,'ideal_laborcost_usdperkglive':'Labour'

      ,'acc_landhousingcost_usdperkglive':'Land & Housing'
      ,'ideal_landhousingcost_usdperkglive':'Land & Housing'

      # ,'acc_medcost_usdperkglive':'Medicine'
      # ,'ideal_medcost_usdperkglive':'Medicine'

      ,'acc_othercost_usdperkglive':'Other'
      ,'ideal_othercost_usdperkglive':'Other'

      ,'bod_costs':'Burden of Disease'
   }
   OUTPUT_DF['Cost Item'] = OUTPUT_DF['cost_item'].replace(pretty_bod_cost_names)

   # Add column with labels for each segment
   OUTPUT_DF['label'] = OUTPUT_DF['Cost Item'] + ' - $' + OUTPUT_DF['cost_usdperkglive'].round(2).astype(str)

   return OUTPUT_DF

def prep_bod_forstackedbar_swine(INPUT_DF):
   working_df = INPUT_DF.copy()

   # Actual costs
   # Ordering here determines order in plot
   cols_actual = [
      'adjusted_feedcost_usdperkgcarc'    # Adjusted based on feed price slider
      ,'acc_nonfeedvariablecost_usdperkgcarc'
      ,'acc_laborcost_usdperkgcarc'
      ,'acc_landhousingcost_usdperkgcarc'
   ]
   # Ideal costs
   cols_ideal = [
      'ideal_feedcost_usdperkgcarc'   # Using feed price from slider
      ,'ideal_nonfeedvariablecost_usdperkgcarc'
      ,'ideal_laborcost_usdperkgcarc'
      ,'ideal_landhousingcost_usdperkgcarc'
   ]

   # If any costs are missing for a given country and year, fill in zero
   for COL in cols_actual + cols_ideal:
      working_df[COL] = working_df[COL].replace(np.nan ,0)

   # If actual costs are all zero, want to display a blank chart
   # In this case, set all ideal costs to zero as well
   _rows_allzero = (working_df[cols_actual].sum(axis=1) == 0)
   for COL in cols_ideal:
      working_df.loc[_rows_allzero ,COL] = 0

   # Create column for Burden of Disease as total actual minus total ideal
   working_df['bod_costs'] = working_df[cols_actual].sum(axis=1) - working_df[cols_ideal].sum(axis=1)

   # Melt actual costs into rows
   output_actual = working_df.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_actual
      ,var_name='cost_item'
      ,value_name='cost_usdperkgcarc'  # Value here determines axis label in plot
   )
   output_actual['opt_or_act'] = 'Actual'  # Value here determines bar label in plot

   # Melt ideal costs into rows
   output_ideal = working_df.melt(
      id_vars=['country' ,'year']
      ,value_vars=cols_ideal + ['bod_costs']
      ,var_name='cost_item'
      ,value_name='cost_usdperkgcarc'  # Value here determines axis label in plot
   )
   output_ideal['opt_or_act'] = 'Ideal + Burden of disease'  # Value here determines bar label in plot

   # Stack actual, ideal, and burden
   OUTPUT_DF = pd.concat(
      [output_actual ,output_ideal]
      ,axis=0
      ,join='outer'
      ,ignore_index=True
   )

   # Recode cost item names
   # Keys are column names
   # Values are cost items as you want them to appear in plot
   # Actual and Ideal costs should appear in pairs, except for bod_costs which only appears once
   pretty_bod_cost_names = {
      "adjusted_feedcost_usdperkgcarc":"Feed"
      ,"ideal_feedcost_usdperkgcarc":"Feed"

      ,"acc_nonfeedvariablecost_usdperkgcarc":"Nonfeed Variable Costs"
      ,"ideal_nonfeedvariablecost_usdperkgcarc":"Nonfeed Variable Costs"

      ,"acc_laborcost_usdperkgcarc":"Labour"
      ,"ideal_laborcost_usdperkgcarc":"Labour"

      ,"acc_landhousingcost_usdperkgcarc":"Finance"
      ,"ideal_landhousingcost_usdperkgcarc":"Finance"

      ,"bod_costs":"Burden of Disease"
   }
   OUTPUT_DF['Cost Item'] = OUTPUT_DF['cost_item'].replace(pretty_bod_cost_names)

   # Add column with labels for each segment
   OUTPUT_DF['label'] = OUTPUT_DF['Cost Item'] + ' - $' + OUTPUT_DF['cost_usdperkgcarc'].round(2).astype(str)

   return OUTPUT_DF


def prep_ahle_fortreemap_ecs(INPUT_DF):
   ecs_ahle_attr_treemap = INPUT_DF.copy()

   # # Trim the data to keep things needed for the treemap
   # ecs_ahle_attr_treemap = working_df[[
   #     'species',
   #     'production_system',
   #     'age_group',
   #     'sex',
   #     'year',
   #     'ahle_component',
   #     'cause',
   #     'disease',
   #     'mean',
   #     # 'pct_of_total'
   #     ]]

   # Can only have positive values
   ecs_ahle_attr_treemap['mean'] = abs(ecs_ahle_attr_treemap['mean'])

   # Replace 'overall' values with more descriptive values
   # ecs_ahle_summary_tree_pivot['age_group'] = ecs_ahle_summary_tree_pivot['age_group'].replace({'Overall': 'Overall Age'})
   ecs_ahle_attr_treemap['sex'] = ecs_ahle_attr_treemap['sex'].replace({'Overall': 'Overall Sex'})

   # Replace mortality with mortality loss
   ecs_ahle_attr_treemap['ahle_component'] = ecs_ahle_attr_treemap['ahle_component'].replace({'Mortality': 'Mortality Loss'})

   # Fill in missing values with 0
   ecs_ahle_attr_treemap = ecs_ahle_attr_treemap.fillna(0)

   OUTPUT_DF = ecs_ahle_attr_treemap

   return OUTPUT_DF


def prep_ahle_forwaterfall_ecs(INPUT_DF):
   ecs_ahle_waterfall = INPUT_DF.copy()

   # Fill missing values with 0
   ecs_ahle_waterfall.fillna(0)

   # Keep only items for the waterfall
   # This also specifies the ordering of the bars
   waterfall_plot_items = ('Value of Offtake',
                            'Value of Eggs consumed',
                            'Value of Eggs sold',
                            'Value of Herd Increase',
                            'Value of draught',
                            'Value of Milk',
                            'Value of Manure',
                            'Value of Hides',
                            'Feed Cost',
                            'Labour Cost',
                            'Health Cost',
                            'Infrastructure Cost',
                            'Capital Cost',
                            'Gross Margin')
   waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
   ecs_ahle_waterfall = ecs_ahle_waterfall.loc[ecs_ahle_waterfall['item'].str.upper().isin(waterfall_plot_items_upper)]

   # Sort Item column to keep values and costs together
   ecs_ahle_waterfall['item'] = ecs_ahle_waterfall['item'].astype('category')
   ecs_ahle_waterfall.item.cat.set_categories(waterfall_plot_items, inplace=True)
   ecs_ahle_waterfall = ecs_ahle_waterfall.sort_values(["item"])

   # Rename costs values to be more descriptive
   ecs_ahle_waterfall['item'] = ecs_ahle_waterfall['item'].replace({'Feed Cost': 'Expenditure on Feed',
                                                                    'Labour Cost': 'Expenditure on Labour',
                                                                    'Health Cost': 'Expenditure on Health',
                                                                    'Infrastructure Cost': 'Expenditure on Housing',
                                                                    'Capital Cost': 'Expenditure on Capital',
                                                                    'Value of draught': 'Value of Draught'})

   OUTPUT_DF = ecs_ahle_waterfall

   return OUTPUT_DF

def prep_ahle_forstackedbar_ecs(INPUT_DF, cols_birr_costs, cols_usd_costs, pretty_ahle_cost_names):
   working_df = INPUT_DF.copy()

   # Birr costs
   # Ordering here determines order in plot
   cols_birr_costs = cols_birr_costs

   # USD costs
   cols_usd_costs = cols_usd_costs

   # If any costs are missing, fill in zero
   for COL in cols_birr_costs + cols_usd_costs:
      working_df[COL] = working_df[COL].replace(np.nan ,0)

   # Melt birr costs into rows
   output_birr = working_df.melt(
      id_vars=['species' ,'production_system']
      ,value_vars=cols_birr_costs
      ,var_name='ahle_due_to'
      ,value_name='cost_birr'
   )
   # output_actual['opt_or_act'] = 'Actual'  # Value here determines bar label in plot

   # Melt usd costs into rows
   output_usd = working_df.melt(
      id_vars=['species' ,'production_system']
      ,value_vars=cols_usd_costs
      ,var_name='ahle_due_to'
      ,value_name='cost_usd'
   )
   # output_ideal['opt_or_act'] = 'Ideal + Burden of disease'  # Value here determines bar label in plot

   # Stack
   OUTPUT_DF = pd.concat(
      [output_birr ,output_usd]
      ,axis=0
      ,join='outer'
      ,ignore_index=True
   )

   # Recode cost item names
   pretty_ahle_cost_names = pretty_ahle_cost_names
   OUTPUT_DF['AHLE Due To'] = OUTPUT_DF['ahle_due_to'].replace(pretty_ahle_cost_names)

   # Create new string column for label
   OUTPUT_DF['Age_group_string'] = OUTPUT_DF['ahle_due_to'].str.slice(10,12)
   OUTPUT_DF['Age_group_string'] = OUTPUT_DF['Age_group_string'].str.upper()

   # Add column with labels for each segment
   OUTPUT_DF['label_birr'] = OUTPUT_DF['Age_group_string'] + ' - ' + OUTPUT_DF['cost_birr'].map('{:,.0f}'.format).astype(str) + ' Birr'
   OUTPUT_DF['label_usd'] = OUTPUT_DF['Age_group_string'] + ' - ' + OUTPUT_DF['cost_usd'].map('{:,.0f}'.format).astype(str) + ' USD'

   return OUTPUT_DF

def prep_ahle_forwaterfall_ga(INPUT_DF):
    # Ordering of current values dictionary determines order in plot
    current_values_labels = {
        'biomass_value_2010usd':'Biomass'
        ,'output_value_meat_2010usd':'Meat'
        ,'output_value_eggs_2010usd':'Eggs'
        ,'output_value_milk_2010usd':'Milk'
        ,'output_value_wool_2010usd':'Wool'

        ,'vetspend_farm_usd':'Producers vet & med costs'
        # Update 4/5/2023: William no longer wants public expenditure to appear in calculations
        # ,'vetspend_public_usd':'Public vet & med costs'
        ,'antimicrobial_expenditure_usd':'Antimicrobial expenditure'

        ,'net_value_2010usd':'Net value'
    }
    current_value_columns = list(current_values_labels)
    ideal_values_labels = {
        'ideal_biomass_value_2010usd':'Biomass'
        ,'ideal_output_value_meat_2010usd':'Meat'
        ,'ideal_output_value_eggs_2010usd':'Eggs'
        ,'ideal_output_value_milk_2010usd':'Milk'
        ,'ideal_output_value_wool_2010usd':'Wool'
        ,'ideal_output_plus_biomass_value_2010usd':'Net value'
    }
    ideal_value_columns = list(ideal_values_labels)

    # Sum to country-year level (summing over species)
    country_year_level = INPUT_DF.pivot_table(
        index=['region' ,'region_label' ,'country' ,'year' ,'incomegroup']
        ,observed=True  # Limit to combinations of index variables that are in data
        ,values=current_value_columns + ideal_value_columns
        ,aggfunc='sum'
        ,fill_value=0
        )
    country_year_level = country_year_level.reset_index()     # Pivoting will change columns to indexes. Change them back.

    # Restructure to create columns 'value_usd_current' and 'value_usd_ideal'
    # Current values
    values_current = country_year_level.melt(
        id_vars=['region' ,'region_label' ,'country' ,'year' ,'incomegroup']
        ,value_vars=current_value_columns
        ,var_name='orig_col'             # Name for new "variable" column
        ,value_name='value_usd_current'              # Name for new "value" column
        )
    values_current['item'] = values_current['orig_col'].apply(ga.lookup_from_dictionary ,DICT=current_values_labels)
    del values_current['orig_col']

    # Ideal values
    values_ideal = country_year_level.melt(
        id_vars=['region' ,'region_label' ,'country' ,'year' ,'incomegroup']
        ,value_vars=ideal_value_columns
        ,var_name='orig_col'             # Name for new "variable" column
        ,value_name='value_usd_ideal'              # Name for new "value" column
        )
    values_ideal['item'] = values_ideal['orig_col'].apply(ga.lookup_from_dictionary ,DICT=ideal_values_labels)
    del values_ideal['orig_col']

    # Merge current and ideal
    values_combined = pd.merge(
        left=values_current
        ,right=values_ideal
        ,on=['region' ,'region_label' ,'country' ,'year' ,'incomegroup' ,'item']
        ,how='outer'
    )

    # Sort Item column to keep values and costs together
    # Sort order is same as current values dictionary defined above
    items_plotorder = list(current_values_labels.values())
    values_combined['item'] = values_combined['item'].astype('category')
    values_combined.item.cat.set_categories(items_plotorder, inplace=True)
    values_combined = values_combined.sort_values(['item'])

    # Fill in zeros for ideal costs
    _vetmed_rows = (values_combined['item'].str.contains('COSTS' ,case=False ,na=False)\
                    | values_combined['item'].str.contains('EXPENDITURE' ,case=False ,na=False))
    values_combined.loc[_vetmed_rows ,'value_usd_ideal'] = 0

    OUTPUT_DF = values_combined

    return OUTPUT_DF

# =============================================================================
#### Define the figures
# =============================================================================
# Define the Waterfall
def create_waterfall(x, y, text):
     waterfall_fig = go.Figure(go.Waterfall(
        name = "20",
        orientation = "v",

        measure = ["relative", "relative", "relative", "relative", "total"],  # This needs to change with number of columns in waterfalll
        x=x,
        y=y,
        hoverinfo = 'none',  # Disable the hover over tooltip
        text=text,
        textposition = ["outside","outside","auto","auto","outside"],
        decreasing = {'marker':{"color":'#F7931D'}},
        increasing = {'marker':{"color":'#3598DB'}},
        totals = {'marker':{"color":'#5BC0DE'}},
        connector = {"line":{"color":"darkgrey"}}#"rgb(63, 63, 63)"}},
        ))

     waterfall_fig.update_layout(clickmode='event+select', ### EVENT SELECT ??????
                                 plot_bgcolor="#ededed")
     waterfall_fig.update_xaxes(
         fixedrange=True
         )
     waterfall_fig.update_yaxes(
         fixedrange=True
         )

     return waterfall_fig

# Define the Sankey
def create_sankey(label_list, color, x, y, source, target, values, n):
    sankey_fig = go.Figure(data=go.Sankey(
        textfont = dict(size=15),
        arrangement = 'fixed',
        hoverinfo = 'none',  # Disable the hover over tooltip
        valueformat = ",.0f",
        node = dict(
            pad = 25,
            thickness = 15,
            line = dict(color = "black", width = 0.5),
            label = label_list,
            x = x,
            y = y,
            color = color
            ),
        link = dict(
            source = source,
            target = target,
            value = values,
            color = ['#ededed']*n),
        ))
    return sankey_fig

# Define the stacked bar
def create_stacked_bar_poultry(input_df, x, y, color):
    bar_fig = px.bar(
       input_df,
       x=x,
       y=y,
       color=color,
       # Keys in color map must match values assigned in pretty_bod_cost_names
       color_discrete_map={
          "Feed":"#2A80B9",
          "Chicks":"#9B58B5",
          "Labour":"#F1C40F",
          "Land & Housing":"#2DCC70",
          "Medicine":"#7A7A7A",
          "Other":"#7A7A7A",
          "Burden of Disease":"#F7931D",
          },
       text='label'
       )
    bar_fig.update_layout(
       plot_bgcolor="#ededed",
       hovermode=False,
       showlegend=True,
       xaxis_title=None,
       yaxis_title='Cost per kg live weight',
       yaxis_tickformat = "$.2f"
       )
    bar_fig.update_xaxes(
        fixedrange=True
        )
    bar_fig.update_yaxes(
        fixedrange=True
        )
    return bar_fig

def create_stacked_bar_swine(input_df, x, y, color):
    bar_fig = px.bar(
       input_df,
       x=x,
       y=y,
       color=color,
       # Keys in color map must match values assigned in pretty_bod_cost_names
       color_discrete_map={
          "Feed":"#2A80B9",
          "Nonfeed Variable Costs":"#9B58B5",
          "Labour":"#F1C40F",
          "Finance":"#2DCC70",
          "Burden of Disease":"#F7931D",
          },
       text='label'
       )
    bar_fig.update_layout(
       plot_bgcolor="#ededed",
       hovermode=False,
       showlegend=True,
       xaxis_title=None,
       yaxis_title='Cost per kg carcass weight',
       yaxis_tickformat = "$.2f"
       )
    bar_fig.update_xaxes(
        fixedrange=True
        )
    bar_fig.update_yaxes(
        fixedrange=True
        )
    return bar_fig

# Define the attribution treemap
def create_attr_treemap_ecs(input_df, path):
    treemap_fig = px.treemap(
        input_df,
        # path=[
        #    'cause',
        #    'production_system',
        #    'age_group',
        #    'sex',
        #    'ahle_component',
        #    ],
        path = path,
        values='mean',
        # hover_data=['pct_of_total'],
        # custom_data=['pct_of_total'],
        color='cause',            # cause only applys to the cause level
        color_discrete_map={      # Cause colors match the Human health dashboard
            '(?)':'lightgrey',
            'Infectious':'#68000D',
            'Non-infectious':'#08316C',
            'External':'#00441B'
            }
        )

    return treemap_fig

# Define the AHLE waterfall
def create_ahle_waterfall_ecs(input_df, name, measure, x, y):
    waterfall_fig = go.Figure(go.Waterfall(
        name = name,
        orientation = "v",
        measure = measure,  # This needs to change with number of columns in waterfalll
        x=x,
        y=y,
        decreasing = {'marker':{"color":'#E84C3D'}},
        increasing = {'marker':{"color":'#3598DB'}},
        totals = {'marker':{"color":'#F7931D'}},
        connector = {"line":{"color":"darkgrey"}},
        customdata=np.stack((y, input_df['item']), axis=-1),
        ))

    waterfall_fig.update_layout(clickmode='event+select', ### EVENT SELECT ??????
                                plot_bgcolor="#ededed",)

    waterfall_fig.add_annotation(x=4, xref='x',         # x position is absolute on axis
                                 y=0, yref='paper',     # y position is relative [0,1] to work regardless of scale
                                 text="Source: GBADs",
                                 showarrow=False,
                                 yshift=10,
                                 font=dict(
                                     family="Helvetica",
                                     size=18,
                                     color="black"
                                     )
                                 )
    waterfall_fig.update_xaxes(
        fixedrange=True
        )
    waterfall_fig.update_yaxes(
        fixedrange=True
        )

    return waterfall_fig

# Define the stacked bar
def create_stacked_bar_ecs(input_df, x, y, text, color, yaxis_title):
    bar_fig = px.bar(
        input_df,
        x=x,
        y=y,
        text = text,
        color=color,
        color_discrete_map={
          "Neonatal male":"#2A80B9",
          "Neonatal":"#2A80B9",
          "Neonatal female":"#6eb1de",
          "Juvenile male":"#9B58B5",
          "Juvenile":"#9B58B5",
          "Juvenile female":"#caa6d8",
          "Adult male":"#2DCC70",
          "Adult female":"#82e3aa",
          })
    bar_fig.update_layout(
        plot_bgcolor="#ededed",
        hovermode=False,
        showlegend=True,
        xaxis_title=None,
        yaxis_title=yaxis_title,
        )
    bar_fig.update_xaxes(
        fixedrange=True
        )
    bar_fig.update_yaxes(
        fixedrange=True
        )
    return bar_fig

# Define Ethiopia subnation level map
def create_map_display_ecs(input_df, geojson, location, featurekey, color_by, color_scale):
    ecs_map_fig = px.choropleth_mapbox(input_df,
                                       geojson=geojson,
                                       locations=location,
                                       featureidkey=featurekey,
                                       color=color_by,
                                       color_continuous_scale=color_scale,
                                       opacity=0.7,
                                       mapbox_style="carto-positron",
                                       zoom=5,
                                       center = {"lat": 9.1450, "lon": 40.4897},
                                       labels={'region': 'State',
                                               'mean_current': 'Current',
                                               'mean_ideal': 'Ideal',
                                               'mean_diff_ideal': 'AHLE'}
                                       )

    return ecs_map_fig

# Wider Economic Impact charts for Ethiopia
def create_wei_chart(
        input_df                # Dataframe
        ,plot_xvar              # String: variable to use for x axis
        ,plot_yvar              # String: variable to use for y axis. Will be interpolated over range min(X), max(X).
        ,plot_color
        ,interpolation_kind     # 'linear', 'quadratic', or 'cubic'. Integer n: spline of order n.
        ,yvar_divisor=None      # Divide y values by this number before interpolation and plotting
    ):
    # Generate range of x-axis values
    gen_end = input_df[plot_xvar].max()
    step_size = 0.01
    gen_num = int(input_df[plot_xvar].max() / step_size)
    gen_x = np.linspace(
    	start=0 				# Start value. Can be integer or float.
    	,stop=gen_end 				# Stop value. Can be integer or float.
    	,num=gen_num 				# Number of elements to generate. Will be evenly spaced from START to STOP.
        )
    # Create dataframe and name generated data for predictor variable
    gen_x_df = pd.DataFrame({
        plot_xvar:gen_x
    })

    # Adjust scale
    if yvar_divisor:
        input_df[plot_yvar] = input_df[plot_yvar] / yvar_divisor

    # Get interpolation line
    interpolator = sp.interpolate.interp1d(
        input_df[plot_xvar]
        ,input_df[plot_yvar]
        ,kind=interpolation_kind
        )
    interp_y = interpolator(gen_x)		# Calculate y-axis values on fit line
    gen_x_df[plot_yvar] = interp_y

    # Plot data
    fig = px.scatter(
        input_df
        ,x=plot_xvar
        ,y=plot_yvar
        ,text='scenario'
        ,hover_name='scenario'
        ,hover_data={
            'scenario':False    # Used for hover name, remove from hover data
            }
        )
    fig.update_traces(
        marker_size=20
        ,marker_color=plot_color
        ,textposition='top center'
        )

    # Plot fit line
    fig_interp = px.scatter(
        gen_x_df
        ,x=plot_xvar
        ,y=plot_yvar
        )
    fig_interp.update_traces(
        mode='lines'
        ,line_width=2
        ,line_color=plot_color
        )
    fig.add_trace(fig_interp.data[0])

    # Draw
    fig.update_layout(xaxis_title=plot_xvar ,yaxis_title=plot_yvar)
    fig.update_xaxes(dtick=0.2)
    return fig

# Define the Biomass map
def create_biomass_map_ga(input_df, iso_alpha3, value, country, display):
    biomass_map_fig = px.choropleth(input_df,
                                    locations=iso_alpha3,
                                    color=value,
                                    hover_name=country, # column to add to hover information
                                    animation_frame="year",
                                    color_continuous_scale=px.colors.sequential.Plasma)
    biomass_map_fig.update_layout(
        geo=dict(
            showframe=False,
            showcoastlines=False,
            projection_type='equirectangular',
            ),
        coloraxis_colorbar=dict(
            title=f"{display}",
            ),
        )

    biomass_map_fig.add_annotation(x=0.50, xref='paper',         # x position is absolute on axis
                                 y=0.05, yref='paper',     # y position is relative [0,1] to work regardless of scale
                                 text="Source: GBADs",
                                 showarrow=False,
                                 font=dict(
                                     family="Helvetica",
                                     size=18,
                                     color="black"
                                     )
                                 )

    # Rename the animation frame
    biomass_map_fig.update_layout(sliders=[{"currentvalue": {"prefix": "Year="}}])

    return biomass_map_fig

# Define the biomass, pop, livewt line chart
# def create_line_chart_ga(input_df, year, biomass, population, liveweight, country):
def create_line_chart_ga(input_df, year, value, country, facet):
    bio_pop_live_line_fig = px.line(input_df, x=year,
                                    y=value,
                                    color=country,
                                    facet_row=facet,
                                    )

    bio_pop_live_line_fig.update_yaxes(matches=None, showticklabels=True)

    # Update yaxis properties
    bio_pop_live_line_fig.update_yaxes(title_text="Biomass (kg)", row=3, col=1)
    bio_pop_live_line_fig.update_yaxes(title_text="Population (head)", row=2, col=1)
    bio_pop_live_line_fig.update_yaxes(title_text="Live Weight (kg)", row=1, col=1)

    # Remove facet titles
    bio_pop_live_line_fig.for_each_annotation(lambda a: a.update(text=a.text.replace("facet=biomass", "")))
    bio_pop_live_line_fig.for_each_annotation(lambda a: a.update(text=a.text.replace("facet=population", "")))
    bio_pop_live_line_fig.for_each_annotation(lambda a: a.update(text=a.text.replace("facet=liveweight", "")))


    bio_pop_live_line_fig.update_layout(
    title="Biomass, Population, and Live Weight Over Time <br><sup> Double click country in legend to isolate</sup>",
    xaxis_title="Year",
    legend_title="Country",
    plot_bgcolor="#ededed",
    )

    return bio_pop_live_line_fig

def create_ahle_waterfall_ga(input_df, name, measure, x, y):
    waterfall_fig = go.Figure(go.Waterfall(
        name = name,
        orientation = "v",
        measure = measure,  # This needs to change with number of columns in waterfalll
        x=x,
        y=y,
        # text=text,
        # hoverinfo = 'none',
        # textposition = ["outside","outside","auto","auto","outside"],
        decreasing = {'marker':{"color":'#E84C3D'}},
        increasing = {'marker':{"color":'#3598DB'}},
        totals = {'marker':{"color":'#F7931D'}},
        connector = {"line":{"color":"darkgrey"}}#"rgb(63, 63, 63)"}},
        ))

    waterfall_fig.update_layout(clickmode='event+select', ### EVENT SELECT ??????
                                plot_bgcolor="#ededed",)

    waterfall_fig.add_annotation(x=4, xref='x',         # x position is absolute on axis
                                 y=0, yref='paper',     # y position is relative [0,1] to work regardless of scale
                                 text="Source: GBADs",
                                 showarrow=False,
                                 yshift=10,
                                 font=dict(
                                     family="Helvetica",
                                     size=18,
                                     color="black"
                                     )
                                 )

    return waterfall_fig


def create_map_display_amu(input_df, value):
    # Add graphing country column for map
    input_df['graphing_country'] = 'TEST'
    input_df['graphing_country'] = np.where(input_df['region']=='Africa', 'Chad', input_df['graphing_country'])
    input_df['graphing_country'] = np.where(input_df['region']=='Americas', 'Guatemala', input_df['graphing_country'])
    input_df['graphing_country'] = np.where(input_df['region']=='Asia, Far East and Oceania', 'China', input_df['graphing_country'])
    input_df['graphing_country'] = np.where(input_df['region']=='Europe', 'Hungary', input_df['graphing_country'])
    input_df['graphing_country'] = np.where(input_df['region']=='Middle East', 'Saudi Arabia', input_df['graphing_country'])


    amu_map_fig = px.scatter_geo(input_df,
                                 locations="graphing_country",
                                 locationmode='country names',
                                 color="region",
                                 hover_name="region",
                                 size=value,
                                 projection="natural earth",
                                 custom_data=['region', value, 'number_of_countries'],
                                 color_discrete_map={"Asia, Far East and Oceania": 'rgb(102,197,204)',
                                                     "Americas": 'rgb(248,156,116)',
                                                     "Europe": 'rgb(220,176,242)',
                                                     "Africa": 'rgb(135,197,95)',
                                                     "Middle East": 'rgb(254,136,177)'}
                                 )

    return amu_map_fig

def create_donut_chart_amu(input_df, value, names):

    pie_fig = go.Figure(data=[go.Pie(labels=names,
                                      values=value,
                                      hovertemplate = "%{label}: <br>%{percent} </br><extra></extra>"
                                      )])

    # show % values inside
    pie_fig.update_traces(textposition='inside')
    pie_fig.update_layout(uniformtext_minsize=12, uniformtext_mode='hide')

    # Use `hole` to create a donut-like pie chart
    pie_fig.update_traces(hole=.4, hoverinfo="label+percent+name")

    # Sort legend based on data sort rather than pie values
    pie_fig.update_traces(sort=False)

    return pie_fig

def create_tree_map_amu(input_df, value, categories):
    tree_map_fig = px.treemap(input_df,
                              path=[px.Constant("Global"), 'region_with_countries_reporting', categories, 'antimicrobial_class'],
                              values=value,
                              maxdepth=3,
                              color='region',
                              # color_discrete_map={'(?)':'lightgrey', 'Africa':'#636FFA', 'Americas':'#EF553B', 'Asia, Far East and Oceania':'#00CC97', 'Europe':'#AB63FA', 'Middle East':'#FFC091'},
                              color_discrete_map={'(?)':'lightgrey', 'Africa':'rgb(135,197,95)', 'Americas':'rgb(248,156,116)', 'Asia, Far East and Oceania':'rgb(102,197,204)', 'Europe':'rgb(220,176,242)', 'Middle East':'rgb(254,136,177)'},
                              )

    # # Add value to bottom leaf node labels
    # tree_map_fig.data[0].textinfo = 'label+text+value'

    return tree_map_fig

# This function creates a plotly treemap with an option to show weighted averages
# instead of sums for boxes above the base level.
# It first calculates weighted averages using a pivot table, then draws the treemap by
# specifying the id and parent for each box.
# 2023/3/22: There is a bug causing a blank chart when AGGREGATION == 'mean'. Not using this at this time.
def create_treemap_withagg(
        INPUT_DF
        ,HIERARCHY              # List: categorical variables that define hierarchy, in desired order most to least aggregated
        ,COLOR_BY               # String: variable to color by. WARNING: must be one of the variables in HIERARCHY.
        ,VALUE_VAR              # String: variable with values to plot
        ,AGGREGATION='sum'      # String: how to aggregate VALUE_VAR. 'sum' (default) or 'mean'.
        ,WEIGHT_VAR=None        # String (optional): variable to use for weighting if AGGREGATION='mean'.
    ):
    if AGGREGATION == 'mean':
        dfmod = INPUT_DF.copy()

        # Create weighted value
        if WEIGHT_VAR:
            dfmod['treemap_weight'] = dfmod[WEIGHT_VAR]
        else:
            dfmod['treemap_weight'] = 1
        dfmod['treemap_weighted_value'] = dfmod[VALUE_VAR] * dfmod['treemap_weight']

        # For each variable in the hierarchy, create summary rows where that variable is ALL
        # Calculate the mean of the weighted value
        treemap_df = pd.DataFrame()     # Initialize dataframe to hold results
        for i ,VAR in enumerate(HIERARCHY):
            summary_rows = dfmod.pivot_table(
                index=HIERARCHY[:i+1]     # Index is all hierarchy variables up to i
                ,values=['treemap_weighted_value' ,'treemap_weight']
                ,aggfunc='sum'
                ).reset_index()
            # summary_rows['treemap_value'] = summary_rows['treemap_weighted_value'] / summary_rows['treemap_weight']
            treemap_df = pd.concat([treemap_df ,summary_rows] ,axis=0 ,ignore_index=True)

        # Add a row for the global total
        global_row = pd.DataFrame(dfmod[['treemap_weighted_value' ,'treemap_weight']].sum()).transpose()
        treemap_df = pd.concat([global_row ,treemap_df] ,axis=0 ,ignore_index=True)

        # Calculate weighted mean
        treemap_df['treemap_value'] = treemap_df['treemap_weighted_value'] / treemap_df['treemap_weight']

        # Drop rows with zero or negative value - these cause plotly to fail silently!
        treemap_df = treemap_df.query("treemap_value > 0")

        # Add columns for id and parent
        treemap_df['treemap_id'] = treemap_df[f'{HIERARCHY[0]}'].str.cat(treemap_df[HIERARCHY[1:]] ,sep='|' ,na_rep='_all_')
        treemap_df['treemap_id'] = treemap_df['treemap_id'].str.replace('|_all_' ,'' ,regex=False)
        treemap_df[['treemap_parent' ,'treemap_parent_remainder']] = treemap_df['treemap_id'].str.rsplit('|' ,n=1 ,expand=True)

        treemap_df.loc[treemap_df['treemap_parent_remainder'].isnull() ,'treemap_parent'] = '_all_'  # First level of hierarchy gets parent _all_
        treemap_df.loc[treemap_df['treemap_id'] == '_all_' ,'treemap_parent'] = ''  # Global level of hierarchy gets parent blank

        # Draw tree map
        # Figure is blank with no errors!!
        tree_map_fig = px.treemap(
            ids=treemap_df['treemap_id']
            ,parents=treemap_df['treemap_parent']
            ,values=treemap_df['treemap_value']
            ,color=treemap_df[COLOR_BY]
            )

        # Figure is blank with no errors!!
        # tree_map_fig = go.Figure(go.Treemap(
        #     ids=treemap_df['treemap_id']
        #     ,parents=treemap_df['treemap_parent']
        #     ,values=treemap_df['treemap_value']
        #     ))

    elif AGGREGATION == 'sum':
        tree_map_fig = px.treemap(
            INPUT_DF
            ,path=HIERARCHY
            ,values=VALUE_VAR
            ,color=COLOR_BY
            )

    return tree_map_fig

#%% 4. LAYOUT
##################################################################################################
# Here we layout the webpage, including dcc (Dash Core Component) controls we want to use, such as dropdowns.
##################################################################################################
gbadsDash.layout = html.Div([

    #### BRANDING & HEADING
    dbc.Row([
        # GBADs Branding
        dbc.Col(
            html.Div([
                html.A(href="https://animalhealthmetrics.org/",
                       children=[
                       html.Img(title="Link to GBADS site", src=(os.environ.get("DASH_BASE_URL") if os.environ.get("DASH_BASE_URL") else "") + '/assets/GBADs-LOGO-Black-sm.png')
                       ]
                       ),
                html.H3("Inclusiveness Challenge Delivery Rigour Transparency",
                        style={"font-style": "italic",
                               "margin": "0",
                               "padding": "0"}),
                ], style = {'margin-left':"10px",
                            "margin-bottom":"10px",
                            'margin-right':"10px"},
                )
            ),
        ], justify='between'),

    #### Data to pass between callbacks
    dcc.Store(id='core-data-poultry'),
    dcc.Store(id='core-data-swine'),
    dcc.Store(id='amu-regional-data'),

    #### TABS
    dcc.Tabs([

        #### USER GUIDE TAB
        dcc.Tab(label="User Guide & References", children =[
            html.Iframe(src="assets/GBADs_Documentation/_build/html/index.html", # this is for the jupyter books
                        style={"width":"100%",
                                "height":"3600px",   # Set large enough for your largest page and guide will use browser scroll bar. Otherwise, longer pages will get their own scroll bars.
                                },)
        ### END OF USER GUIDE TAB
            ], style=user_guide_tab_style, selected_style=user_guide_tab_selected_style),

        #### GLOBAL OVERVIEW TAB
        dcc.Tab(label="Global Overview [WIP]", children = [

            #### -- COUNTRY AND SPECIES CONTROLS
            dbc.Row([
                # Region-country alignment
                dbc.Col([
                    html.H6('Region-country alignment'),
                    dcc.RadioItems(id='Region-country-alignment-overview-ga',
                                    options=region_structure_options_ga,
                                    inputStyle={"margin-right": "10px", # This pulls the words off of the button
                                                "margin-left":"20px"},
                                    value="World Bank",
                                    style={"margin-left":'-20px'})
                    ],
                    style={
                            "margin-top":"10px",
                            "margin-right":"70px",
                            }

                    ),
                # Region
                dbc.Col([
                    html.H6("Region"),
                    dcc.Dropdown(id='select-region-overview-ga',
                                  options=wb_region_options_ga,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                # Income Group
                dbc.Col([
                    html.H6("Income Group"),
                    dcc.Dropdown(id='select-incomegrp-overview-ga',
                                  options=incomegrp_options_ga,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                # Country
                dbc.Col([
                    html.H6("Country"),
                    dcc.Dropdown(id='select-country-overview-ga',
                                  options=country_options_ga,
                                  # value='All',
                                  value='Ethiopia', #!!! - for testing
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                  # Species
                  dbc.Col([
                      html.H6("Species"),
                      dcc.Dropdown(id='select-species-ga',
                                  options=ga_species_options,
                                  value='Cattle',
                                  clearable = False,
                                  )
                      ],style={
                              "margin-top":"10px",
                              },
                      ),
                ], justify='evenly', style={"margin-right": "10px"}),

            #### -- VISUALIZATION SWITCH
            # Select Visual Control
            dbc.Card([
                dbc.CardBody([
                    html.H5("Select Visualization",
                            className="card-title",
                            style={"font-weight": "bold"}),

            dbc.Row([ # Row with Control for Visuals

                    # Visualization
                    dbc.Col([
                        html.H6("Visualize"),
                        dcc.RadioItems(
                            id='viz-radio-ga',
                            options=['Map', 'Line chart'],
                            value='Map',
                            inputStyle={"margin-right": "2px", # This pulls the words off of the button
                                        "margin-left": "10px"},
                            ),
                        ]),

                    # Map Display options
                    dbc.Col([
                        html.H6("Map Display"),
                        # dcc.RadioItems(
                        dcc.Dropdown(
                            id='map-display-radio-ga',
                            options=map_display_options_ga,
                            value='Population',
                            # inputStyle={"margin-right": "2px", # This pulls the words off of the button
                            #             "margin-left": "10px"},
                            ),
                        ]),

            ]), # END OF ROW

                # END OF CARD BODY
                ]),

            ], color='#F2F2F2', style={"margin-right": "10px"}), # END OF CARD

            html.Hr(style={'margin-right':'10px',}),
            html.Br(),

            #### -- GRAPHICS
            dbc.Row([  # Row with GRAPHICS

                dbc.Col([ # Global Aggregation Visual
                    dbc.Spinner(children=[
                    dcc.Graph(id='ga-map-or-line-select',
                                style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Global_Agg_Viz'
                                      },
                                  }
                              )
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of Map
                    ]),

            html.Br(),
            # END OF GRAPHICS ROW
            ],),

        #### -- DATATABLE
        dbc.Row([
            dbc.Spinner(children=[
            dbc.Col([
                html.Div([  # Core data for AHLE
                      html.Div( id='ga-world-abt-datatable'),
                ], style={'margin-left':"20px"}),

            html.Br() # Spacer for bottom of page
            ]),# END OF COL
            # End of Spinner
            ],size="md", color="#393375", fullscreen=False),
        ]),
        html.Br(),
        ### END OF DATATABLE

        ### END OF GLOBAL AGGREGATE TAB
        ], style=global_tab_style, selected_style=global_tab_selected_style),

        #### GLOBAL AHLE DETAILS TAB
        dcc.Tab(label="Global AHLE Details [WIP]", children = [

            #### -- COUNTRY AND CHART CONTROLS
            dbc.Row([
                # Display
                dbc.Col([
                    html.H6("Display"),
                    dcc.RadioItems(id='select-display-ga',
                                  options=ecs_display_options,
                                  value='Difference',
                                  labelStyle={'display': 'block'},
                                  inputStyle={"margin-right": "2px"}, # This pulls the words off of the button
                                  ),
                    ],
                    style={
                            "margin-top":"10px",
                            "margin-right":"70px",
                            }
                ),
                # Region-country alignment
                dbc.Col([
                    html.H6('Region-country alignment'),
                    dcc.RadioItems(id='Region-country-alignment-detail-ga',
                                    options=region_structure_options_ga,
                                    inputStyle={"margin-right": "10px", # This pulls the words off of the button
                                                "margin-left":"20px"},
                                    value="World Bank",
                                    style={"margin-left":'-20px'})
                    ],
                    style={
                            "margin-top":"10px",
                            "margin-right":"70px",
                            }

                    ),
                # Region
                dbc.Col([
                    html.H6("Region"),
                    dcc.Dropdown(id='select-region-detail-ga',
                                  options=wb_region_options_ga,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                # Income Group
                dbc.Col([
                    html.H6("Income Group"),
                    dcc.Dropdown(id='select-incomegrp-detail-ga',
                                options=incomegrp_options_ga,
                                value='All',
                                clearable = False,
                                ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                # Country
                dbc.Col([
                    html.H6("Country"),
                    dcc.Dropdown(id='select-country-detail-ga',
                                  options=country_options_ga,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),
                ], style={"margin-right": "10px"}), # END OF ROW

            #### -- CHART SPECIFIC AND BOTH CONTROLS
            dbc.Row([
                # AHLE Specific Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Output Values and Costs Graph Controls",
                                    className="card-title",
                                    style={"font-weight": "bold"}),
                            dbc.Row([
                            # Year
                            dbc.Col([
                                html.H6("Year"),
                                dcc.Dropdown(id='select-year-ga',
                                              options=year_options_ga,
                                              value=2020,
                                              clearable = False,
                                              ),
                                ],style={
                                          "margin-top":"10px",
                                          },
                                ),
                            ]), # END OF ROW
                    # END OF CARD BODY
                    ],),

                    # END OF CARD
                    ], color='#F2F2F2',),
                ],  width=3),

                    #### -- MORTALITY AND OTHER CONTROLS
                    dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Exploring Contributions to AHLE (Not Active)",
                                    className="card-title",
                                    style={"font-weight": "bold"}),
                    dbc.Row([  # Line up all the controls in the same row.

                        # Base mortality rate
                        dbc.Col([
                            html.H6("Base mortality rate"),
                            html.Br(),
                            daq.Slider(
                                id='base-mortality-rate-ga',
                                min=1,
                                max=10,
                                handleLabel={"showCurrentValue": True,"label": "%"},
                                step=1,
                                value=mortality_rate_ga_default,
                                ),
                            ],style={
                                      "margin-top":"10px",
                                      }
                            ,),

                        # Base morbidity rate
                        dbc.Col([
                            html.H6("Base morbidity rate"),
                            html.Br(),
                            daq.Slider(
                                id='base-morbidity-rate-ga',
                                min=1,
                                max=10,
                                handleLabel={"showCurrentValue": True,"label": "%"},
                                step=1,
                                value=morbidity_rate_ga_default,
                                ),
                            ],style={
                                      "margin-top":"10px",
                                      }
                            ,),

                        # Live weight price
                        dbc.Col([
                            html.H6("Live weight price (USD per kg)"),
                            html.Br(),
                            daq.Slider(
                                id='base-live-weight-price-ga',
                                min=0.70,
                                max=3.25,
                                handleLabel={"showCurrentValue": True,"label": "$"},
                                step=.01,
                                value=live_weight_price_ga_default,
                                ),
                            ],style={
                                      "margin-top":"10px",
                                      }
                            ,),

                        ## END OF ROW ##
                        ], justify='evenly'),

                    # END OF CARD BODY
                    ],),

                    # END OF CARD
                    ], color='#F2F2F2'),
                    ], width=6),

                # Item Over Time Specific Controls
                dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H5("Item Over Time Graph Controls",
                                className="card-title",
                                style={"font-weight": "bold"}),
                        dbc.Row([

                          # Item
                          dbc.Col([
                              html.H6("Item"),
                              dcc.Dropdown(id='select-item-ga',
                                            options=item_options_ga,
                                            value=item_list_ga[-1],   # Default is last item in list
                                            clearable = False,
                                            ),
                              ],style={
                                        "margin-top":"10px",
                                        },
                              ),
                        ]), # END OF ROW

                # END OF CARD BODY
                ],),

                # END OF CARD
                ], color='#F2F2F2'),
                ], width=3),

                ], style={"margin-right": "10px"}),

            html.Br(),

            #### -- GRAPHICS ROW
            dbc.Row([
                # Side by side waterfall
                dbc.Col([
                    dbc.Spinner(children=[
                        dcc.Graph(id='ga-ahle-waterfall',
                                  style = {"height":"650px"},
                                  config = {
                                      "displayModeBar" : True,
                                      "displaylogo": False,
                                      'toImageButtonOptions': {
                                          'format': 'png', # one of png, svg, jpeg, webp
                                          'filename': 'GBADs_GlobalAggregate_AHLE_Waterfall'
                                          },
                                      'modeBarButtonsToRemove': ['zoom',
                                                                  'zoomIn',
                                                                  'zoomOut',
                                                                  'autoScale',
                                                                  #'resetScale',  # Removes home button
                                                                  'pan',
                                                                  'select2d',
                                                                  'lasso2d']
                                      }
                                  )
                        # End of Spinner
                        ],size="md", color="#393375", fullscreen=False),
                    # End of Side by side waterfall
                    ],style={"width":5}),

                # Plot over time
                dbc.Col([
                    dbc.Spinner(children=[
                        dcc.Graph(id='ga-ahle-over-time',
                                  style = {"height":"650px"},
                                  config = {
                                      "displayModeBar" : True,
                                      "displaylogo": False,
                                      'toImageButtonOptions': {
                                          'format': 'png', # one of png, svg, jpeg, webp
                                          'filename': 'GBADs_GlobalAggregate_AHLE_Overtime'
                                          },
                                      'modeBarButtonsToRemove': ['zoom',
                                                                  'zoomIn',
                                                                  'zoomOut',
                                                                  'autoScale',
                                                                  #'resetScale',  # Removes home button
                                                                  'pan',
                                                                  'select2d',
                                                                  'lasso2d']
                                      }
                                  )
                        # End of Spinner
                        ],size="md", color="#393375", fullscreen=False),
                    # End of plot over time
                    ],style={"width":5}),
                ]),

        #### -- FOOTNOTES
        dbc.Row([
            dbc.Col([
                # Waterfall chart
                html.P("Ideal values assume increased production if there were no morbidity or mortality"),
                html.P("Antimicrobial Expenditure shown is the estimated global total based on usage and price selected on the Antimicrobial Usage tab."),
                # html.P("Using morbidity and mortality rates according to income group"),
                ]),

            # # Regional AM Expenditure Estimator Button
            # dbc.Col([
            #     dcc.Link(
            #         dbc.Button(id="am-expend-button-ga",
            #             children='Antimicrobial Expenditure',
            #                     # style={'color': 'white',
            #                     #        'backgroundColor': '#101820',
            #                     #        'fontSize': '15px ',
            #                     #        'width': '150px',
            #                     #        'height': '50px',
            #                     #        'marginLeft': '10px',
            #                     #        'marginRight': '100px',
            #                     #        }
            #                     ),
            #         href='#AMU-regional-expenditure', refresh=True),

            #     # html.Button('Antimicrobial Expenditure', id='am-expend-button-ga'),
            #     ]),

            dbc.Col([
                # Line chart
                html.P(""),
                ]),
            ], style={'margin-left':"40px",
                      'font-style': 'italic',
                      "margin-right": "20px"}
            ),
        html.Br(),

        #### -- DATATABLE
        dbc.Spinner(children=[
            html.Div([  # Row with DATATABLE
                      html.Div( id='ga-detailtab-displaytable'),
                      ], style={'margin-left':"20px",
                                "margin-right": "10px",
                                # "width":"95%"
                                }
                      ),
            # End of Spinner
            ],size="md", color="#393375", fullscreen=False),
        html.Br(), # Spacer for bottom of page

        ### END OF GLOBAL AHLE DETAILS TAB
        ], style=global_tab_style, selected_style=global_tab_selected_style),

        #### POULTRY TAB
        dcc.Tab(label="Major Producers | Poultry", children = [

            #### -- COUNTRY AND YEAR CONTROLS
            dbc.Row([
                # Region-country alignment
                dbc.Col([
                    html.H6('Region-country alignment'),
                    dcc.RadioItems(id='Region-country-alignment-poultry',
                                    options=region_structure_options,
                                    inputStyle={"margin-right": "10px", # This pulls the words off of the button
                                                "margin-left":"20px"},
                                    value="WOAH",
                                    style={"margin-left":'-20px'})
                    ],
                    style={
                            "margin-top":"10px",
                            "margin-right":"70px",
                            }

                    ),
                # Region
                dbc.Col([
                    html.H6("Region"),
                    dcc.Dropdown(id='select-region-poultry',
                                  options=WOAH_region_options,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),

                # Country
                dbc.Col([
                    html.H6("Country"),
                    dcc.Dropdown(id='select-country-poultry',
                                  options=country_options_poultry,
                                  value='United Kingdom',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px",
                              },
                    ),

                  # Year
                  dbc.Col([
                      html.H6("Year"),
                      dcc.Dropdown(id='select-year-poultry',
                                  options=year_options_poultry,
                                  value=2020,
                                  clearable = False,
                                  )
                      ],style={
                              "margin-top":"10px",
                              },
                      ),

              # Metric
                dbc.Col([
                    html.H6("Metric"),
                    dcc.Dropdown(id='select-metric-poultry',
                                  options=metric_options,
                                  value="tonnes",
                                  clearable = False,
                                  )
                    ],style={
                              "margin-top":"10px",
                              "margin-right": '10px',
                              },
                    ),

                ], justify='evenly'),


            html.Hr(style={'margin-right':'10px',}),

            #### -- CALCULATION CONTROLS
            dbc.Row([  # Line up all the controls in the same row.

                # Days on Feed
                dbc.Col([
                    html.H6("Days on feed"),
                    html.Br(),
                    daq.Slider(
                        id='dof-slider-poultry',
                        min=20,
                        max=60,
                        handleLabel={"showCurrentValue": True,"label": "Days"},
                        step=1,
                        value=dof_poultry_default,
                        ),

                    # Text underneath slider
                    html.P(id='reference-dof-poultry'),
                      ],style={'width': "auto",
                              # 'margin-left':'-40px',
                              }
                    ),

                # Achievable weight as percent of breed standard
                dbc.Col([
                    html.H6("Achievable % of breed standard"),
                    html.Br(),
                    daq.Slider(
                        id='achievable-pct-slider-poultry',
                        min=90,
                        max=110,
                        handleLabel={"showCurrentValue": True,"label": "%"},
                        step=1,
                        value=achievable_pct_poultry_default,
                        ),

                    # Text underneath slider
                      html.P(id='reference-achievable-pct-poultry'),
                      ],style={'width': "auto",
                              }
                      ),

                # Price to Producers Upon Sale
                dbc.Col([
                    html.H6("Producer price (USD per kg carcass wt.)"),
                    html.Br(),
                    daq.Slider(
                        id='producer-price-slider-poultry',
                        min=0.70,
                        max=3.25,
                        handleLabel={"showCurrentValue": True,"label": "$"},
                        step=.01,
                        value=producer_price_poultry_default
                        ),

                    # Text underneath slider
                    html.P(id='reference-producerprice-poultry'),
                    ],style={'width': "auto",
                              }
                    ),

                # Ration prices
                dbc.Col([
                    html.H6("Feed price (USD per tonne)"),
                    html.Br(),
                    daq.Slider(
                        id='ration-price-slider-poultry',
                        min=200,
                        max=500,
                        handleLabel={"showCurrentValue": True,"label": "$"},
                        step=10,
                        value=ration_price_poultry_default
                        ),

                    # Text underneath slider
                    html.P(id='reference-feedprice-poultry'),
                    ],style={'width': "auto",
                              }
                    ),

                # FCR
                dbc.Col([
                    html.H6("Ideal feed conversion ratio"),
                    html.Br(),
                    daq.Slider(
                        id='fcr-slider-poultry',
                        min=1,
                        max=2.5,
                        handleLabel={"showCurrentValue": True,"label": "FCR"},
                        step=0.1,
                        value=fcr_poultry_default,
                        ),
                    # Text underneath slider
                    html.P(id='reference-fcr-poultry'),
                    ],style={'width': "auto",
                              'margin-right':'20px'}
                    ),

                # Reset to defaults button
                dbc.Col([
                    html.Button('Reset to default', id='reset-val-poultry', n_clicks=0),
                ],style={'width': "auto",
                          'textAlign':'center',
                          'margin':'auto',}
                ),

                ## END OF POULTRY TAB CONTROLS ROW ##
                ], justify='evenly',
                ),

        html.Hr(style={'margin-right':'10px',}),

        #html.Hr(),

        #### -- GRAPHICS
        dbc.Row([  # Row with GRAPHICS

            dbc.Col([ # Poultry Waterfall
                dbc.Spinner(children=[
                dcc.Graph(id='poultry-waterfall',
                            style = {"height":"650px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_Poultry_Waterfall'
                                  },
                              'modeBarButtonsToRemove': ['zoom',
                                                          'zoomIn',
                                                          'zoomOut',
                                                          'autoScale',
                                                          #'resetScale',  # Removes home button
                                                          'pan',
                                                          'select2d',
                                                          'lasso2d']
                              }
                          )
                # End of Spinner
                ],size="md", color="#393375", fullscreen=False),
                # End of Waterfall
                ],style={"width":5}),

            # dbc.Col([ # Poultry Sankey
            #     dbc.Spinner(children=[
            #     dcc.Graph(id='poultry-sankey',
            #                 style = {"height":"650px"},
            #               config = {
            #                   "displayModeBar" : True,
            #                   "displaylogo": False,
            #                   'toImageButtonOptions': {
            #                       'format': 'png', # one of png, svg, jpeg, webp
            #                       'filename': 'GBADs_Poultry_Sankey'
            #                       },
            #                   'modeBarButtonsToRemove': ['select2d',
            #                                              'lasso2d',
            #                                              'resetSCale']
            #                   })
            #         # End of Spinner
            #         ],size="md", color="#393375", fullscreen=False),
            #         # End of Sankey
            #         ],style={"width":5}
            #         ),

            dbc.Col([ # Poultry Stacked Bar
                dbc.Spinner(children=[
                dcc.Graph(id='poultry-stacked-bar',
                          style = {"height":"650px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_Poultry_Stacked_Bar'
                                  },
                              'modeBarButtonsToRemove': ['zoom',
                                                          'zoomIn',
                                                          'zoomOut',
                                                          'autoScale',
                                                          #'resetScale',  # Removes home button
                                                          'pan',
                                                          'select2d',
                                                          'lasso2d']
                              })
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of Stacked Bar
                    ],style={"width":5}
                    ),
            ]),
        html.Br(),

        #### -- FOOTNOTES
        dbc.Row([
            dbc.Col([
              # Breed Standard Potential source
              html.P(id='waterfall-footnote-poultry'),
            ]),
            dbc.Col([
              # Cost Assumptions
              html.P("Ideal costs are those required to achieve realised production if there were no mortality or morbidity."),
              ]),
        ], style={'margin-left':"40px", 'font-style': 'italic'}
        ),
        html.Br(),

        #### -- DATATABLE
        html.Div([  # Row with DATATABLE
                  html.Div( id='poultry-background-data'),
            ], style={'margin-left':"20px",
                        "width":"95%"}),
        html.Br(), # Spacer for bottom of page

        html.Div([  # Breed standard data
                  html.Div( id='poultry-breed-data'),
            ], style={'margin-left':"20px",
                      "width":"12%",}),
        html.Br() # Spacer for bottom of page

        ### END OF POULTRY TAB
        ], style=major_producers_tab_style, selected_style=major_producers_tab_selected_style),

        #### SWINE TAB
        dcc.Tab(label="Major Producers | Swine", children = [

            #### -- COUNTRY AND YEAR CONTROLS
            dbc.Row([
                # Region-country alignment
                dbc.Col([
                    html.H6('Region-country alignment'),
                    dcc.RadioItems(id='Region-country-alignment-swine',
                                    options=region_structure_options,
                                    inputStyle={"margin-right": "10px",
                                                "margin-left":"20px"},
                                    value="WOAH",
                                    style={"margin-left":'-20px'})
                    ],style={
                        "margin-top":"10px",
                        "margin-right":"70px",
                            }

                    ),
                # Region
                dbc.Col([
                    html.H6("Region"),
                    dcc.Dropdown(id='select-region-swine',
                                  options=WOAH_region_options,
                                  value='All',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px"
                              }
                    ),

                # Country
                dbc.Col([
                    html.H6("Country"),
                    dcc.Dropdown(id='select-country-swine',
                                  options=country_options_swine,
                                  value='United Kingdom',
                                  clearable = False,
                                  ),
                    ],style={
                              "margin-top":"10px"
                              },
                    ),

                  # Year
                  dbc.Col([
                      html.H6("Year"),
                      dcc.Dropdown(id='select-year-swine',
                                  options=year_options_swine,
                                  value=2020,
                                  clearable = False,
                                  )
                      ],style={
                              "margin-top":"10px"
                              },
                      ),

                # Metric
                dbc.Col([
                    html.H6("Metric"),
                    dcc.Dropdown(id='select-metric-swine',
                                  options=metric_options,
                                  value="tonnes",
                                  clearable = False,
                                  )
                    ],style={
                              "margin-top":"10px",
                              "margin-right": '10px',
                              },
                    ),

                ], justify='evenly'),


            html.Hr(style={'margin-right':'10px'}),

            #### -- CALCULATION CONTROLS
            dbc.Row([  # Line up all the controls in the same row.

                # Days on Feed
                dbc.Col([
                    html.H6("Days on feed"),
                    html.Br(),
                    daq.Slider(
                        id='dof-slider-swine',
                        min=112,
                        max=196,
                        handleLabel={"showCurrentValue": True,"label": "Days"},
                        step=7,
                        value=dof_swine_default,
                        ),
                    ],style={'width': "auto",
                              }
                    ),

                # Feed Intake
                # Alternative to Days on Feed for determining breed standard potential
                  # dbc.Col([
                  #     html.H6("Feed intake (kg per head)"),
                  #     html.Br(),
                  #     daq.Slider(
                  #         id='feed-slider-swine',
                  #         min=80,
                  #         max=355,
                  #         handleLabel={"showCurrentValue": True,"label": "kg"},
                  #         step=5,
                  #         value=feed_swine_default,
                  #         ),
                  #     html.P(id='reference-feedintake-swine'),
                  #      ],style={'width': "auto",
                  #               }
                  #     ),

                # Achievable weight in kg
                # Alternative to Achievable Percent for determining effect of feed and practices
                dbc.Col([
                    html.H6("Achievable live weight without disease (kg)"),
                    html.Br(),
                    daq.Slider(
                      id='achievable-weight-slider-swine',
                      min=70,
                      max=180,
                      handleLabel={"showCurrentValue": True,"label": "kg"},
                      step=5,
                      value=achievable_weight_swine_default,
                      ),
                    # Text underneath slider
                    html.P(id='reference-liveweight-swine'),
                    ],style={'width': "auto",
                            }
                    ),

                # Price to Producers Upon Sale
                dbc.Col([
                    html.H6("Producer price (USD per kg carcass wt.)"),
                    html.Br(),
                    daq.Slider(
                        id='producer-price-slider-swine',
                        min=0.70,
                        max=3.25,
                        handleLabel={"showCurrentValue": True,"label": "$"},
                        step=.01,
                        value=producer_price_swine_default,
                        ),
                    # Text underneath slider
                    html.P(id='reference-producerprice-swine'),
                    ],style={'width': "auto",
                              }
                    ),

                # Ration prices
                dbc.Col([
                    html.H6("Feed price (USD per tonne)"),
                    html.Br(),
                    daq.Slider(
                        id='ration-price-slider-swine',
                        min=200,
                        max=500,
                        handleLabel={"showCurrentValue": True,"label": "$"},
                        step=10,
                        value=ration_price_swine_default,
                        ),
                    # Text underneath slider
                    html.P(id='reference-feedprice-swine'),
                    ],style={'width': "auto",
                              'margin-right':'20px'}
                    ),

                # FCR
                dbc.Col([
                    html.H6("Ideal feed conversion ratio"),
                    html.Br(),
                    daq.Slider(
                        id='fcr-slider-swine',
                        min=1.5,
                        max=3,
                        handleLabel={"showCurrentValue": True,"label": "FCR"},
                        step=0.1,
                        value=fcr_swine_default,
                        ),
                    # Text underneath slider
                    html.P(id='reference-fcr-swine'),
                    ],style={'width': "auto",
                              'margin-right':'20px'}
                    ),

                # Reset to defaults button
                dbc.Col([
                    html.Button('Reset to default', id='reset-val-swine', n_clicks=0),
                ],style={'width': "auto",
                          'textAlign':'center',
                          'margin':'auto',}
                ),

                ## END OF SWINE TAB CONTROLS ROW ##
                ], # justify='evenly',
                          #    style={'vertical-align':'top',
                          # 'display':'flex',
                          # 'no-gutters':True}
                ),

        #### -- GRAPHICS
        dbc.Row([  # Row with GRAPHICS

            dbc.Col([ # Swine Waterfall
                dbc.Spinner(children=[
                dcc.Graph(id='swine-waterfall',
                          style = {"height":"650px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_Swine_Waterfall'
                                  },
                              'modeBarButtonsToRemove': ['zoom',
                                                          'zoomIn',
                                                          'zoomOut',
                                                          'autoScale',
                                                          #'resetScale',  # Removes home button
                                                          'pan',
                                                          'select2d',
                                                          'lasso2d']
                              }
                          )
                # End of Spinner
                ],size="md", color="#393375", fullscreen=False),
                # End of Waterfall
                ],style={"width":5}),

            # dbc.Col([ # Swine Sankey
            #     dbc.Spinner(children=[
            #     dcc.Graph(id='swine-sankey',
            #               style = {"height":"650px"},
            #               config = {
            #                   "displayModeBar" : True,
            #                   "displaylogo": False,
            #                   'toImageButtonOptions': {
            #                       'format': 'png', # one of png, svg, jpeg, webp
            #                       'filename': 'GBADs_Swine_Sankey'
            #                       },
            #                   'modeBarButtonsToRemove': ['select2d',
            #                                              'lasso2d',
            #                                              'resetSCale']
            #                   })
            #         # End of Spinner
            #         ],size="md", color="#393375", fullscreen=False),
            #         # End of Sankey
            #         ],style={"width":5}
            #         ),

            dbc.Col([ # Swine Stacked Bar
                dbc.Spinner(children=[
                dcc.Graph(id='swine-stacked-bar',
                            style = {"height":"650px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_Swine_Stacked_Bar'
                                  },
                              'modeBarButtonsToRemove': ['zoom',
                                                          'zoomIn',
                                                          'zoomOut',
                                                          'autoScale',
                                                          #'resetScale',  # Removes home button
                                                          'pan',
                                                          'select2d',
                                                          'lasso2d']

                              })
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of Stacked Bar
                    ],style={"width":5}
                    ),

            ]),
        html.Br(),

        #### -- FOOTNOTES
        dbc.Row([
            dbc.Col([
              # Breed Standard Potential source
              html.P("*Using PIC breed standard, assuming 75% average carcass yield."),
            ]),
            dbc.Col([
              # Cost Assumptions
              html.P("Ideal costs are those required to achieve realised production if there were no mortality or morbidity."),
            ]),
        ], style={'margin-left':"40px", 'font-style': 'italic'}
        ),
        html.Br(),

        #### -- DATATABLE
        html.Div([  # Core data for country
                  html.Div( id='swine-background-data'),
            ], style={'margin-left':"20px",
                      "width":"95%",}),
        html.Br(), # Spacer for bottom of page

        html.Div([  # Breed standard data
                  html.Div( id='swine-breed-data'),
            ], style={'margin-left':"20px",
                      "width":"18%",}),
        html.Br() # Spacer for bottom of page

        ### END OF SWINE TAB
        ], style=major_producers_tab_style, selected_style=major_producers_tab_selected_style),

        #### ETHIOPIA TAB
        dcc.Tab(label="Ethiopia Case Study", children =[

            html.H3("Ethiopia Animal Health Loss Envelope and Disease Attribution"),
            html.Label(["Displaying production values, expenditures, and gross margin under the current and ideal scenario estimated by a compartmental herd dynamics model. Attribution of AHLE to infectious, non-infectious, and external causes is based on the results of expert elicitation."]),
            # html.Label(["Results on this page are currently limited to cattle, small ruminants, and poultry, as those are the species for which the compartmental herd model has been estimated."]),
            html.Label(["Results on this page are currently limited to cattle, small ruminants, and poultry."]),
            html.Hr(style={'margin-right':'10px'}),
            html.Label(["Select a species and production system to view and the currency to display for all charts"]
                       ,style={"font-style":"italic"}
                       ),

            #### -- DROPDOWNS CONTROLS
            dbc.Row([
                dbc.Col([
                    html.H4("Species"),
                    dcc.Dropdown(id='select-species-ecs',
                                options=ecs_species_options,
                                value='Cattle',
                                clearable = False,
                                ),
                    ]),
                dbc.Col([
                    html.H4("Production System"),
                    dcc.Dropdown(id='select-prodsys-ecs',
                                 # Options and value are now defined in a callback based on selected species
                                 clearable = False,
                                 ),
                    ]),
                dbc.Col([
                    html.H4("Currency"),
                    dcc.Dropdown(id='select-currency-ecs',
                                options=ecs_currency_options,
                                value='Birr',
                                clearable = False,
                                ),
                    ]),
                ],style={"margin-bottom":"30px"}),  # END OF FIRST CONTROL ROW

            # SECOND CONTROL ROW
            dbc.Row([
                dbc.Col([
                    # Switch between single year and over time
                    html.H4("Display AHLE for..."),
                    dcc.RadioItems(id='select-graph-ahle-ecs',
                                  inline=True,                  # True: arrange buttons horizontally
                                  inputStyle={
                                      "margin-right":"2px",     # This pulls the words off of the button
                                      "margin-left":"10px",     # Space between buttons if inline=True
                                      },
                                  ),
                    # Text underneath
                    html.P("Estimates over time or for any year other than 2021 are currently placeholders" ,style={'font-style':'italic'}),
                    ]),

                # Year selector
                dbc.Col([
                    html.H5("Year"),
                    dcc.Dropdown(id='select-year-ecs',
                                 clearable = False,
                                 ),
                    ]),

                # Geographical breakdown options
                dbc.Col([
                    html.H4("AHLE Geographic Scope"),
                    dcc.RadioItems(id='select-geo-view-ecs',
                                  inline=True,                  # True: arrange buttons horizontally
                                  inputStyle={
                                      "margin-right":"2px",     # This pulls the words off of the button
                                      "margin-left":"10px",     # Space between buttons if inline=True
                                      },
                                  ),
                    # Text underneath
                    html.P("Subnational estimates are currently only available for cattle for 2021" ,style={'font-style':'italic'}),
                    ]),

                # Subnational dropdwon
                dbc.Col([
                    html.H5("Subnational state", id='select-region-ecs-title'),
                    dcc.Dropdown(id='select-region-ecs',
                                 options=ecs_region_options,
                                 placeholder='Select Subnational...',
                                 clearable = False,
                                 ),
                    ]),
                ],justify='evenly'),  # END OF SECOND CONTROL ROW

            html.Hr(style={'margin-right':'10px'}),

            dbc.Row([
                #### -- AHLE Specific Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Animal Health Loss Envelope (AHLE)",
                                    className="card-title",
                                    style={"font-weight": "bold"}
                                    ),
                            html.Label(["Comparing current values, expenditures, and gross margin to the ideal. Note that the ideal values and expenditures describe the system in an ideal state (for example, zero health expenditure); they do not describe what is required to achieve that state."]),
                            dbc.Row([
                                # Switch between side by side and difference
                                dbc.Col([
                                    html.H6("Show current and ideal as..."),
                                    dcc.RadioItems(id='select-display-ecs',
                                                   options=ecs_display_options,
                                                   value='Difference',
                                                   labelStyle={'display': 'block'},
                                                   inputStyle={"margin-right": "2px"}, # This pulls the words off of the button
                                                   ),
                                    html.Label(["Difference: show a single bar for each item representing the difference between the current and ideal values"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Side by Side: show two bars for each item, one for current and another for the ideal value"] ,style={'font-style':'italic'}),
                                    ]),

                                # Compare
                                dbc.Col([
                                    html.H6("Compare current to...", id='select-compare-ecs-title'),
                                    dcc.RadioItems(id='select-compare-ecs',
                                                   options=ecs_compare_options_limited,
                                                   value='Ideal',
                                                   labelStyle={'display': 'block'},
                                                   inputStyle={"margin-right": "2px"}, # This pulls the words off of the button
                                                   ),
                                    html.Label(["Ideal: zero mortality and ideal growth and production rates"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Zero Mortality: zero mortality but growth and production rates at current levels"] ,style={'font-style':'italic'}),
                                    ]),

                                # Age/Sex combination
                                dbc.Col([
                                    html.H6("Show results for group...", id='select-agesex-ecs-title'),
                                    dcc.Dropdown(id='select-agesex-ecs',
                                                 options=ecs_agesex_options,
                                                 value='Overall',
                                                 clearable = False,
                                                 ),
                                    html.Label(["Overall: show values and costs for whole system"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Otherwise, show values and costs for just the selected age/sex group"] ,style={'font-style':'italic'}),
                                    ]),
                            ]), # END OF ROW
                            dbc.Row([
                                dbc.Col([
                                    html.H6("Item", id='select-item-ecs-title'),
                                    dcc.Dropdown(id='select-item-ecs',
                                                 value='Gross Margin',
                                                 clearable = False,
                                                 ),
                                    ]),

                                # Factor dropdown
                                dbc.Col([
                                    html.H6("Improvement Factor", id='select-factor-ecs-title'),
                                    dcc.Dropdown(id='select-factor-ecs',
                                                  options=ecs_factor_options,
                                                  value='Mortality',
                                                  clearable = True,
                                                  ),
                                      ],width=4,
                                    ),

                                # Reduction
                                dbc.Col([
                                    html.H6("Improvement Amount", id='select-improve-ecs-title'),
                                    dcc.RadioItems(id='select-improve-ecs',
                                                  options=ecs_improve_options,
                                                  value= "25%",
                                                  inputStyle={"margin-right": "2px", # This pulls the words off of the button
                                                              "margin-left": "10px"},
                                                  ),
                                    ]),
                                ]),     ## END OF ROW ##
                            ]),    # END OF CARD BODY
                        ], color='#F2F2F2'),    # END OF CARD
                    ],width=6),

                #### -- Attribution Specific Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("AHLE Attribution",
                                    className="card-title",
                                    style={"font-weight": "bold"}),
                            html.Label(["Showing how each component contributes to the total animal health loss envelope, including attribution to infectious, non-infectious, and external causes. NOTE: this is shown for species groups (cattle, all small ruminants, or all poultry) rather than for individual species."]),
                            html.H5("Segment by..."),
                            dbc.Row([
                                # Top Level
                                dbc.Col([
                                    html.H6("Top Level", id="select-top-lvl-attr-ecs-title"),
                                    dcc.Dropdown(id='select-top-lvl-attr-ecs',
                                                  options=ecs_hierarchy_attr_options,
                                                  value='cause',
                                                  clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                # Drilldown 1
                                dbc.Col([
                                    html.H6("Drilldown 1", id="select-dd-1-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-1-attr-ecs',
                                                  # options=ecs_hierarchy_dd_attr_options,
                                                  # value='production_system',
                                                   clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                # Drilldown 2
                                dbc.Col([
                                    html.H6("Drilldown 2", id="select-dd-2-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-2-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='age_group',
                                                  clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                ]), # END OF ROW
                            dbc.Row([
                                # Drilldown 3
                                dbc.Col([
                                    html.H6("Drilldown 3", id="select-dd-3-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-3-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='disease',
                                                  clearable = False,
                                                  ),
                                    ]),
                                # Drilldown 4
                                dbc.Col([
                                    html.H6("Drilldown 4", id="select-dd-4-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-4-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='ahle_component',
                                                  clearable = False,
                                                  ),
                                    ]),
                                ]), # END OF ROW
                            html.Label([
                                "Disease drilldown shows infectious AHLE broken out as follows depending on species:"
                                ,html.Br()
                                ,"- Cattle: Brucellosis | FMD | Other Infectious"
                                ,html.Br()
                                ,"- Small ruminants: Brucellosis | PPR | Other Infectious"
                                ,html.Br()
                                ,html.Br()
                                ,"Set any drill down to None to segment by fewer factors"
                                ] ,style={"font-style":"italic" ,"margin-top":"10px"}
                                ),
                            # html.Label(["Set any drill down to None to segment by fewer factors"] ,style={"font-style":"italic"}),
                            ]),     # END OF CARD BODY
                        ], color='#F2F2F2'),    # END OF CARD
                    ]),
                ], justify='evenly'),   # END OF DROPDOWN CONTROLS
            html.Br(),

            #### -- GRAPHICS PT.1
            dbc.Row([  # Row with GRAPHICS

                # Values and Costs Waterfall
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-ahle-waterfall',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_AHLE_Sunburst'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                              'zoomIn',
                                                              'zoomOut',
                                                              'autoScale',
                                                              #'resetScale',  # Removes home button
                                                              'pan',
                                                              'select2d',
                                                              'lasso2d']
                                  }
                              )
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of AHLE Sunburst
                    ],style={"width":5}),

                # Attribution Treemap
                dbc.Col(
                    dbc.Spinner(children=[

                    dcc.Graph(id='ecs-attr-treemap',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              )
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of Attribution Treemap
                    style={"width":5}),
                ]),

            #### -- FOOTNOTES PT.1
            dbc.Row([
                dbc.Col([   # Waterfall footnote
                    html.P("Blue indicates an increase, red indicates a decrease for each item. Orange is the net value of all of them.", id="waterfall-footnote-ecs"),
                    html.P("Error bars show 95% confidence interval for each item based on simulation results and reflect uncertainty in the input parameters"),
                ]),
                dbc.Col([   # Treemap footnote
                    html.P("Attribution to infectious, non-infectious, and external causes is based on expert opinion. See the expert opinion attribution proportions in the table below."),
                    html.P("AHLE Components are production loss, mortality loss, and health cost. Health cost makes up the smallest proportion and may not be visible in this view."),
                ]),
            ], style={'font-style': 'italic'}
            ),
            ### END OF FOOTNOTES

            html.Hr(style={'margin-right':'10px',}),

            #### -- WIDER ECONOMIC IMPACT
            dbc.Row([
                html.H3("Wider Economic Impact"),
                html.Label(["Estimating the total economic impact of each scenario for cattle and small ruminants using the ",
                            html.A('GTAP model.', href='https://www.gtap.agecon.purdue.edu/' ,target='_blank')  # target='_blank' to open in a new tab
                            ]),
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-wei-chart-1',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              ),
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-wei-chart-2',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              ),
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),
                ]),

            #### -- WEI FOOTNOTES
            dbc.Row([
                dbc.Col([   # Chart 1 footnote
                    html.P("% Change in Production is the % change in live animal production."),
                ]),
                dbc.Col([   # Chart 2 footnote
                    html.P("Economic surplus refers to the monetary gains that a consumer or producer or both accrues from an economic activity."),
                ]),
            ], style={'font-style': 'italic'}
            ),
            ### END OF FOOTNOTES

            #### -- MAP
            dbc.Card([
                dbc.CardBody([
                    html.H3("Subnational AHLE"),
                    html.Label(["Showing the animal health loss envelope for each subnational state. Use the dropdown to view an individual item of revenue, expenditure, or gross margin instead."]),
                    html.Label(["Note: a subnational state will appear blank if there is no data for the selected production system there"] ,style={"font-style":"italic"}),
                    dbc.Row([
                        # Map Display
                        dbc.Col([
                            html.H5("Item"),
                            dcc.Dropdown(id='select-map-display-ecs',
                                         value='Animal Health Loss Envelope',
                                         clearable=False,
                                         ),
                            ],width=3),

                        # Denominator
                        dbc.Col([
                            html.H5("Show values as..."),
                            dcc.RadioItems(id='select-map-denominator-ecs',
                                          options=ecs_map_denominator_options,
                                          value= "Per kg biomass",
                                          inputStyle={"margin-right": "2px", # This pulls the words off of the button
                                                      "margin-left": "10px"},
                                          ),
                            ]),
                        ]), # END OF MAP SELECTIONS ROW
                    ]),     # END OF CARD BODY
                ], color='#F2F2F2', style={"margin-right": "10px"}),    # END OF CARD

            # Map viz
            dbc.Row([
                dbc.Col([ # Ethiopian subnational level
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-map',
                                style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Subnational_Viz'
                                      },
                                  }
                              )
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),     # End of Map
                ]),     # END OF MAP ROW

            #### -- MAP FOOTNOTES
            dbc.Row([
                html.P("Livestock data is not shown for city regions (Addis Ababa, Dire Dawa, and Harari)"),
                html.P("South West Ethiopia did not have data available at the time of analysis. It is showing the same values as SNNP."),
                ], style={'font-style': 'italic'}
                ),

            #### -- GRAPHICS PT.2
            # dbc.Row([
            #     dbc.Col([ # AHLE Stacked Bar
            #         dbc.Spinner(children=[
            #         dcc.Graph(id='ahle-stacked-bar-ecs',
            #                   style = {"height":"500px"},
            #                   config = {
            #                       "displayModeBar" : True,
            #                       "displaylogo": False,
            #                       'toImageButtonOptions': {
            #                           'format': 'png', # one of png, svg, jpeg, webp
            #                           'filename': 'GBADs_AHLE_Stacked_Bar_ECS'
            #                           },
            #                       'modeBarButtonsToRemove': ['zoom',
            #                                                   'zoomIn',
            #                                                   'zoomOut',
            #                                                   'autoScale',
            #                                                   #'resetScale',  # Removes home button
            #                                                   'pan',
            #                                                   'select2d',
            #                                                   'lasso2d']
            #                       }
            #                   )
            #             ],size="md", color="#393375", fullscreen=False),    # End of Spinner
            #         ],style={"width":5}     # End of Stacked Bar
            #         ),

            #     # Sankey
            #     dbc.Col([
            #     dbc.Spinner(children=[
            #         html.H4("Sankey for Attribution"),
            #             html.Div(children=[
            #                     html.Img(src=(os.environ.get("DASH_BASE_URL") if os.environ.get("DASH_BASE_URL") else "") + '/assets/ECS_Sanky_diagram_from_Gemma.png',
            #                     style = {'width':'120vw'}),
            #                     ],
            #                       style = {
            #                               "margin-bottom":"10px",
            #                               'margin-right':"10px",},
            #                       ),
            #             # End of Spinner
            #             ],size="md", color="#393375", fullscreen=False),
            #         ]),
            #     ]), # END OF ROW

            #### -- FOOTNOTES PT.2
            # dbc.Row([
            #     dbc.Col([
            #         # Stacked bar
            #         html.P("Expenditure on Health is not recorded for individual age groups so is not included in individual AHLE calculations."),
            #         html.P("Expenditure on Health is very small, so the impact on AHLE is negligible."),
            #         ]),
            #     dbc.Col([
            #         # Sankey
            #         # No footnote
            #         ]),
            #     ], style={'font-style': 'italic'}
            #     ),

            html.Hr(style={'margin-right':'10px',}),

            #### -- DATATABLES
            html.H3("Data Viewer", id="ETH-data-export"),
            dbc.Row([
                dbc.Col([
                    html.Div([  # Core data for AHLE
                          html.Div( id='ecs-ahle-datatable'),
                          ], style={'margin-left':"20px"}),
                    html.Br() # Spacer for bottom of page
                    ]),
                dbc.Col([
                    html.Div([  # Core data for attribution
                          html.Div( id='ecs-attr-datatable'),
                          ], style={'margin-left':"20px",}),
                    html.Br(),
                    html.Div([  # Attribution expert opinion
                          html.Div( id='ecs-attr-expert-opinion'),
                          ], style={'margin-left':"20px",}),
                    html.Br(), # Spacer for bottom of page
                    ]),  # END OF COL
                ]),     # END OF ROW
            html.Br(),
            ### END OF DATATABLE
            ], style=ecs_tab_style, selected_style=ecs_tab_selected_style),     ### END OF ETHIOPIA TAB

        #### ANTIMICROBIAL USAGE TAB
       dcc.Tab(label="Antimicrobial Usage (AMU)", id='AMU-tab', children =[
            #### -- NAVIGATION BUTTONS
            dbc.Row([
                # Regional & Global AMU
                dbc.Col([
                    dbc.NavbarBrand(dcc.Link(
                                dbc.Button(children='AMU by Region & Importance',
                                            # style={
                                            #     'display': 'inline-block',
                                            #     'align': 'center',
                                            #     'color': 'white',
                                            #     'fontSize': '15px ',
                                            #     'backgroundColor': '#101820',
                                            #     'width': '150px',
                                            #     'height': '50px',
                                            #     'marginLeft': '100px',
                                            #     'marginRight': '100px'
                                            # }
                                            ),

                                href='#AMU-Regional-Global', refresh=True)),
                    ]),

                # Treemap & Map (Visualization of AMU, Biomass, AMR & AM Costs)
                dbc.Col([
                    dbc.NavbarBrand(dcc.Link(
                        dbc.Button(children='Visualization of AMU, Biomass, AMR & AM Costs',
                                    # style={'color': 'white',
                                    #        'backgroundColor': '#101820',
                                    #        'fontSize': '15px ',
                                    #        'width': '150px',
                                    #        'height': '50px',
                                    #        'marginLeft': '10px',
                                    #        'marginRight': '100px',
                                    #        }
                                    ),
                        href='#AMU-Biomass-AMR-Costs-Viz', refresh=True),
                        style={'justify-content':'center',
                               'display':'flex'}),
                    ],width="auto"),

                # Exploring AMU/price Variability
                dbc.Col([
                    dbc.NavbarBrand(dcc.Link(
                        dbc.Button(children='Exploring AMU/price Variability',
                                    # style={'color': 'white',
                                    #        'backgroundColor': '#101820',
                                    #        'fontSize': '15px ',
                                    #        'width': '150px',
                                    #        'height': '50px',
                                    #        'marginLeft': '10px',
                                    #        'marginRight': '100px',
                                    #        }
                                    ),
                        href='#AMU-exploring-variability', refresh=True),
                        style={'justify-content':'center',
                               'display':'flex'}),
                    ]),

                # Regional AM Expenditure Estimator
                dbc.Col([
                    dbc.NavbarBrand(dcc.Link(
                        dbc.Button(children='Regional AM Expenditure Estimator',
                                    # style={'color': 'white',
                                    #        'backgroundColor': '#101820',
                                    #        'fontSize': '15px ',
                                    #        'width': '150px',
                                    #        'height': '50px',
                                    #        'marginLeft': '10px',
                                    #        'marginRight': '100px',
                                    #        }
                                    ),
                        href='#AMU-regional-expenditure', refresh=True),
                        style={'justify-content':'center',
                               'display':'flex'}),
                    ]),

                # Data Export
                dbc.Col([
                    dbc.NavbarBrand(dcc.Link(
                        dbc.Button(children='Data Export',
                                    # style=nav_btn_style,
                                    ),
                        href='#AMU-data-export', refresh=True),
                        style={'justify-content':'center',
                               'display':'flex'}),
                    ],
                    style={
                            # TODO: Change colors in CSS
                              # "border":"2px #C5DAB8 solid",
                              }
                    ),

            #     dbc.NavbarSimple(
            #     children=[
            #         dbc.NavItem(dbc.NavLink("Regional & Global AMU", href="#AMU-Regional-Global",)),
            #         dbc.DropdownMenu(
            #             children=[
            #                 dbc.DropdownMenuItem("More pages", header=True),
            #                 dbc.DropdownMenuItem("Exploring AMU/price Variability", href="#AMU-exploring-variability",),
            #                 dbc.DropdownMenuItem("Regional AM Expenditure Estimator", href="#AMU-regional-expenditure",),
            #             ],
            #             nav=True,
            #             in_navbar=True,
            #             label="More",
            #         ),
            #     ],
            #     brand="NavbarSimple",
            #     # brand_href="#",
            #     color="secondary",
            #     dark=True,
            # ),

                # END OF NAVIGATION BUTTONS ROW
                ], justify='evenly',
                    style={
                            # 'position': 'fixed',
                            # 'z-index': '999', # Bring to front
                        },
                    ),

               html.Br(),

           #### -- DROPDOWN CONTROLS
           html.H3("Livestock Antimicrobial Usage by Region & Antimicrobial Importance/Classes", id="AMU-Regional-Global"),
            # html.P("Displaying antimicrobial usage as reported to WOAH" ,style={'font-style':'italic'}),
            # html.A("Source: WOAH 2018"
            #        ,href='https://www.woah.org/app/uploads/2022/06/a-sixth-annual-report-amu-final.pdf'
            #        ,style={'font-style':'italic'}
            #        ),
            html.Label(['Displaying antimicrobial usage as reported to ',
                        html.A('WOAH (2018)', href='https://www.woah.org/app/uploads/2022/06/a-sixth-annual-report-amu-final.pdf')
                        ], style={'font-style':'italic'}),
           html.Br(),
           dbc.Row([

               # Bar Chart selection
               dbc.Col([
                   html.H6("Regional AMU Bar Display"),
                   dcc.RadioItems(id='select-amu-graph',
                         options=['Total', 'Percent'],
                         value='Total',
                         labelStyle={'display': 'block'},
                         inputStyle={"margin-right": "10px"},
                         ),
                   ]),

               # Display quantity
               dbc.Col([
                   html.H6("AMU Units"),
                   dcc.RadioItems(id='select-quantity-amu-tonnes',
                         options=['Tonnes', 'mg per kg biomass'],
                         value='Tonnes',
                         labelStyle={'display': 'block'},
                         inputStyle={"margin-right": "10px"},
                         ),
                   ]),

               # AMU classification
               dbc.Col([
                   html.H6("Antimicrobial Grouping"),
                   dcc.Dropdown(id='select-classification-amu',
                         options=[
                             'Top Global Classes'
                             ,'WHO Importance Categories'
                             ,'WOAH Importance Categories'
                             ,'OneHealth Importance Categories'
                             ,'Individual Classes'
                             ],
                         value='Top Global Classes',
                         clearable=False,
                         ),
                   # Text underneath
                   html.P("See user guide for descriptions of importance categories" ,style={'font-style':'italic'}),
                   ]),

               # Region-country alignment
                # dbc.Col([
                #     html.H6('Region-country alignment'),
                #     dcc.RadioItems(id='Region-country-alignment-amu',
                #                     options=region_structure_options,
                #                     inputStyle={"margin-right": "10px", # This pulls the words off of the button
                #                                 "margin-left":"20px"},
                #                     value="WOAH",
                #                     style={"margin-left":'-20px'})
                #     ]),

               # Region
               dbc.Col([
                   html.H6("Region"),
                   dcc.Dropdown(id='select-region-amu',
                                 options=WOAH_region_options_ga,
                                 value='All',
                                 clearable = False,
                                 ),
                   ]),


        # END OF CONTROLS ROW
        ], justify='evenly'),

        html.Hr(style={'margin-right':'10px',}),

           #### -- GRAPHICS PT.1
            dbc.Row([
                     dbc.Col([ # AMU Stacked Bar
                     dbc.Spinner(children=[
                     dcc.Graph(id='amu-stacked-bar',
                               style = {"height":"650px"},
                               config = {
                                   "displayModeBar" : True,
                                   "displaylogo": False,
                                   'toImageButtonOptions': {
                                       'format': 'png', # one of png, svg, jpeg, webp
                                       'filename': 'GBADs_AMU_Stacked_Bar'
                                       },
                                   'modeBarButtonsToRemove': ['zoom',
                                                               'zoomIn',
                                                               'zoomOut',
                                                               'autoScale',
                                                               #'resetScale',  # Removes home button
                                                               'pan',
                                                               'select2d',
                                                               'lasso2d']
                                   })
                         # End of Spinner
                         ],size="md", color="#393375", fullscreen=False),

                         # End of Stacked Bar
                         ]),

                         dbc.Col([ # AMU Donut Chart
                         dbc.Spinner(children=[
                         dcc.Graph(id='amu-donut-chart',
                                   style = {"height":"650px"},
                                   config = {
                                       "displayModeBar" : True,
                                       "displaylogo": False,
                                       'toImageButtonOptions': {
                                           'format': 'png', # one of png, svg, jpeg, webp
                                           'filename': 'GBADs_AMU_Donut'
                                           },
                                       'modeBarButtonsToRemove': ['zoom',
                                                                   'zoomIn',
                                                                   'zoomOut',
                                                                   'autoScale',
                                                                   #'resetScale',  # Removes home button
                                                                   'pan',
                                                                   'select2d',
                                                                   'lasso2d']
                                       }
                                   )
                         # End of Spinner
                         ],size="md", color="#393375", fullscreen=False),
                         # End of Donut Chart
                         ]),

                 # END OF FIRST GRAPHICS ROW
                 ],),

           #### -- FOOTNOTES PT.1
            dbc.Row([
                dbc.Col([
                    html.P("Numbers in parenthesis show the number of countries in each region reporting to WOAH and the percent of region total biomass they represent.",
                           style={'margin-bottom':0,}),
                    ]),
                dbc.Col([   # Empty column so footnotes line up with charts
                      html.P("Click on an antimicrobial name/importance category in the legend to remove it from the visual"),
                      ]),
                ], style={'margin-left':"10px",
                          'font-style': 'italic',}
                ),

            html.Br(),

            #### -- MAP/DRILLDOWN CONTROLS
            dbc.Card([
                dbc.CardBody([
                    html.H3("Visualization of Antimicrobial Usage, Resistance and Expenditure in Livestock by Region", id="AMU-Biomass-AMR-Costs-Viz",
                            className="card-title"),

            dbc.Row([
                # Visualization Switch
                dbc.Col([
                    html.H6("Global Visualization"),
                    dcc.RadioItems(id='select-viz-switch-amu',
                                  options=['Drill Down', 'Map'],
                                  value='Drill Down',
                                  labelStyle={'display': 'block'},
                                  inputStyle={"margin-right": "10px"},
                                  ),
                    ],  width=1),

                # Map Display/Drill Down switch
                dbc.Col([
                    html.H6("Map Display", id='select-map-display-drilldown-amu-title'),
                    dcc.Dropdown(id='select-map-display-drilldown-amu',
                          clearable=False,
                          ),
                    ]),


            # Antimicrobial Class
            dbc.Col([
                html.H6("Antimicrobials", id='select-antimicrobial-importance-class-amu-title'),
                dcc.Dropdown(id='select-antimicrobial-importance-class-amu',
                      value='Aminoglycosides',
                      clearable=False,
                      ),
                ]),

                # Pathogens
                dbc.Col([
                    html.H6("Pathogen", id='select-pathogens-amu-title'),
                    dcc.Dropdown(id='select-pathogens-amu',
                          options=amu_pathogen_options,
                          value='All',
                          clearable=False,
                          ),
                    ]),

            # END OF CARD OPTIONS ROW
            ]),
            dbc.Row([
                html.P("Drill Down: show antimicrobial usage by region and importance category",
                       style={'font-style': 'italic',
                              'margin-bottom':0,}),
                html.P("Map: show antimicrobial usage, antimicrobial resistance, or antimicrobial expenditure on a world map",
                       style={'font-style': 'italic',
                              'margin-bottom':0,}),
                ]),

            # END OF CARD BODY
            ]),

            ], color='#F2F2F2', style={"margin-right": "10px"}), # END OF CARD

            html.Hr(style={'margin-right':'10px',}),

            # Map viz
            dbc.Row([
                dbc.Col([ # Global Aggregation Visual
                    dbc.Spinner(children=[
                    dcc.Graph(id='amu-map',
                                style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Global_AMU_Viz'
                                      },
                                  }
                              )
                # End of Spinner
                ],size="md", color="#393375", fullscreen=False),
                # End of Map
                ]),

             # END OF SECOND GRAPHICS ROW
            ]),

            #### -- MAP/DRILLDOWN FOOTNOTES
            dbc.Row([
                dbc.Col([
                    html.P("Data sources for drill down and map are as follows:"),
                    html.P("Antimicrobial usage in tonnes or mg per kg bimoass: countries reporting total usage to WOAH (WOAH 2018)."),
                    html.P("Biomass: total biomass for countries reporting to WOAH (WOAH 2018)."),
                    html.P("Antimicrobial Resistance (country level): percent of pathogen positive samples for the selected pathogen that are resistant to the selected antimicrobial class (source: Venkateswaran et al., 2023)."),
                    html.P("Drug Resistance Index (region level): drug resistance index based on the average resistance rate across all antimicrobials tested in the region, weighted by the frequency of use of those antimicrobials. Using data from (Venkateswaran et al., 2023) and methods from (Laxminarayan 2011) and (EFSA AMR Indicators 2017). See the user guide for more details."),
                    html.P("Antimicrobial Expenditure in total USD or USD per kg biomass: calculated from antimicrobial usage and price selected below."),
                    ]),
                ], style={'margin-left':"10px", 'font-style': 'italic'}
                ),

           #### -- GRAPHICS PT.2
           # Separator for WOAH data above, estimates/variations below
           html.Hr(style={'margin-right':'10px',}),
           dbc.Row([
               html.H3("Exploring Variability of Veterinary Antimicrobial Usage and Price by Data Source", id="AMU-exploring-variability"),
               html.P("Use the charts and sliders below to compare illustrative antimicrobial usage and price variations. To facilitate comparison with other sources, antimicrobial usage reported to WOAH is extended to 2020 and extrapolated to cover whole regions. See the user guide for full descriptions of these estimates."),
               ]),
           # dbc.Row([
           #     dbc.Col([
           #         dbc.Card([
           #             dbc.CardBody([html.H5("Antimicrobial usage estimates are produced for terrestrial livestock as follows:", className="card-title"),
           #                           html.P("A*: Limited to countries reporting total antimicrobial usage to WOAH. Estimate for terrestrial livestock based on terrestrial biomass as a proportion of total biomass. Extended to 2020 by assuming the trend from 2016-2018 continues."),
           #                           html.P("B*: Estimate A* extrapolated to whole region based on the proportion of terrestrial biomass for the region represented in the countries reporting."),
           #                           html.P("C*: Whole-region estimate for terrestrial livestock from Mulchandani et. al. (https://journals.plos.org/globalpublichealth/article?id=10.1371/journal.pgph.0001305)."),
           #                           ]),
           #             ]),
           #         ]),
           #     dbc.Col([
           #         dbc.Card([
           #             dbc.CardBody([html.H5("Price estimates are from the following sources:", className="card-title"),
           #                           html.P("A*: For Africa, the Americas, and the Middle East: the average price in Brazil (https://www.oecd-ilibrary.org/agriculture-and-food/antimicrobial-use-resistance-and-economic-benefits-and-costs-to-livestock-producers-in-brazil_27137b1e-en). For Asia, Far East and Oceania: the price of Tetracyclin in China (https://one.oecd.org/document/TAD/CA/APM/WP(2018)19/FINAL/En/pdf (page 25)). For Europe: https://animalhealtheurope.eu/about-us/annual-reports/2020-2/key-figures/."),
           #                           html.P("B*: For Africa: 22% increase from price in Europe. For the Americas: midpoint between high and low estimates. For Asia, Far East and Oceania: . For Europe: . For the Middle East: 25% decrease from price in Europe."),
           #                           html.P("C*: For Africa: 42% increase from price in Europe. For the Americas and Asia, Far East and Oceania: the average price reported in Europe. For Europe: . For the Middle East: 15% decrease from price in Europe."),
           #                           ]),
           #             ]),
           #         ]),
           #     ]),
           # html.Br(),

           # Control and note for usage and price charts
           dbc.Row([
               # Usage units
               dbc.Col([
                   html.H6("Display antimicrobial usage as:"),
                   dcc.RadioItems(id='select-usage-units-amu',
                         options=['total tonnes', 'mg per kg biomass'],
                         value='total tonnes',
                         labelStyle={'display': 'inline-block'},
                         inputStyle={"margin": "0 5px 0 15px",},
                         ),
                   ]),
               # Note for prices
               # dbc.Col([
               #       html.P("*Click on 'A*', 'B*', or 'C*' to jump to those values.",
               #              style={'font-weight': '600', 'font-style': 'italic'}),
               #       ],
               #     style={'margin-top': '30px',}, width=7,),

               ]), #END OF ROW

           # Plots comparing different estimates of usage and price
           dbc.Row([
               dbc.Col([    # Side-by-side bars comparing usage estimates for each region
                   dbc.Spinner(children=[
                       dcc.Graph(id='am-usage-comparison',
                          style = {"height":"400px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_AM_usage_comparison'
                                  },
                              'modeBarButtonsToRemove': [
                                  'zoom',
                                  'zoomIn',
                                  'zoomOut',
                                  'autoScale',
                                  #'resetScale',  # Removes home button
                                  'pan',
                                  'select2d',
                                  'lasso2d'
                                  ]
                              }
                          )
                       # End of Spinner
                       ],size="md", color="#393375", fullscreen=False),
                   ]),
               dbc.Col([    # Dots and error bars comparing price estimates for each region
                   dbc.Spinner(children=[
                       dcc.Graph(id='am-price-comparison',
                          style = {"height":"400px"},
                          config = {
                              "displayModeBar" : True,
                              "displaylogo": False,
                              'toImageButtonOptions': {
                                  'format': 'png', # one of png, svg, jpeg, webp
                                  'filename': 'GBADs_AM_price_comparison'
                                  },
                              'modeBarButtonsToRemove': [
                                  'zoom',
                                  'zoomIn',
                                  'zoomOut',
                                  'autoScale',
                                  #'resetScale',  # Removes home button
                                  'pan',
                                  'select2d',
                                  'lasso2d'
                                  ]
                              }
                          )
                       # End of Spinner
                       ],size="md", color="#393375", fullscreen=False),
                   ]),
               ]),
           #### -- FOOTNOTES PT.2
           dbc.Row([
               dbc.Col([
                   html.P("Bars represent usage from the following sources. Please refer to the user guide for details.",),
                   html.P("A*: Countries reporting 2018 data to WOAH, extended to 2020 by assuming the trend from 2016-2018 continues (source: WOAH 2018).",
                          style={'margin-bottom':0,}),
                   html.P("B*: Estimate A extended to whole region based on the proportion of region total biomass represented in the countries reporting (source: WOAH 2018).",
                          style={'margin-bottom':0,}),
                   html.P("C*: Region-total estimate from (Mulchandani et al., 2023).",
                          style={'margin-bottom':0,}),
                   ]),
               dbc.Col([
                   html.P("Price points for antimicrobials were extracted from a range of sources. Extrapolations were made for regions where price data was not available. Please refer to the user guide for details."),
                   ]),
               ], style={'margin-left':"10px",
                         'font-style': 'italic',}
               ),


           html.Br(),

           #### -- GRAPHICS PT.3
           # Usage and Price Sliders with Expenditure chart
           html.H3("Regional Veterinary Antimicrobial Expenditure Estimator", id="AMU-regional-expenditure"),

           # Control and note for sliders and expenditure chart
           dbc.Row([
               # Expenditure units
               dbc.Col([
                   html.H6("Display antimicrobial expenditure as:"),
                   dcc.RadioItems(id='select-expenditure-units-amu',
                         options=['total', 'per kg biomass'],
                         value='total',
                         labelStyle={'display': 'inline-block'},
                         inputStyle={"margin": "0 5px 0 15px",},
                         ),
                   ]),
               # Note for sliders
               dbc.Col([
                     html.P("*Click on 'A*', 'B*', or 'C*' to jump to those values.",
                            style={'font-weight': '600', 'font-style': 'italic'}),
                     ],
                   style={'margin-top': '30px',}, width=7,),

               ]), #END OF ROW

           # Gaphics Row
           dbc.Row([
               dbc.Col([
                   dbc.Spinner(children=[
                   dcc.Graph(id='amu-expenditure',
                             config = {
                                 "displayModeBar" : True,
                                 "displaylogo": False,
                                 'toImageButtonOptions': {
                                     'format': 'png', # one of png, svg, jpeg, webp
                                     'filename': 'GBADs_AMU_Expenditure'
                                     },
                                 'modeBarButtonsToRemove': ['zoom',
                                                          'zoomIn',
                                                          'zoomOut',
                                                          'autoScale',
                                                          #'resetScale',  # Removes home button
                                                          'pan',
                                                          'select2d',
                                                          'lasso2d']
                             })
                   # End of Spinner
                   ],size="md", color="#393375", fullscreen=False),
                   ]),

               # Price and Usage Sliders
               dbc.Col([
                   dbc.Card([
                       dbc.CardBody([
                           html.H5("Estimated Antimicrobial Usage and Price for Terrestrial Livestock",
                                   className="card-title",
                                   style={"font-weight": "bold"}
                                   ),

                           # Reset to midpoint button
                           dbc.Col([
                               html.Button('Reset to midpoint (B*)', id='reset-sliders-amu', n_clicks=0),
                           ],style={'width': "auto",
                                     'textAlign':'center',
                                     'margin':'auto',}
                           ),

                           dbc.Row([    # Region names
                               dbc.Col([html.H5("Africa")]),
                               dbc.Col([html.H5("Americas")]),
                               dbc.Col([html.H5("Asia, Far East and Oceania")]),
                               dbc.Col([html.H5("Europe")]),
                               dbc.Col([html.H5("Middle East")]),
                               ]),
                           dbc.Spinner(children=[
                           dbc.Row([
                               dbc.Col([
                                   html.H6("Usage"),
                                   daq.Slider(
                                       id='am-usage-slider-africa',
                                       handleLabel={"showCurrentValue":
                                                    True ,"label":"Tonnes",
                                                    'style':{'fontSize':'1'}},
                                       vertical=True,
                                       color= 'rgb(135,197,95)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Price"),
                                   daq.Slider(
                                       id='am-price-slider-africa',
                                       handleLabel={"showCurrentValue":True ,"label":"USD per tonne"},
                                       vertical=True,
                                       color= 'rgb(135,197,95)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Usage"),
                                   daq.Slider(
                                       id='am-usage-slider-americas',
                                       handleLabel={"showCurrentValue":True ,"label":"Tonnes"},
                                       vertical=True,
                                       color='rgb(248,156,116)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Price"),
                                   daq.Slider(
                                       id='am-price-slider-americas',
                                       handleLabel={"showCurrentValue":True ,"label":"USD per tonne"},
                                       vertical=True,
                                       color='rgb(248,156,116)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Usage"),
                                   daq.Slider(
                                       id='am-usage-slider-asia',
                                       handleLabel={"showCurrentValue":True ,"label":"Tonnes"},
                                       vertical=True,
                                       color='rgb(102,197,204)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Price"),
                                   daq.Slider(
                                       id='am-price-slider-asia',
                                       handleLabel={"showCurrentValue":True ,"label":"USD per tonne"},
                                       vertical=True,
                                       color='rgb(102,197,204)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Usage"),
                                   daq.Slider(
                                       id='am-usage-slider-europe',
                                       handleLabel={"showCurrentValue":True ,"label":"Tonnes"},
                                       vertical=True,
                                       color='rgb(220,176,242)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Price"),
                                   daq.Slider(
                                       id='am-price-slider-europe',
                                       handleLabel={"showCurrentValue":True ,"label":"USD per tonne"},
                                       vertical=True,
                                       color='rgb(220,176,242)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Usage"),
                                   daq.Slider(
                                       id='am-usage-slider-mideast',
                                       handleLabel={"showCurrentValue":True ,"label":"Tonnes"},
                                       vertical=True,
                                       color='rgb(254,136,177)',
                                       ),
                                   ]),
                               dbc.Col([
                                   html.H6("Price"),
                                   daq.Slider(
                                       id='am-price-slider-mideast',
                                       handleLabel={"showCurrentValue":True ,"label":"USD per tonne"},
                                       vertical=True,
                                       color='rgb(254,136,177)',
                                       ),
                                   ]),
                               ]),
                           ],size="md", color="#393375", fullscreen=False),     # End of spinner
                           ]),
                       ]),
                   ]
                   ,width=7
                   ),
               ]),

           # AMU for terrestrial animals, with uncertainty
           # dbc.Row([
           #     dbc.Col([
           #         dbc.Spinner(children=[
           #         dcc.Graph(id='amu-terr-error-usage',
           #                   style = {"height":"650px"},
           #                   config = {
           #                       "displayModeBar" : True,
           #                       "displaylogo": False,
           #                       'toImageButtonOptions': {
           #                           'format': 'png', # one of png, svg, jpeg, webp
           #                           'filename': 'GBADs_AMU_Terrestrial_Usage'
           #                           },
           #                       'modeBarButtonsToRemove': ['zoom',
           #                                                'zoomIn',
           #                                                'zoomOut',
           #                                                'autoScale',
           #                                                #'resetScale',  # Removes home button
           #                                                'pan',
           #                                                'select2d',
           #                                                'lasso2d']
           #                   })
           #         # End of Spinner
           #         ],size="md", color="#393375", fullscreen=False),
           #         ]),
           #     dbc.Col([
           #         dbc.Spinner(children=[
           #         dcc.Graph(id='amu-terr-error-expenditure',
           #                   style = {"height":"650px"},
           #                   config = {
           #                       "displayModeBar" : True,
           #                       "displaylogo": False,
           #                       'toImageButtonOptions': {
           #                           'format': 'png', # one of png, svg, jpeg, webp
           #                           'filename': 'GBADs_AMU_Terrestrial_Expenditure'
           #                           },
           #                       'modeBarButtonsToRemove': ['zoom',
           #                                                'zoomIn',
           #                                                'zoomOut',
           #                                                'autoScale',
           #                                                #'resetScale',  # Removes home button
           #                                                'pan',
           #                                                'select2d',
           #                                                'lasso2d']
           #                   })
           #         # End of Spinner
           #         ],size="md", color="#393375", fullscreen=False),
           #         ]),
           #     ]),

           #### -- DATATABLES
           html.Hr(style={'margin-right':'10px',}),
           html.H3("Data Export", id="AMU-data-export"),
           dbc.Row([
               dbc.Spinner(children=[
               dbc.Col([
                   html.Div([
                         html.Div( id='amu-2018-combined-tall-todisplay'),
                   ], style={'margin-left':"20px"}),

               html.Br() # Space in between tables

               ]),# END OF COL
               # End of Spinner
               ],size="md", color="#393375", fullscreen=False),

           ]),

           dbc.Row([
               dbc.Spinner(children=[
               dbc.Col([
                   html.Div([
                         html.Div(id='amu-regional-todisplay'),
                   ], style={'margin-left':"20px"}),
               html.Br() # Spacer for bottom of page
               ]),# END OF COL
               # End of Spinner
               ],size="md", color="#393375", fullscreen=False),
           ]),

           dbc.Row([
               dbc.Spinner(children=[
               dbc.Col([
                   html.Div([
                         html.Div(id='amr-todisplay'),
                   ], style={'margin-left':"20px"}),
               html.Br() # Spacer for bottom of page
               ]),# END OF COL
               # End of Spinner
               ],size="md", color="#393375", fullscreen=False),
           ]),

           # Add naviagation button to top of page
           dbc.Row([
               dbc.Col(html.Div([
                   html.A(href="#AMU-tab",
                   children=[
                       html.Img(title="Back to top",src=(os.environ.get("DASH_BASE_URL") if os.environ.get("DASH_BASE_URL") else "") + '/assets/up_arrow_icon_black-modified.png')
                   ], style={'width':'80px'},
                   ),
                       ], style = {'margin-left':"10px",
                                   "margin-bottom":"10px",
                                   'margin-right':"10px",
                                   'position': 'fixed',
                                   'bottom':0,
                                   },
               )),
           ]),

            ], style=user_guide_tab_style, selected_style=user_guide_tab_selected_style),


        ### END OF TABS ###
        ],style={'margin-right':'10px',
                 'margin-left': '10px'}, )

        ])



#%% 5. CALLBACKS
# This section does the interactivity work with the web page
# - Listens to Inputs, linked to the id's of various web page elements in the LAYOUT
# - Changes the webpage with Outputs, also linked to the id's in the LAYOUT

# Version using multiple callbacks relies on passing data between them
# See https://dash.plotly.com/sharing-data-between-callbacks

# ==============================================================================
#### UPDATE POULTRY
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
#Update regions based on region contry aligment selection:
@gbadsDash.callback(
    Output(component_id='select-region-poultry', component_property='options'),
    Input(component_id='Region-country-alignment-poultry', component_property='value'),
    )
def update_region_options_poultry(region_country):
    if region_country == "WOAH":
        options = WOAH_region_options
    elif region_country =="FAO":
        options = fao_region_options
    elif region_country == "World Bank":
        options = wb_region_options
    return options

# Update country options based on region selection
@gbadsDash.callback(
    Output(component_id='select-country-poultry', component_property='options'),
    Input(component_id='Region-country-alignment-poultry', component_property='value'),
    Input(component_id='select-region-poultry', component_property='value'),
    )
def update_country_options_poultry(region_country, region):
    if region_country == "WOAH":
        if region == "All":
            options = country_options_poultry
        elif region == "Africa":
            options = WOAH_africa_options
        elif region == "Americas":
            options = WOAH_americas_options
        elif region == "Asia, Far East and Oceania":
            options = WOAH_asia_options
        else:
            options = WOAH_europe_options
    elif region_country =="FAO":
        if region == "All":
            options = country_options_poultry
        elif region == "Africa":
            options = fao_africa_options
        elif region == "Asia":
            options = fao_asia_options
        elif region == "Europe and Central Asia":
            options = fao_eca_options
        elif region == "Latin America and the Caribbean":
            options = fao_lac_options
        else:
            options = fao_swp_options
    elif region_country == "World Bank":
        if region == "All":
            options = country_options_poultry
        elif region == "Sub-Saharan Africa":
            options = wb_africa_options
        elif region == "Europe & Central Asia":
            options = wb_eca_options
        elif region == "Latin America & the Caribbean":
            options = wb_lac_options
        elif region == "North America":
            options = wb_na_options
        else:
            options = wb_southasia_options
    else:
        options = country_options_poultry

    return options

# Set slider starting values and add reference underneath based on selected country
# Also enable "Reset to Default" button
@gbadsDash.callback(
    Output('achievable-pct-slider-poultry', 'value'),
    Input(component_id='reset-val-poultry', component_property='n_clicks')   # Reset to defaults button
    )
def reset_achievablepct_poultry(reset):
    return achievable_pct_poultry_default

@gbadsDash.callback(
    Output('dof-slider-poultry', 'value'),
    Output('reference-dof-poultry', 'children'),
    Input('select-country-poultry', 'value'),
    Input('select-year-poultry', 'value'),
    Input(component_id='reset-val-poultry', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_daysonfeed_poultry(country, year, reset):
    input_df = gbads_chickens_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_avgdaysonfeed'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = dof_poultry_default
      display = '(no data)'
    else:
      slider = datavalue
      display = f'{datavalue:.0f} days'
    return slider, f'Average for {country_shortname} in {year}: {display}'

@gbadsDash.callback(
    Output('producer-price-slider-poultry', 'value'),
    Output('reference-producerprice-poultry', 'children'),
    Input('select-country-poultry', 'value'),
    Input('select-year-poultry', 'value'),
    Input(component_id='reset-val-poultry', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_producerprice_poultry(country, year, reset):
    input_df = gbads_chickens_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_producerprice_usdperkgcarc'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = producer_price_poultry_default
      display = '(no data)'
    else:
      slider = round(datavalue, 2)
      display = f'${datavalue:.2f}'
    return slider, f'Average for {country_shortname} in {year}: {display}'

@gbadsDash.callback(
    Output('ration-price-slider-poultry', 'value'),
    Output('reference-feedprice-poultry', 'children'),
    Input('select-country-poultry', 'value'),
    Input('select-year-poultry', 'value'),
    Input(component_id='reset-val-poultry', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_feedprice_poultry(country, year, reset):
    input_df = gbads_chickens_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_feedprice_usdpertonne'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = ration_price_poultry_default
      display = '(no data)'
    else:
      slider = round(datavalue, 2)
      display = f'${datavalue:.2f}'
    return slider, f'Average for {country_shortname} in {year}: {display}'

# Using Breed Standard FCR as reference
@gbadsDash.callback(
    Output('fcr-slider-poultry', 'value'),
    Output('reference-fcr-poultry', 'children'),
    Input('select-country-poultry', 'value'),
    Input('dof-slider-poultry', 'value'),
    Input(component_id='reset-val-poultry', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_fcr_poultry(country, dof, reset):
    breed_label_touse = poultry_lookup_breed_from_country[country]
    breed_df_touse = poultry_lookup_breed_df[breed_label_touse]
    _rowselect = (breed_df_touse['dayonfeed'] == dof)
    datavalue = breed_df_touse.loc[_rowselect ,'fcr'].values[0]
    if pd.isnull(datavalue):
      slider = fcr_poultry_default
      display = '(no data)'
    else:
      slider = round(datavalue, 2)
      display = f'{datavalue:.2f}'
    return slider, f'Breed standard: {display}'

# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# MUST HAPPEN FIRST: Calculate burden of disease components on core data
# Updates when user changes achievable proportion slider
# Does not care about simple filtering (country and year)
@gbadsDash.callback(
    Output('core-data-poultry','data'),
    Input('achievable-pct-slider-poultry','value'),
    Input('dof-slider-poultry','value'),
    Input('select-country-poultry','value'),
    Input('ration-price-slider-poultry','value'),
    Input('fcr-slider-poultry','value')
    )
def update_core_data_poultry(achievable_pct, avg_dof, country, feedprice, fcr):
    breed_label_touse = poultry_lookup_breed_from_country[country]
    breed_df_touse = poultry_lookup_breed_df[breed_label_touse]
    poultry_data_withbod = bod.calc_bod_master_poultry(
      gbads_chickens_merged_fordash
      ,ACHIEVABLE_PCT_MASTER=achievable_pct      # Integer [0, 120]: proportion of ideal production that is achievable without disease, i.e. efficiency of feed, medications, and practices
      ,AVG_DOF_MASTER=avg_dof                      # Integer (0, 63]: Average days on feed. Will lookup breed standard weight for this day on feed.
      ,BREED_DF_MASTER=breed_df_touse     # Data frame with breed reference information. Must contain columns 'dayonfeed' and 'bodyweight_g'.
      ,FEEDPRICE_USDPERTONNE_MASTER=feedprice           # Float
      ,IDEAL_FCR_LIVE_MASTER=fcr                        # Float: ideal FCR per kg live weight
      # ,AVG_CARC_YIELD_MASTER=0.695                 # Float [0, 1]: average carcass yield as proportion of live weight. If blank, will use 'bod_breedstdyield_prpn'.
    )
    poultry_data_withbod['year'] = poultry_data_withbod['year'].astype(str)   # Change Year type to text
    return poultry_data_withbod.to_json(date_format='iso', orient='split')

# Can happen in any order after update_core_data
# These update when user changes filtering (country and year)
# Update data table to show user
@gbadsDash.callback(
    Output('poultry-background-data', 'children'),
    Input('core-data-poultry','data'),
    Input('select-country-poultry','value'),
    Input('producer-price-slider-poultry','value'),
    Input('ration-price-slider-poultry','value'),
    )
def update_background_data_poultry(input_json, country ,producerprice ,rationprice):
    # Dash callback input data is a string that names a json file
    # First read it into a dataframe
    input_df = pd.read_json(input_json, orient='split')
    background_data = input_df.loc[(input_df['country'] == country)]

    # Add slider values as columns to display
    background_data['producerprice_usdperkg'] = producerprice
    background_data['rationprice_usdpertonne'] = rationprice
    background_data['bod_totalburden_usd'] = background_data['bod_totalburden_tonnes'] * 1000 \
      * background_data['producerprice_usdperkg']

    columns_to_display_with_labels = {
      'country':'Country'
      ,'year':'Year'

      ,'acc_headplaced':'Head Placed'
      ,'acc_headslaughtered':'Head Slaughtered'
      ,'acc_totalcarcweight_tonnes':'Total Carcass Weight (tonnes)'   # Equal to bod_realizedproduction_tonnes
      ,'acc_avgcarcweight_kg':'Avg. Carcass Weight (kg)'
      # ,'acc_avgdaysonfeed':'Avg Days on Feed'   # Using input value rather than this column
      # ,'acc_avgliveweight_kg':'Avg Live Weight (kg)'

      ,'bod_dof_used':'Days on Feed'
      ,'bod_breedstdwt_kg':'Breed Standard Live Weight (kg)'
      ,'bod_breedstdyield_prpn':'Breed Standard Carcass Yield'
      ,'bod_breedstdcarcwt_kg':'Breed Standard Carcass Weight (kg)'
      ,'bod_referenceproduction_tonnes':'Breed Standard Potential (tonnes)'
      ,'bod_efficiency_tonnes':'Effect of Feed & Practices (tonnes)'
      ,'bod_gmax_tonnes':'Achievable without Disease (tonnes)'
      ,'bod_deathloss_tonnes':'Mortality & Condemns (tonnes)'
      ,'bod_morbidity_tonnes':'Morbidity (tonnes)'
      ,'bod_realizedproduction_tonnes':'Realised Production (tonnes)'
      ,'bod_totalburden_tonnes':'Total Burden of Disease (tonnes)'

      ,'producerprice_usdperkg':'Producer Price (USD per kg)'
      ,'bod_totalburden_usd':'Total Burden of Disease (USD)'
      # ,'wb_gdp_usd':'GDP (USD)'

      ,'acc_feedcost_usdperkglive':'Avg. Feed Cost (USD per kg live weight)'
      ,'acc_chickcost_usdperkglive':'Avg. Chick Cost (USD per kg live weight)'
      ,'acc_laborcost_usdperkglive':'Avg. Labour Cost (USD per kg live weight)'
      ,'acc_landhousingcost_usdperkglive':'Avg. Land & Housing Cost (USD per kg live weight)'
      ,'acc_medcost_usdperkglive':'Avg. Medicine Cost (USD per kg live weight)'
      ,'acc_othercost_usdperkglive':'Avg. Other Costs (USD per kg live weight)'

      ,'ideal_headplaced':'Ideal Head Placed'
      ,'ideal_fcr':'Ideal FCR'
      ,'ideal_feed_tonnes':'Ideal Feed Consumption (tonnes)'
      ,'rationprice_usdpertonne':'Feed Price (USD per tonne)'
      ,'ideal_feedcost_usdperkglive':'Ideal Feed Cost (USD per kg live weight)'
      ,'ideal_chickcost_usdperkglive':'Ideal Chick Cost (USD per kg live weight)'
      ,'ideal_landhousingcost_usdperkglive':'Ideal Land & Housing Cost (USD per kg live weight)'
      ,'ideal_laborcost_usdperkglive':'Ideal Labour Cost (USD per kg live weight)'
      ,'ideal_medcost_usdperkglive':'Ideal Medicine Cost (USD per kg live weight)'
      ,'ideal_othercost_usdperkglive':'Ideal Other Costs (USD per kg live weight)'
    }

    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places
    background_data.update(background_data[[
      'acc_headplaced'
      ,'acc_headslaughtered'
      ,'acc_totalcarcweight_tonnes'
      ,'bod_referenceproduction_tonnes'
      ,'bod_realizedproduction_tonnes'
      ,'bod_efficiency_tonnes'
      ,'bod_gmax_tonnes'
      ,'bod_deathloss_tonnes'
      ,'bod_morbidity_tonnes'
      ,'bod_totalburden_tonnes'
      ,'wb_gdp_usd'
      ,'ideal_headplaced'
      ,'ideal_feed_tonnes'
    ]].applymap('{:,.0f}'.format))

    # Two decimal places
    background_data.update(background_data[[
      'bod_breedstdwt_kg'
      ,'bod_breedstdyield_prpn'
      ,'bod_breedstdcarcwt_kg'
      ,'acc_avgcarcweight_kg'
      ,'producerprice_usdperkg'
      ,'bod_totalburden_usd'
      ,'rationprice_usdpertonne'
      ,'acc_feedcost_usdperkglive'
      ,'acc_chickcost_usdperkglive'
      ,'acc_laborcost_usdperkglive'
      ,'acc_landhousingcost_usdperkglive'
      ,'acc_medcost_usdperkglive'
      ,'acc_othercost_usdperkglive'
      ,'ideal_fcr'
      ,'ideal_feedcost_usdperkglive'
      ,'ideal_chickcost_usdperkglive'
      ,'ideal_landhousingcost_usdperkglive'
      ,'ideal_laborcost_usdperkglive'
      ,'ideal_medcost_usdperkglive'
      ,'ideal_othercost_usdperkglive'
    ]].applymap('{:,.2f}'.format))

    # ------------------------------------------------------------------------------
    # Hover-over text
    # ------------------------------------------------------------------------------
    # Read last row of data with filters applied to get source of each column.
    # For most countries and columns, source is the same for every year.
    # But if source differs for later years, want to report the latest.
    background_data_lastrow = background_data.iloc[-1 ,:]

    # Define tooltips, using _src columns where appropriate
    column_tooltips = {
      "acc_headplaced":f"Chicks placed ({background_data_lastrow['acc_headplaced_src']}) adjusted for net imports ({background_data_lastrow['acc_netimport_chicks_src']})"
      ,"acc_headslaughtered":f"Source: {background_data_lastrow['acc_headslaughtered_src']}"
      ,"acc_totalcarcweight_tonnes":f"Source: {background_data_lastrow['acc_totalcarcweight_tonnes_src']}"
      ,"acc_avgcarcweight_kg":"[Total Carcass Weight] / [Head Slaughtered]"

      ,"bod_dof_used":"Set by slider: days on feed"
      ,"bod_breedstdwt_kg":"Source: breed standard @ selected days on feed"
      ,"bod_breedstdyield_prpn":"Source: breed standard @ selected days on feed"
      ,"bod_breedstdcarcwt_kg":"[Breed Standard Live Weight] x [Breed Standard Carcass Yield]"
      ,"bod_referenceproduction_tonnes":"[Head Placed] x [Breed Standard Live Weight] x [Breed Standard Carcass Yield]"
      ,"bod_efficiency_tonnes":"Adjustment to breed standard potential according to achievable % (slider)"
      ,"bod_gmax_tonnes":"[Breed Standard Potential] + [Effect of Feed & Practices]"
      ,"bod_deathloss_tonnes":"[Head Placed] - [Head Slaughtered]"
      ,"bod_morbidity_tonnes":"[Achievable without Disease] - [Mortality & Condemns] - [Realised Production]"
      ,"bod_realizedproduction_tonnes":f"Source: {background_data_lastrow['acc_totalcarcweight_tonnes_src']}"
      ,"bod_totalburden_tonnes":"[Mortality & Condemns] + [Morbidity]"

      ,"producerprice_usdperkg":"Set by slider: Price to producers"
      ,"bod_totalburden_usd":"[Total Burden of Disease (tonnes)] x 1000 x [Producer Price (USD per kg)]"
      ,"rationprice_usdpertonne":"Set by slider: Ration price"
      ,"wb_gdp_usd":"Source: World Bank"

      ,"acc_feedcost_usdperkglive":f"Source: {background_data_lastrow['acc_feedcost_usdperkglive_src']}"
      ,"acc_chickcost_usdperkglive":f"Source: {background_data_lastrow['acc_chickcost_usdperkglive_src']}"
      ,"acc_laborcost_usdperkglive":f"Source: {background_data_lastrow['acc_laborcost_usdperkglive_src']}"
      ,"acc_landhousingcost_usdperkglive":f"Source: {background_data_lastrow['acc_landhousingcost_usdperkglive_src']}"
      ,"acc_medcost_usdperkglive":f"Source: {background_data_lastrow['acc_medcost_usdperkglive_src']}"
      ,"acc_othercost_usdperkglive":f"Source: {background_data_lastrow['acc_othercost_usdperkglive_src']}"

      ,"ideal_headplaced":"Animals required to match realised production if there were no mortality or morbidity"
      ,"ideal_fcr":"Set by slider: ideal feed conversion ratio"
      ,"ideal_feed_tonnes":"Feed required to match realised production at zero mortality and ideal FCR"
      ,"rationprice_usdpertonne":"Set by slider: feed price"
      ,"ideal_feedcost_usdperkglive":"[Ideal Feed Consumption] x [Feed Price]"
      ,"ideal_chickcost_usdperkglive":"Actual chick cost reduced proportionally with ideal head placed / actual head placed"
      ,"ideal_landhousingcost_usdperkglive":"Actual land & housing cost reduced proportionally with ideal head placed / actual head placed"
      ,"ideal_laborcost_usdperkglive":"Actual labor cost reduced proportionally with ideal land & housing cost"
      ,"ideal_medcost_usdperkglive":"Actual medicine cost reduced proportionally with ideal head placed / actual head placed"
      ,"ideal_othercost_usdperkglive":"Actual other cost reduced proportionally with ideal head placed / actual head placed"
    }

    return [
            html.H4(f"Data for {country}"),
            # html.P('All currently processed data.  Unformatted and unfiltered.'),
            #html.P(' '.join(df['id'].tolist())),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=background_data.to_dict('records'),
                export_format="csv",
                sort_action = 'native',
                # #filter_action="native",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll'},

                # Source tooltip and styling
                # Hover-over for column headers
                tooltip_header=column_tooltips,
                tooltip_delay= 500,
                tooltip_duration=50000,

                # Underline columns with tooltips
                style_header_conditional=[{
                    'if': {'column_id': col},
                    'textDecoration': 'underline',
                    'textDecorationStyle': 'dotted',
                    } for col in list(column_tooltips)],
            )
        ]

@gbadsDash.callback(
    Output('poultry-breed-data', 'children'),
    Input('select-country-poultry','value'),
    )
def update_breed_data_poultry(country):
    breed_label_touse = poultry_lookup_breed_from_country[country]
    breed_df_touse = poultry_lookup_breed_df[breed_label_touse]

    columns_to_display_with_labels = {
      'dayonfeed':'Day on Feed'
      ,'bodyweight_g':'Live Weight (g)'
      ,'cmlfeedintake_g':'Cml Feed Intake (g)'
      ,'fcr':'FCR'
      ,'pct_yield':'Carcass Yield'
    }
    # breed_df_touse = breed_df_touse.transpose()

    # Subset columns
    breed_df_touse = breed_df_touse[list(columns_to_display_with_labels)]

    # breed_df_touse = breed_df_touse.transpose()

    # Format numbers
    breed_df_touse.update(breed_df_touse[['dayonfeed' ,'bodyweight_g' ,'cmlfeedintake_g']].applymap('{:,.0f}'.format))
    breed_df_touse.update(breed_df_touse[['pct_yield']].applymap('{:,.1f}%'.format))
    breed_df_touse.update(breed_df_touse[['fcr']].applymap('{:,.2f}'.format))

    return [
            html.H4(f"{breed_label_touse} Breed Standard"),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=breed_df_touse.to_dict('records'),
                export_format="csv",
                style_cell={
                    'font-family':'sans-serif',
                    },
            )
        ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# Update waterfall chart
@gbadsDash.callback(
    Output('poultry-waterfall','figure'),
    Input('core-data-poultry','data'),
    Input('select-metric-poultry', 'value'),
    Input('select-country-poultry','value'),
    Input('select-year-poultry','value'),
    Input('producer-price-slider-poultry','value')
    )
def update_waterfall_poultry(input_json, metric, country, year, producerprice):
    # Dash callback input data is a string that names a json file
    # First read it into a dataframe
    input_df = pd.read_json(input_json, orient='split')

    # Structure for plot
    waterfall_df = prep_bod_forwaterfall(input_df ,USDPERKG=producerprice)

    # Apply country and year filters
    waterfall_df = waterfall_df.loc[(waterfall_df['country'] == country) & (waterfall_df['year'] == year)]

    x = waterfall_df['Component']
    y = waterfall_df[metric]

    # Burden of disease
    mortality = waterfall_df.loc[waterfall_df['Component'] == 'Mortality & Condemns', metric ].iloc[0]
    morbidity = waterfall_df.loc[waterfall_df['Component'] == 'Morbidity', metric].iloc[0]
    BOD = abs(mortality + morbidity)

    if metric.upper() == 'TONNES':
      text = [f"{i:,.0f}" for i in waterfall_df[metric]]
      BOD = '{:,.0f}'.format(BOD)
      BOD = BOD + ' tonnes'
      axis_title = 'Tonnes carcass weight'
      axis_format = ''
    elif metric.upper() == 'US DOLLARS':
      text = [f"${i:,.0f}" for i in waterfall_df[metric]]
      BOD = '${:,.0f} USD'.format(BOD)
      axis_title = 'US dollars'
      axis_format = ''
    elif metric.upper() == 'PERCENT OF GDP':
      text = [f"{i:.3%}" for i in waterfall_df[metric]]
      BOD = '{:,.3%}'.format(BOD)
      BOD = BOD + ' of GDP'
      axis_title = 'Percent of GDP'
      axis_format = '~%'
    elif metric.upper() == 'PERCENT OF BREED STANDARD':
      text = [f"{i:.2%}" for i in waterfall_df[metric]]
      BOD = '{:,.2%}'.format(BOD)
      BOD = BOD + ' of Breed Standard'
      axis_title = 'Percent of Breed Standard'
      axis_format = '~%'
    elif metric.upper() == 'PERCENT OF REALISED PRODUCTION':
      text = [f"{i:.2%}" for i in waterfall_df[metric]]
      BOD = '{:,.2%}'.format(BOD)
      BOD = BOD + ' of Breed Standard'
      axis_title = 'Percent of Realised Production'
      axis_format = '~%'


    fig = create_waterfall(x, y, text)
    fig.update_layout(title_text=f'Poultry Production | {country}, {year} <br><sup>Burden of disease: {BOD} lost production (Mortality & Condemns + Morbidity)</sup>'
                      ,font_size=15
                      ,yaxis_title=axis_title
                      ,yaxis_tickformat=axis_format
                      )

    # Adjust color for Effect of Feed and Practices bar if negative
    if (waterfall_df.loc[waterfall_df['Component'] == 'Effect of Feed & Practices', metric].iloc[0]) < 0:
        fig.add_shape(
        type="rect",
        fillcolor="#E84C3D",
        line=dict(color="#E84C3D",
                  width=.5),
        opacity=1,
        x0=0.6,
        x1=1.4,
        xref="x",
        y0=fig.data[0].y[0],
        y1=fig.data[0].y[0] + fig.data[0].y[1],
        yref="y"
        )


    # Adjust color of Breed Standard Potential bar
    fig.add_shape(
    type="rect",
    fillcolor="#3598DB",
    line=dict(color="#3598DB",
              width=.5),
    opacity=1,
    x0=-0.4,
    x1=0.4,
    xref="x",
    y0=0.0,
    y1=fig.data[0].y[0],
    yref="y"
    )

    # Adjust color of Realised production bar
    fig.add_shape(
    type="rect",
    fillcolor="#2DCC70",
    line=dict(color="#2DCC70",
              width=.5),
    opacity=1,
    x0=3.6,
    x1=4.4,
    xref="x",
    y0=0.0,
    y1=fig.data[0].y[-1], yref="y"
    )

    fig.add_annotation(x=2, xref='x',         # x position is absolute on axis
                      y=0, yref='paper',     # y position is relative [0,1] to work regardless of scale
                      text="Source: GBADs",
                      showarrow=False,
                      yshift=10,
                      font=dict(
                          family="Helvetica",
                          size=18,
                          color="black"
                          )
                      )
    return fig

# Update Waterfall footnote
@gbadsDash.callback(
    Output('waterfall-footnote-poultry','children'),
    Input('select-country-poultry','value')
    )
def update_waterfall_footnote_poultry(country):
    breed_label_touse = poultry_lookup_breed_from_country[country]
    display_text = f"*Using {breed_label_touse} breed standard for {country}"
    return display_text

# # Update Sankey diagram
# @gbadsDash.callback(
#    Output('poultry-sankey','figure'),
#    Input('core-data-poultry','data'),
#    Input('select-metric-poultry', 'value'),
#    Input('select-country-poultry','value'),
#    Input('select-year-poultry','value'),
#    Input('achievable-pct-slider-poultry','value'),
#    Input('dof-slider-poultry','value')
#    )
# def update_sankey_poultry(input_json, metric, country, year, achievable, dof):
#    # Dash callback input data is a string that names a json file
#    # First read it into a dataframe
#    input_df = pd.read_json(input_json, orient='split')

#    # Structure for plot
#    sankey_df = prep_bod_forsankey(input_df)

#    # Apply country and year filters
#    sankey_df = sankey_df.loc[(sankey_df['country'] == country) & (sankey_df['year'] == year)]

#    ### UPDATE SANKEY ###
#    # This creates indexes to be used in the Sankey diagram
#    label_list = sankey_df['Component'].unique().tolist() + sankey_df['Component Source'].unique().tolist()

#    label_idx_dict = {}
#    for idx, label in enumerate(label_list):
#       label_idx_dict[label] = idx
#    label_idx_dict

#    sankey_df['Component_idx'] = sankey_df['Component'].map(label_idx_dict)
#    sankey_df['Component_Source_idx'] = sankey_df['Component Source'].map(label_idx_dict)

#    # Create source, target, and value lists
#    source = sankey_df['Component_Source_idx'].tolist()
#    target = sankey_df['Component_idx'].tolist()
#    values = sankey_df['Tonnes'].tolist()
#    print('Checking source value')
#    print(source)

#    n = len(sankey_df['Component_Source_idx'])

#    # Define node colors based on feature name and selected achievable % of breed standard
#    # Define x,y to move the burden of disease node down
#    # if achievable == 100:
#    #     color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#    #     x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47, np.nan]
#    #     y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95, np.nan]
#    # elif achievable < 100:
#    #     color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#    #     x = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#    #     y = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    # else:
#    #     color = ("white","#5BC0DE","#333333","#A66999","#333333","#F7931D","white","#98C193","#F7C42A")
#    #     x = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#    #     y = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    if country == 'United Kingdom' and achievable == 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47, np.nan]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95, np.nan]
#    elif country == 'United Kingdom' and achievable < 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [.33, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [.86, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable < 93:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable < 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [.33, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [.86, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable == 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    else:
#        color = ("white","#5BC0DE","#333333","#A66999","#333333","#F7931D","white","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .95]

#    sankey_fig = create_sankey(label_list, color, x, y, source, target, values, n)

#    sankey_fig.update_layout(title_text=f'Poultry | Production and burden of disease in {metric} <br><sup>{country}, {year}</sup>'
#                      ,font_size=15
#                      )

#    return sankey_fig

# Update Stacked bar chart
@gbadsDash.callback(
    Output('poultry-stacked-bar','figure'),
    Input('core-data-poultry','data'),
    Input('select-country-poultry','value'),
    Input('select-year-poultry','value'),
    )
def update_stacked_bar_poultry(input_json, country, year):

    input_df = pd.read_json(input_json, orient='split')

    # -----------------------------------------------------------------------------
    # Base plot
    # -----------------------------------------------------------------------------
    # Structure for plot
    stackedbar_df = prep_bod_forstackedbar_poultry(input_df)

    # Apply country and year filters
    stackedbar_df = stackedbar_df.loc[(stackedbar_df['country'] == country) & (stackedbar_df['year'] == year)]

    x = stackedbar_df['opt_or_act']
    y = stackedbar_df['cost_usdperkglive']
    color = stackedbar_df['Cost Item']
    poultry_bar_fig = create_stacked_bar_poultry(stackedbar_df, x, y, color)

    # Burden of disease
    BOD = stackedbar_df.loc[stackedbar_df['cost_item'] == 'bod_costs' ,'cost_usdperkglive'].values[0]

    poultry_bar_fig.update_layout(title_text=f'Poultry Costs | {country}, {year}<br><sup>Burden of disease: ${BOD :.2f} increased cost per kg live weight</sup>',
                                font_size=15)

    # # -----------------------------------------------------------------------------
    # # Add connecting lines
    # # -----------------------------------------------------------------------------
    # optactcost_1_t = costs_poultry.set_index('Costs').transpose().reset_index(drop=True)
    # optactcost_1_t_dict = optactcost_1_t.to_dict()

    # for i in range(0,1):
    #     for j, _ in enumerate(optactcost_1_t_dict):
    #         y1 = 0
    #         y2 = 0
    #         for key in list(optactcost_1_t_dict.keys())[:j+1]:
    #             y1 += optactcost_1_t_dict[key][i]
    #             y2 += optactcost_1_t_dict[key][i+1]

    #         poultry_bar_fig.add_trace(go.Scatter(
    #             # x=[0.25, 0.75],
    #             x = [optactcost_2['opt_or_act'][i],optactcost_2['opt_or_act'][i+6]],
    #             # x0 = optactcost_2['opt_or_act'][i],
    #             # x1 = optactcost_2['opt_or_act'][i+5],
    #             # x0=swine_bar_fig.data[1].y[0],
    #             y=[y1, y2],
    #             mode="lines",
    #             showlegend=False,
    #             line={'dash': 'dot', 'color': "#7A7A7A"}
    #         ))

    return poultry_bar_fig


# ==============================================================================
#### UPDATE SWINE
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
# Update regions based on region contry aligment selection:
@gbadsDash.callback(
    Output(component_id='select-region-swine', component_property='options'),
    Input(component_id='Region-country-alignment-swine', component_property='value'),
    )
def update_region_options_swine(region_country):
    if region_country == "WOAH":
        options = WOAH_region_options
    elif region_country =="FAO":
        options = fao_region_options
    elif region_country == "World Bank":
        options = wb_region_options
    return options

# Update country options based on region selection
@gbadsDash.callback(
    Output(component_id='select-country-swine', component_property='options'),
    Input(component_id='Region-country-alignment-swine', component_property='value'),
    Input(component_id='select-region-swine', component_property='value'),
    )
def update_country_options_swine(region_country, region):
    if region_country == "WOAH":
        if region == "All":
            options = country_options_swine
        elif region == "Africa":
            options = WOAH_africa_options
        elif region == "Americas":
            options = WOAH_americas_options
        elif region == "Asia, Far East and Oceania":
            options = WOAH_asia_options
        else:
            options = WOAH_europe_options
    elif region_country =="FAO":
        if region == "All":
            options = country_options_swine
        elif region == "Africa":
            options = fao_africa_options
        elif region == "Asia":
            options = fao_asia_options
        elif region == "Europe and Central Asia":
            options = fao_eca_options
        elif region == "Latin America and the Caribbean":
            options = fao_lac_options
        else:
            options = fao_swp_options
    elif region_country == "World Bank":
        if region == "All":
            options = country_options_swine
        elif region == "Sub-Saharan Africa":
            options = wb_africa_options
        elif region == "Europe & Central Asia":
            options = wb_eca_options
        elif region == "Latin America & the Caribbean":
            options = wb_lac_options
        elif region == "North America":
            options = wb_na_options
        else:
            options = wb_southasia_options

    return options

# Set slider starting values and add reference underneath based on selected country
# Also enable "Reset to Default" button
@gbadsDash.callback(
    Output('dof-slider-swine', 'value'),
    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
    )
def reset_daysonfeed_swine(reset):
    return dof_swine_default

# @gbadsDash.callback(
#     Output('dof-slider-swine', 'value'),
#     Output('reference-dof-swine', 'children'),
#     Input('select-country-swine', 'value'),
#     Input('select-year-swine', 'value'),
#     Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
#     )
# def show_ref_daysonfeed_swine(country, year, reset):
#     input_df = gbads_pigs_merged_fordash
#     _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
#     datavalue = input_df.loc[_rowselect ,'acc_avgdaysonfeed'].values[0]
#     country_shortname = country_shortnames[country]
#     if pd.isnull(datavalue):
#       slider = dof_swine_default
#       display = '(no data)'
#     else:
#       slider = round(datavalue ,0)
#       display = f'{datavalue:.0f} days'
#     return slider, f'Average for {country_shortname} in {year}: {display}'

# @gbadsDash.callback(
#    Output('feed-slider-swine', 'value'),
#    Output('reference-feedintake-swine', 'children'),
#    Input('select-country-swine', 'value'),
#    Input('select-year-swine', 'value'),
#    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
#    )
# def show_ref_feedintake_swine(country, year, reset):
#    input_df = gbads_pigs_merged_fordash
#    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
#    datavalue = input_df.loc[_rowselect ,'acc_avgfeedintake_kgperhd'].values[0]
#    country_shortname = country_shortnames[country]
#    if pd.isnull(datavalue):
#       slider = feed_swine_default
#       display = '(no data)'
#    else:
#       slider = round(datavalue ,1)
#       display = f'{datavalue:.1f} kg'
#    return slider, f'Average for {country_shortname} in {year}: {display}'

@gbadsDash.callback(
    Output('achievable-weight-slider-swine', 'value'),
    Output('reference-liveweight-swine', 'children'),
    Input('select-country-swine', 'value'),
    Input('select-year-swine', 'value'),
    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_liveweight_swine(country, year, reset):
    input_df = gbads_pigs_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_avgliveweight_kg'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = achievable_weight_swine_default
      display = '(no data)'
    else:
      slider = round(datavalue * 1.1 ,0)   # 10% higher than actual
      display = f'{datavalue:.1f} kg'
    return slider, f'Average for {country_shortname} in {year}: {display}'

@gbadsDash.callback(
    Output('producer-price-slider-swine', 'value'),
    Output('reference-producerprice-swine', 'children'),
    Input('select-country-swine', 'value'),
    Input('select-year-swine', 'value'),
    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_producerprice_swine(country, year, reset):
    input_df = gbads_pigs_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_producerprice_usdperkgcarc'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = producer_price_swine_default
      display = '(no data)'
    else:
      slider = round(datavalue ,2)
      display = f'${datavalue:.2f}'
    return slider, f'Average for {country_shortname} in {year}: {display}'

@gbadsDash.callback(
    Output('ration-price-slider-swine', 'value'),
    Output('reference-feedprice-swine', 'children'),
    Input('select-country-swine', 'value'),
    Input('select-year-swine', 'value'),
    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_feedprice_swine(country, year, reset):
    input_df = gbads_pigs_merged_fordash
    _rowselect = (input_df['country'] == country) & (input_df['year'] == year)
    datavalue = input_df.loc[_rowselect ,'acc_feedprice_usdpertonne'].values[0]
    country_shortname = country_shortnames[country]
    if pd.isnull(datavalue):
      slider = ration_price_swine_default
      display = '(no data)'
    else:
      slider = round(datavalue ,2)
      display = f'${datavalue:.2f}'
    return slider, f'Average for {country_shortname} in {year}: {display}'

# Using Breed Standard FCR as reference
@gbadsDash.callback(
    Output('fcr-slider-swine', 'value'),
    Output('reference-fcr-swine', 'children'),
    Input('select-country-swine', 'value'),
    Input('dof-slider-swine', 'value'),
    Input(component_id='reset-val-swine', component_property='n_clicks')   # Reset to defaults button
    )
def show_ref_fcr_swine(country, dof, reset):
    breed_label_touse = swine_lookup_breed_from_country[country]
    breed_df_touse = swine_lookup_breed_df[breed_label_touse]
    _rowselect = (breed_df_touse['dayonfeed'] == dof)
    datavalue = breed_df_touse.loc[_rowselect ,'cml_fcr'].values[0]
    if pd.isnull(datavalue):
      slider = fcr_swine_default
      display = '(no data)'
    else:
      slider = round(datavalue ,2)
      display = f'{datavalue:.2f}'
    return slider, f'Breed standard: {display}'

# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# MUST HAPPEN FIRST: Calculate burden of disease components on core data

# Using Achievable Percent and Days on Feed
#!!! Make sure appropriate sliders are activated in LAYOUT!
# @gbadsDash.callback(
#     Output('core-data-swine','data'),
#     Input('achievable-pct-slider-swine','value'),
#     Input('dof-slider-swine','value')
#     )
# def update_core_data_swine(achievable_pct ,avg_dof):
#     swine_data_withbod = bod_calcs.calc_bod_master_swine(
#       gbads_pigs_merged_fordash
#       ,ACHIEVABLE_PCT_MASTER=achievable_pct
#       ,AVG_DOF_MASTER=avg_dof
#       ,BREED_DF_MASTER=swinebreedstd_pic_growthandfeed   # Data frame with breed reference information. Must contain columns 'dayonfeed' and 'bodyweight_g'.
#       ,AVG_CARC_YIELD_MASTER=0.75                        # Float [0, 1]: average carcass yield in kg meat per kg live weight
#     )
#     swine_data_withbod['year'] = swine_data_withbod['year'].astype(str)   # Change Year type to text
#     return swine_data_withbod.to_json(date_format='iso', orient='split')

# Alternative call using ACHIEVABLE WEIGHT instead of ACHIEVABLE PERCENT
#!!! Make sure appropriate sliders are activated in LAYOUT!
@gbadsDash.callback(
    Output('core-data-swine','data'),
    Input('achievable-weight-slider-swine','value'),
    Input('dof-slider-swine','value'),
    Input('ration-price-slider-swine','value'),
    Input('fcr-slider-swine','value')
    )
def update_core_data_swine(achievable_wt ,avg_dof ,feedprice ,fcr):
    swine_data_withbod = bod.calc_bod_master_swine(
        gbads_pigs_merged_fordash
        ,ACHIEVABLE_WT_KG_MASTER=achievable_wt             # Float: achievable weight without disease
        ,AVG_DOF_MASTER=avg_dof                            # Integer [1, 176]: Average days on feed. Will lookup breed standard weight for this day on feed.
        ,BREED_DF_MASTER=swinebreedstd_pic_growthandfeed   # Data frame with breed reference information. Must contain columns 'dayonfeed' and 'bodyweight_g'.
        ,AVG_CARC_YIELD_MASTER=0.75                        # Float [0, 1]: average carcass yield in kg meat per kg live weight
        ,FEEDPRICE_USDPERTONNE_MASTER=feedprice           # Float
        ,IDEAL_FCR_LIVE_MASTER=fcr                        # Float: ideal FCR per kg live weight
    )
    swine_data_withbod['year'] = swine_data_withbod['year'].astype(str)   # Change Year type to text
    return swine_data_withbod.to_json(date_format='iso', orient='split')

# Alternative call using Feed Intake instead of Days on Feed to determine standard
#!!! Make sure appropriate sliders are activated in LAYOUT!
# @gbadsDash.callback(
#     Output('core-data-swine','data'),
#     Input('achievable-weight-slider-swine','value'),
#     Input('feed-slider-swine','value')
#     )
# def update_core_data_swine(achievable_wt ,avg_feedint):
#     swine_data_withbod = bod.calc_bod_master_swine(
#          gbads_pigs_merged_fordash
#          ,ACHIEVABLE_WT_KG_MASTER=achievable_wt             # Float: achievable weight without disease
#          ,AVG_FEEDINT_KG_MASTER=avg_feedint                 # Float: average feed intake in kg per head
#          ,BREED_DF_MASTER=swinebreedstd_pic_growthandfeed   # Data frame with breed reference information. Must contain columns 'dayonfeed' and 'bodyweight_g'.
#          ,AVG_CARC_YIELD_MASTER=0.75                        # Float [0, 1]: average carcass yield as proportion of live weight
#     )
#     swine_data_withbod['year'] = swine_data_withbod['year'].astype(str)   # Change Year type to text
#     return swine_data_withbod.to_json(date_format='iso', orient='split')

# Can happen in any order after update_core_data
# These update when user changes filtering (country and year)
# Update data table to show user
@gbadsDash.callback(
    Output('swine-background-data', 'children'),
    Input('core-data-swine','data'),
    Input('select-country-swine','value'),
    Input('producer-price-slider-swine','value'),
    Input('ration-price-slider-swine','value'),
    )
def update_background_data_swine(input_json, country ,producerprice ,rationprice):
    # Dash callback input data is a string that names a json file
    # First read it into a dataframe
    input_df = pd.read_json(input_json, orient='split')
    background_data = input_df.loc[(input_df['country'] == country)]

    # Add slider values as columns to display
    background_data['producerprice_usdperkg'] = producerprice
    background_data['rationprice_usdpertonne'] = rationprice
    background_data['bod_totalburden_usd'] = background_data['bod_totalburden_tonnes'] * 1000 \
      * background_data['producerprice_usdperkg']

    columns_to_display_with_labels = {
      'country':'Country'
      ,'year':'Year'

      ,'acc_breedingsows':'Breeding Sows'
      # ,'acc_headfarrowed':'Head Farrowed'
      ,'acc_headweaned':'Head Weaned'
      ,'acc_headplaced':'Head Placed'
      ,'acc_headslaughtered':'Head Slaughtered'
      ,'acc_totalcarcweight_tonnes':'Total Carcass Weight (tonnes)'   # Equal to bod_realizedproduction_tonnes
      ,'acc_avgcarcweight_kg':'Avg. Carcass Weight (kg)'
      # ,'acc_avgliveweight_kg':'Avg Live Weight (kg)'
      # ,'acc_avgdaysonfeed':'Avg Days on Feed'   # Using input value rather than this column
      # ,'acc_feedconsumption_tonnes':'Total Feed Consumed (tonnes)'
      # ,'acc_avgfeedintake_kgperhd':'Avg. Feed Intake (kg per head)'

      ,'bod_dof_used':'Days on Feed'
      # ,'bod_feedint_used':'Feed Intake (kg per hd)'
      ,'bod_breedstdwt_kg':'Breed Standard Live Weight (kg)'
      ,'bod_breedstdyield_prpn':'Breed Standard Carcass Yield'
      ,'bod_breedstdcarcwt_kg':'Breed Standard Carcass Weight (kg)'
      ,'bod_referenceproduction_tonnes':'Breed Standard Potential (tonnes)'
      ,'bod_efficiency_tonnes':'Effect of Feed & Practices (tonnes)'
      ,'bod_gmax_tonnes':'Achievable without Disease (tonnes)'
      ,'bod_deathloss_tonnes':'Mortality & Condemns (tonnes)'
      ,'bod_morbidity_tonnes':'Morbidity (tonnes)'
      ,'bod_realizedproduction_tonnes':'Realised Production (tonnes)'
      ,'bod_totalburden_tonnes':'Total Burden of Disease (tonnes)'

      ,'producerprice_usdperkg':'Producer Price (USD per kg)'
      ,'bod_totalburden_usd':'Total Burden of Disease (USD)'
      # ,'wb_gdp_usd':'GDP (USD)'

      ,'acc_feedcost_usdperkgcarc':'Avg. Feed Cost (USD per kg carcass weight)'
      ,'acc_nonfeedvariablecost_usdperkgcarc':'Avg. Non-feed Variable Costs (USD per kg carcass weight)'
      ,'acc_laborcost_usdperkgcarc':'Avg. Labour Cost (USD per kg carcass weight)'
      ,'acc_landhousingcost_usdperkgcarc':'Avg. Land & Housing Cost (USD per kg carcass weight)'

      ,'ideal_headplaced':'Ideal Head Placed'
      ,'ideal_fcr':'Ideal FCR'
      ,'ideal_feed_tonnes':'Ideal Feed Consumption (tonnes)'
      ,'rationprice_usdpertonne':'Feed Price (USD per tonne)'
      ,'ideal_feedcost_usdperkgcarc':'Ideal Feed Cost (USD per kg carcass weight)'
      ,'ideal_nonfeedvariablecost_usdperkgcarc':'Ideal Non-feed Variable Costs (USD per kg carcass weight)'
      ,'ideal_laborcost_usdperkgcarc':'Ideal Labour Cost (USD per kg carcass weight)'
      ,'ideal_landhousingcost_usdperkgcarc':'Ideal Land & Housing Cost (USD per kg carcass weight)'
    }
    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places
    background_data.update(background_data[[
      'acc_breedingsows'
      ,'acc_headweaned'
      ,'acc_headplaced'
      ,'acc_headslaughtered'
      ,'acc_totalcarcweight_tonnes'
      # ,'acc_feedconsumption_tonnes'
      ,'bod_referenceproduction_tonnes'
      ,'bod_realizedproduction_tonnes'
      ,'bod_efficiency_tonnes'
      ,'bod_gmax_tonnes'
      ,'bod_deathloss_tonnes'
      ,'bod_morbidity_tonnes'
      ,'bod_totalburden_tonnes'
      ,'wb_gdp_usd'
      ,'ideal_headplaced'
      ,'ideal_feed_tonnes'
    ]].applymap('{:,.0f}'.format))

    # One decimal place
    background_data.update(background_data[[
      'bod_breedstdwt_kg'
      ,'bod_breedstdcarcwt_kg'
      ,'acc_avgcarcweight_kg'
      # ,'acc_avgfeedintake_kgperhd'
    ]].applymap('{:,.1f}'.format))

    # Two decimal places
    background_data.update(background_data[[
      'producerprice_usdperkg'
      ,'bod_totalburden_usd'
      ,'bod_breedstdyield_prpn'
      ,'rationprice_usdpertonne'
      ,'acc_feedcost_usdperkgcarc'
      ,'acc_nonfeedvariablecost_usdperkgcarc'
      ,'acc_laborcost_usdperkgcarc'
      ,'acc_landhousingcost_usdperkgcarc'
      ,'ideal_fcr'
      ,'ideal_feedcost_usdperkgcarc'
      ,'ideal_nonfeedvariablecost_usdperkgcarc'
      ,'ideal_laborcost_usdperkgcarc'
      ,'ideal_landhousingcost_usdperkgcarc'
    ]].applymap('{:,.2f}'.format))

    # ------------------------------------------------------------------------------
    # Hover-over text
    # ------------------------------------------------------------------------------
    # Read last row of data with filters applied to get source of each column.
    # For most countries and columns, source is the same for every year.
    # But if source differs for later years, want to report the latest.
    background_data_lastrow = background_data.iloc[-1 ,:]

    column_tooltips = {
      'acc_breedingsows':f"Source: {background_data_lastrow['acc_breedingsows_src']}"
      # ,"acc_headfarrowed":f"Breeding sows ({background_data_lastrow['acc_headfarrowed_src']}) x (Avg litter size) x (Avg litters per sow per year)"
      ,"acc_headweaned":f"[Breeding Sows] x Pigs weaned per sow per year ({background_data_lastrow['acc_litters_persow_peryear_src']})"
      ,"acc_headplaced":f"[Head Weaned] adjusted for net imports ({background_data_lastrow['acc_netimport_gte50kg_src']})"
      ,"acc_headslaughtered":f"Source: {background_data_lastrow['acc_headslaughtered_src']}"
      ,"acc_totalcarcweight_tonnes":f"Source: {background_data_lastrow['acc_totalcarcweight_tonnes_src']}"
      ,"acc_avgcarcweight_kg":"[Realised Production] / [Head Slaughtered]"
      # ,"acc_feedconsumption_tonnes":f"Source: {background_data_lastrow['acc_feedconsumption_tonnes_src']}"
      ,"acc_avgfeedintake_kgperhd":f"[Total Feed Consumed] / [Head Slaughtered], adjusted for feed consumed by head that died"

      ,"bod_dof_used":"Set by slider: days on feed"
      ,'bod_feedint_used':"Set by slider: average feed intake"
      ,"bod_breedstdwt_kg":"Source: breed standard @ selected days on feed"
      ,"bod_breedstdyield_prpn":"Overall average"
      ,"bod_breedstdcarcwt_kg":"[Breed Standard Live Weight] x [Standard Carcass Yield]"
      ,"bod_referenceproduction_tonnes":"[Head Placed] x [Breed Standard Live Weight] x Avg. carcass yield"
      ,"bod_realizedproduction_tonnes":f"Source: {background_data_lastrow['acc_totalcarcweight_tonnes_src']}"
      ,"bod_efficiency_tonnes":"Adjustment to breed standard potential according to achievable weight (slider)"
      ,"bod_gmax_tonnes":"[Breed Standard Potential] + [Effect of Feed & Practices]"
      ,"bod_deathloss_tonnes":"[Head Placed] - [Head Slaughtered]"
      ,"bod_morbidity_tonnes":"[Achievable without Disease] - [Mortality & Condemns] - [Realised Production]"
      ,"bod_totalburden_tonnes":"[Mortality & Condemns] + [Morbidity]"

      ,"producerprice_usdperkg":"Set by slider: Price to producers"
      ,"bod_totalburden_usd":"[Total Burden of Disease (tonnes)] x 1000 x [Producer Price (USD per kg)]"
      ,"rationprice_usdpertonne":"Set by slider: Ration price"
      ,"wb_gdp_usd":"Source: World Bank"

      ,"acc_feedcost_usdperkgcarc":f"Source: {background_data_lastrow['acc_feedcost_usdperkgcarc_src']}"
      ,"acc_nonfeedvariablecost_usdperkgcarc":f"Source: {background_data_lastrow['acc_nonfeedvariablecost_usdperkgcarc_src']}"
      ,"acc_laborcost_usdperkgcarc":f"Source: {background_data_lastrow['acc_laborcost_usdperkgcarc_src']}"
      ,"acc_landhousingcost_usdperkgcarc":f"Source: {background_data_lastrow['acc_landhousingcost_usdperkgcarc_src']}"

      ,"ideal_headplaced":"Animals required to match realised production if there were no mortality or morbidity"
      ,"ideal_fcr":"Set by slider: ideal feed conversion ratio"
      ,"ideal_feed_tonnes":"Feed required to match realised production at zero mortality and ideal FCR"
      ,"rationprice_usdpertonne":"Set by slider: feed price"
      ,"ideal_feedcost_usdperkgcarc":"[Ideal Feed Consumption] x [Feed Price]"
      ,"ideal_nonfeedvariablecost_usdperkgcarc":"Actual non-feed variable cost reduced proportionally with ideal head placed / actual head placed"
      ,"ideal_landhousingcost_usdperkgcarc":"Actual land & housing cost reduced proportionally with ideal head placed / actual head placed"
      ,"ideal_laborcost_usdperkgcarc":"Actual labor cost reduced proportionally with ideal land & housing cost"
    }

    return [
            html.H4(f"Data for {country}"),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=background_data.to_dict('records'),
                export_format="csv",
                sort_action = 'native',
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll'},

                # Hover-over for column headers
                tooltip_header=column_tooltips,
                tooltip_delay= 500,
                tooltip_duration=50000,

                # Underline columns with tooltips
                style_header_conditional=[{
                    'if': {'column_id': col},
                    'textDecoration': 'underline',
                    'textDecorationStyle': 'dotted',
                    } for col in list(column_tooltips)],
            )
        ]

@gbadsDash.callback(
    Output('swine-breed-data', 'children'),
    Input('core-data-swine','data')   # Currently only one breed used, so no inputs needed. But Dash wants an input here.
    )
def update_breed_data_swine(breed):
    columns_to_display_with_labels = {
      'dayonfeed':'Day on Feed'
      ,'bodyweight_kg':'Live Weight (kg)'
      ,'cml_feedintake_kg':'Cml Feed Intake (kg)'
      ,'cml_fcr':'FCR'
    }
    breed_data = swinebreedstd_pic_growthandfeed.copy()

    # Subset columns
    breed_data = breed_data[list(columns_to_display_with_labels)]

    # Format numbers
    breed_data.update(breed_data[['dayonfeed']].applymap('{:,.0f}'.format))
    breed_data.update(breed_data[['bodyweight_kg' ,'cml_feedintake_kg']].applymap('{:,.1f}'.format))
    breed_data.update(breed_data[['cml_fcr']].applymap('{:,.2f}'.format))

    return [
            html.H4("PIC Breed Standard"),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=breed_data.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
            )
        ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# Update waterfall chart
@gbadsDash.callback(
    Output('swine-waterfall','figure'),
    Input('core-data-swine','data'),
    Input('select-metric-swine', 'value'),
    Input('select-country-swine','value'),
    Input('select-year-swine','value'),
    Input('producer-price-slider-swine','value')
    )
def update_waterfall_swine(input_json, metric, country, year, producerprice):
    # Dash callback input data is a string that names a json file
    # First read it into a dataframe
    input_df = pd.read_json(input_json, orient='split')

    # Structure for plot
    waterfall_df = prep_bod_forwaterfall(input_df ,USDPERKG=producerprice)

    # Apply country and year filters
    waterfall_df = waterfall_df.loc[(waterfall_df['country'] == country) & (waterfall_df['year'] == year)]

    ### JR: Simplified plot spec after calcs moved to prep_bod_forwaterfall()
    x = waterfall_df['Component']
    y = waterfall_df[metric]

    # Burden of disease
    mortality = waterfall_df.loc[waterfall_df['Component'] == 'Mortality & Condemns', metric].iloc[0]
    morbidity = waterfall_df.loc[waterfall_df['Component'] == 'Morbidity', metric].iloc[0]
    BOD = abs(mortality + morbidity)

    if metric.upper() == 'TONNES':
      text = [f"{i:,.0f}" for i in waterfall_df[metric]]
      BOD = '{:,.0f}'.format(BOD)
      BOD = BOD + ' tonnes'
      axis_title = 'Tonnes carcass weight'
      axis_format = ''
    elif metric.upper() == 'US DOLLARS':
      text = [f"${i:,.0f}" for i in waterfall_df[metric]]
      BOD = '${:,.0f} USD'.format(BOD)
      axis_title = 'US dollars'
      axis_format = ''
    elif metric.upper() == 'PERCENT OF GDP':
      text = [f"{i:.3%}" for i in waterfall_df[metric]]
      BOD = '{:,.3%}'.format(BOD)
      BOD = BOD + ' of GDP'
      axis_title = 'Percent of GDP'
      axis_format = '~%'
    elif metric.upper() == 'PERCENT OF BREED STANDARD':
      text = [f"{i:.2%}" for i in waterfall_df[metric]]
      BOD = '{:,.2%}'.format(BOD)
      BOD = BOD + ' of Breed Standard'
      axis_title = 'Percent of Breed Standard'
      axis_format = '~%'
    elif metric.upper() == 'PERCENT OF REALISED PRODUCTION':
      text = [f"{i:.2%}" for i in waterfall_df[metric]]
      BOD = '{:,.2%}'.format(BOD)
      BOD = BOD + ' of Breed Standard'
      axis_title = 'Percent of Realised Production'
      axis_format = '~%'

    fig = create_waterfall(x, y, text)

    fig.update_layout(title_text=f'Swine Production | {country}, {year} <br><sup>Burden of disease: {BOD} lost production (Mortality & Condemns + Morbidity)</sup>'
                      ,font_size=15
                      ,yaxis_title=axis_title
                      ,yaxis_tickformat=axis_format
                      )

    # Adjust color for Effect of Feed and Practices bar if negative
    if (waterfall_df.loc[waterfall_df['Component'] == 'Effect of Feed & Practices', metric].iloc[0]) < 0:
        fig.add_shape(
        type="rect",
        fillcolor="#E84C3D",
        line=dict(color="#E84C3D",
                  width=.5),
        opacity=1,
        x0=0.6,
        x1=1.4,
        xref="x",
        y0=fig.data[0].y[0],
        y1=fig.data[0].y[0] + fig.data[0].y[1],
        yref="y"
        )

    # Adjust color of Breed Standard Potential bar
    fig.add_shape(
    type="rect",
    fillcolor="#3598DB",
    line=dict(color="#3598DB",
              width=.5),
    opacity=1,
    x0=-0.4,
    x1=0.4,
    xref="x",
    y0=0.0,
    y1=fig.data[0].y[0],
    yref="y"
    )

    # Add outline to Realised production bar
    fig.add_shape(
    type="rect",
    fillcolor="#2DCC70",
    line=dict(color="#2DCC70",
              width=.5),
    opacity=1,
    x0=3.6,
    x1=4.4,
    xref="x",
    y0=0.0,
    y1=fig.data[0].y[-1],
    yref="y"
    )

    fig.add_annotation(x=2, xref='x',         # x position is absolute on axis
                      y=0, yref='paper',     # y position is relative [0,1] to work regardless of scale
                      text="Source: GBADs",
                      showarrow=False,
                      yshift=10,
                      font=dict(
                          family="Helvetica",
                          size=18,
                          color="black"
                          )
                      )
    return fig

# # Update Sankey diagram
# @gbadsDash.callback(
#    Output('swine-sankey','figure'),
#    Input('core-data-swine','data'),
#    Input('select-metric-swine', 'value'),
#    Input('select-country-swine','value'),
#    Input('select-year-swine','value'),
#    Input('achievable-weight-slider-swine','value'),
#    Input('feed-slider-swine','value')
#    # Input('dof-slider-swine','value')
#    )
# def update_sankey_swine(input_json, metric, country, year, achievable, dof):
#    # Dash callback input data is a string that names a json file
#    # First read it into a dataframe
#    input_df = pd.read_json(input_json, orient='split')

#    # Structure for plot
#    sankey_df = prep_bod_forsankey(input_df)

#    # Apply country and year filters
#    sankey_df = sankey_df.loc[(sankey_df['country'] == country) & (sankey_df['year'] == year)]

#    ### UPDATE SANKEY ###
#    # This creates indexes to be used in the Sankey diagram
#    label_list = sankey_df['Component'].unique().tolist() + sankey_df['Component Source'].unique().tolist()

#    label_idx_dict = {}
#    for idx, label in enumerate(label_list):
#       label_idx_dict[label] = idx
#    label_idx_dict

#    sankey_df['Component_idx'] = sankey_df['Component'].map(label_idx_dict)
#    sankey_df['Component_Source_idx'] = sankey_df['Component Source'].map(label_idx_dict)

#    # Create source, target, and value lists
#    source = sankey_df['Component_Source_idx'].tolist()
#    target = sankey_df['Component_idx'].tolist()
#    values = sankey_df['Tonnes'].tolist()
#    print('Checking source value')
#    print(source)

#    n = len(sankey_df['Component_Source_idx'])

#    # JR: commenting-out code to set color, x, and y based on inputs
#    color = ("white","white","#5BC0DE","#333333","#A66999","#7A7A7A","#FE9666","#75AC6F","#FFB703")
#    x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47, np.nan]
#    y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95, np.nan]

#    # Define node colors based on feature name and selected achievable % of breed standard
#    if country == 'United Kingdom' and achievable == 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47, np.nan]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95, np.nan]
#    elif country == 'United Kingdom' and achievable < 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [.33, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [.86, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable < 93:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable < 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [.33, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [.86, np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    elif country == 'United States of America' and dof == 60 and achievable == 100:
#        color = ("white","white","#5BC0DE","#333333","#A66999","#333333","#F7931D","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, .95]
#    else:
#        color = ("white","#5BC0DE","#333333","#A66999","#333333","#F7931D","white","#98C193","#F7C42A")
#        x = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .47]
#        y = [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, .95]

#    sankey_fig = create_sankey(label_list, color, x, y, source, target, values, n)
#    sankey_fig.update_layout(title_text=f'Swine | Production and burden of disease in {metric} <br><sup>{country}, {year}</sup>'
#                      ,font_size=15
#                      )

#    return sankey_fig

# Update Stacked bar chart
@gbadsDash.callback(
    Output('swine-stacked-bar','figure'),
    Input('core-data-swine','data'),
    Input('select-country-swine','value'),
    Input('select-year-swine','value'),
    )
def update_stacked_bar_swine(input_json, country, year):

    input_df = pd.read_json(input_json, orient='split')

    # -----------------------------------------------------------------------------
    # Base plot
    # -----------------------------------------------------------------------------
    # Structure for plot
    stackedbar_df = prep_bod_forstackedbar_swine(input_df)

    # Apply country and year filters
    stackedbar_df = stackedbar_df.loc[(stackedbar_df['country'] == country) & (stackedbar_df['year'] == year)]

    x = stackedbar_df['opt_or_act']
    y = stackedbar_df['cost_usdperkgcarc']
    color = stackedbar_df['Cost Item']
    swine_bar_fig = create_stacked_bar_swine(stackedbar_df, x, y, color)

    # Burden of disease
    BOD = stackedbar_df.loc[stackedbar_df['cost_item'] == 'bod_costs' ,'cost_usdperkgcarc'].values[0]

    swine_bar_fig.update_layout(title_text=f'Swine Costs | {country}, {year}<br><sup>Burden of disease: ${BOD :.2f} increased cost per kg carcass weight</sup>',
                                font_size=15)


    # # -----------------------------------------------------------------------------
    # # Add connecting lines
    # # -----------------------------------------------------------------------------
    # optactcost_1_t = costs_swine.set_index('Costs').transpose().reset_index(drop=True)
    # optactcost_1_t_dict = optactcost_1_t.to_dict()

    # for i in range(0,1):
    #     for j, _ in enumerate(optactcost_1_t_dict):
    #         y1 = 0
    #         y2 = 0
    #         for key in list(optactcost_1_t_dict.keys())[:j+1]:
    #             y1 += optactcost_1_t_dict[key][i]
    #             y2 += optactcost_1_t_dict[key][i+1]

    #         swine_bar_fig.add_trace(go.Scatter(
    #             # x=[0.25, 0.75],
    #             x = [optactcost_2['opt_or_act'][i],optactcost_2['opt_or_act'][i+6]],
    #             # x0 = optactcost_2['opt_or_act'][i],
    #             # x1 = optactcost_2['opt_or_act'][i+5],
    #             # x0=swine_bar_fig.data[1].y[0],
    #             y=[y1, y2],
    #             mode="lines",
    #             showlegend=False,
    #             line={'dash': 'dot', 'color': "#7A7A7A"}
    #         ))

    return swine_bar_fig


# ==============================================================================
#### UPDATE GLOBAL AGGREGATE
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
# Update regions based on region contry aligment selection:
@gbadsDash.callback(
    Output('select-region-overview-ga', 'options'),
    Input('Region-country-alignment-overview-ga', 'value'),
    )
def update_region_overview_options_ga(region_country):
    if region_country == "WOAH":
        options = WOAH_region_options_ga
    elif region_country =="FAO":
        options = fao_region_options_ga
    else:   # Fallback: World Bank
        options = wb_region_options_ga
    return options

@gbadsDash.callback(
    Output('select-region-detail-ga', 'options'),
    Input('Region-country-alignment-detail-ga', 'value'),
    )
def update_region_detail_options_ga(region_country):
    if region_country == "WOAH":
        options = WOAH_region_options_ga
    elif region_country =="FAO":
        options = fao_region_options_ga
    else:   # Fallback: World Bank
        options = wb_region_options_ga
    return options

# Update country options based on region and income group selection
@gbadsDash.callback(
    Output('select-country-overview-ga', 'options'),
    Input('Region-country-alignment-overview-ga', 'value'),
    Input('select-region-overview-ga', 'value'),
    Input('select-incomegrp-overview-ga','value'),
    )
def update_country_overview_options_ga(region_country, region, income):
    if region_country == "WOAH":
        if region == "All":
            options = country_options_ga
        elif region == "Africa":
            options = WOAH_africa_options_ga
        elif region == "Americas":
            options = WOAH_americas_options_ga
        elif region == "Asia, Far East and Oceania":
            options = WOAH_asia_options_ga
        elif region == "Europe":
            options = WOAH_europe_options_ga
        else:
            options = WOAH_me_options_ga
    elif region_country =="FAO":
        if region == "All":
            options = country_options_ga
        elif region == "Africa":
            options = fao_africa_options_ga
        elif region == "Asia":
            options = fao_asia_options_ga
        elif region == "Europe and Central Asia":
            options = fao_eca_options_ga
        elif region == "Latin America and the Caribbean":
            options = fao_lac_options_ga
        elif region == "Near East and North Africa":
            options = fao_ena_options_ga
        else:
            options = fao_swp_options_ga
    elif region_country == "World Bank":
        if region == "All":
            if income == "All":
                options = country_options_ga
            else:
                options_df = ga_countries_biomass.loc[(ga_countries_biomass['incomegroup'] == income)]
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
        else:
            options_df = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == region)]
            if income == "All":
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
            else:
                options_df = options_df.loc[(options_df['incomegroup'] == income)]
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
    else:
        options = country_options_ga

    return options

# Update country options based on region and income group selection
@gbadsDash.callback(
    Output('select-country-detail-ga', 'options'),
    Input('Region-country-alignment-detail-ga', 'value'),
    Input('select-region-detail-ga', 'value'),
    Input('select-incomegrp-detail-ga','value'),
    )
def update_country_detail_options_ga(region_country, region, income):
    if region_country == "WOAH":
        if region == "All":
            options = country_options_ga
        elif region == "Africa":
            options = WOAH_africa_options_ga
        elif region == "Americas":
            options = WOAH_americas_options_ga
        elif region == "Asia, Far East and Oceania":
            options = WOAH_asia_options_ga
        elif region == "Europe":
            options = WOAH_europe_options_ga
        else:
            options = WOAH_me_options_ga
    elif region_country =="FAO":
        if region == "All":
            options = country_options_ga
        elif region == "Africa":
            options = fao_africa_options_ga
        elif region == "Asia":
            options = fao_asia_options_ga
        elif region == "Europe and Central Asia":
            options = fao_eca_options_ga
        elif region == "Latin America and the Caribbean":
            options = fao_lac_options_ga
        elif region == "Near East and North Africa":
            options = fao_ena_options_ga
        else:
            options = fao_swp_options_ga
    elif region_country == "World Bank":
        if region == "All":
            if income == "All":
                options = country_options_ga
            else:
                options_df = ga_countries_biomass.loc[(ga_countries_biomass['incomegroup'] == income)]
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
        else:
            options_df = ga_countries_biomass.loc[(ga_countries_biomass['region_label'] == region)]
            if income == "All":
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
            else:
                options_df = options_df.loc[(options_df['incomegroup'] == income)]
                options = [{'label': "All", 'value': "All"}]
                for i in options_df['country'].unique():
                    str(options.append({'label':i,'value':(i)}))
    else:
        options = country_options_ga

    return options

# Update species options based on region and country selections
@gbadsDash.callback(
    Output('select-species-ga', 'options'),
    Input('select-country-overview-ga', 'value'),
    Input('select-region-overview-ga', 'value'),
    )
def update_species_options_ga(country, region):
    if region == 'All':
        if country == "All":
            options = []
            for i in ga_countries_biomass['species'].unique():
                str(options.append({'label':i,'value':(i)}))
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
            options = []
            for i in input_df['species'].unique():
                str(options.append({'label':i,'value':(i)}))
    elif region == "Sub-Saharan Africa":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_africa_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    elif region == "East Asia & Pacific":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_eap_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    elif region == "Europe & Central Asia":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_eca_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    elif region == "Latin America & the Caribbean":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_lac_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    elif region == "Middle East & North Africa":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_mena_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    elif region == "North America":
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_na_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))
    else:
        if country == 'All':
            country = [[v for k,v in d.items()] for d in wb_southasia_options_ga]
            country = [a[1] for a in country]
            input_df = ga_countries_biomass[ga_countries_biomass['country'].isin(country)]
        else:
            input_df=ga_countries_biomass.loc[(ga_countries_biomass['country'] == country)]
        # Set options for species based on the filters for region and country
        options = []
        for i in input_df['species'].unique():
            str(options.append({'label':i,'value':(i)}))

    return options

# Navigate to the AMU tab with button below waterfall
# @app.callback(
#     Output('tabs','active_tab'),
#     Input('am-expend-button-ga','n_clicks')
# )
# def display_amutab(n_clicks):
#     return 'AMU-tab'

# @app.callback(
#     Output('AMU-tab', 'value'),
#     [Input('am-expend-button-ga', 'n_clicks')]
# )
# def open_home_tab(n_clicks):
#     if not ctx.triggered:
#         return 'AMU-tab'

# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# Attribution datatable below graphic
@gbadsDash.callback(
    Output('ga-world-abt-datatable', 'children'),
    Input('select-species-ga','value'),
    Input('select-incomegrp-overview-ga','value'),
    Input('select-region-overview-ga', 'value'),
    Input('select-country-overview-ga','value'),
    # Input('select-currency-ecs','value'),
    Input('amu-regional-data', 'data'),
    )
def update_overview_table_ga(
        species
        ,income
        ,region
        ,country
        ,amu_data_json
    ):
    # Read in data
    input_df = ga_countries_biomass.copy()
    input_df_amu = pd.read_json(amu_data_json, orient='split')

    # Add mortality, morbidity, and vetmed rate columns
    input_df = ga.add_mortality_rate(input_df)
    input_df = ga.add_morbidity_rate(input_df)
    input_df = ga.add_vetmed_rates(input_df)
    input_df = ga.add_antimicrobial_expenditure(input_df ,input_df_amu)

    # Apply AHLE calcs
    input_df = ga.ahle_calcs_adj_outputs(input_df)

    # Filter Species
    input_df = input_df.loc[(input_df['species'] == species)]

    # Filter Income Group
    if income == 'All':
        input_df = input_df
    else:
        input_df = input_df.loc[(input_df['incomegroup'] == income)]

    # Filter Region & country
    if region == "All":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in country_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "Sub-Saharan Africa":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_africa_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "East Asia & Pacific":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_eap_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "Europe & Central Asia":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_eca_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "Latin America & the Caribbean":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_lac_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "Middle East & North Africa":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_mena_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    elif region == "North America":
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_na_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]
    else:
         if country == 'All':
             selected = [[v for k,v in d.items()] for d in wb_southasia_options_ga]
             selected = [a[1] for a in selected]
             input_df = input_df[input_df['country'].isin(selected)]
         else:
             input_df=input_df.loc[(input_df['country'] == country)]

    # Fill in for missing values AHLE
    # input_df['ahle_total_2010usd'] = input_df['ahle_total_2010usd'].fillna(0)

    # Format numbers
    input_df.update(input_df[['biomass',
                              'population',
                              'liveweight',
                               # 'ahle_total_2010usd',
                              ]].applymap('{:,.0f}'.format))

    columns_to_display_with_labels = {
       'country':'Country'
       ,'species':'Species'
       ,'year':'Year'
       ,'incomegroup': 'Income Group'
       # ,'ahle_total_2010usd': 'Total AHLE (2010 USD)'
       ,'biomass':'Biomass (kg)'
       ,'population':'Population (head)'
       ,'liveweight':'Average Live Weight (kg)'
    }

    # Subset columns
    input_df = input_df[list(columns_to_display_with_labels)]

    # Hover-over text
    column_tooltips = {
       'incomegroup':'Source: World Bank via GBADs knowledge engine'
       # ,'ahle_total_2010usd': ')'
       ,'biomass':'Source: FAO via GBADs knowledge engine'
       ,'population':'Source: FAO via GBADs knowledge engine'
       ,'liveweight':'Source: FAO via GBADs knowledge engine'
    }
    return [
            html.H4("Global Aggregation Data"),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                fixed_rows={'headers': True, 'data': 0},
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '680px',
                              'overflowY': 'auto'},
                page_action='none',

                # Hover-over for column headers
                tooltip_header=column_tooltips,
                tooltip_delay= 500,
                tooltip_duration=50000,

                # Underline columns with tooltips
                style_header_conditional=[{
                    'if': {'column_id': col},
                    'textDecoration': 'underline',
                    'textDecorationStyle': 'dotted',
                    } for col in list(column_tooltips)],
            )
        ]

@gbadsDash.callback(
    Output('ga-detailtab-displaytable', 'children'),
    Input('select-region-detail-ga','value'),
    Input('select-incomegrp-detail-ga','value'),
    Input('select-country-detail-ga','value'),
    Input('amu-regional-data', 'data'),
    )
def update_detail_table_ga(
        selected_region
        ,selected_incgrp
        ,selected_country
        ,amu_data_json
    ):
    # Read data
    input_df = ga_countries_biomass.copy()
    input_df_amu = pd.read_json(amu_data_json, orient='split')

    # Add mortality, morbidity, and vetmed rate columns
    input_df = ga.add_mortality_rate(input_df)
    input_df = ga.add_morbidity_rate(input_df)
    input_df = ga.add_vetmed_rates(input_df)
    input_df = ga.add_antimicrobial_expenditure(input_df ,input_df_amu)

    # Apply AHLE calcs
    input_df = ga.ahle_calcs_adj_outputs(input_df)

    # Apply filters
    input_df_filtered = input_df

    # Region, Country and Income group might not be filtered
    if selected_region == 'All':
        if selected_country == 'All':
            input_df_filtered = input_df_filtered
            # print_selected_country = 'All countries, '
            print_selected_country = 'Global, '

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                input_df_filtered = input_df_filtered
                print_selected_incgrp = 'all income groups, '
            else:
                input_df_filtered = input_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}, '
        else:
            input_df_filtered = input_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country}'
            print_selected_incgrp = ''
    else:
        if selected_country == 'All':
            input_df_filtered = input_df_filtered.query(f"region_label == '{selected_region}'")
            print_selected_country = f'All {selected_region} countries,'

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                input_df_filtered = input_df_filtered
                print_selected_incgrp = 'all income groups, '
            else:
                input_df_filtered = input_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}, '
        else:
            input_df_filtered = input_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country}'
            print_selected_incgrp = ''

    columns_to_display_with_labels = {
        'region':'Region'
        ,'incomegroup':'Income group'
        ,'country':'Country'
        ,'species':'Species'
        ,'year':'Year'
        ,'population':'Population (head)'
        ,'liveweight':'Average liveweight (kg)'
        ,'biomass':'Biomass of standing stock (kg)'
        ,'biomass_popandslaughter_kg':'Biomass of standing stock and slaughter head (kg)'

        ,'production_eggs_tonnes':'Egg production (tonnes)'
        ,'production_meat_tonnes':'Meat production (tonnes)'
        ,'production_milk_tonnes':'Milk production (tonnes)'
        ,'production_wool_tonnes':'Wool production (tonnes)'

        ,'producer_price_meat_live_usdpertonne_cnst2010':'Liveweight price (USD per tonne)'
        ,'producer_price_eggs_usdpertonne_cnst2010':'Egg price (USD per tonne)'
        ,'producer_price_meat_usdpertonne_cnst2010':'Meat price (USD per tonne)'
        ,'producer_price_milk_usdpertonne_cnst2010':'Milk price (USD per tonne)'
        ,'producer_price_wool_usdpertonne_cnst2010':'Wool price (USD per tonne)'

        ,'biomass_value_2010usd':'Value of biomass (USD)'
        ,'output_value_eggs_2010usd':'Value of Egg production (USD)'
        ,'output_value_meat_2010usd':'Value of Meat production (USD)'
        ,'output_value_milk_2010usd':'Value of Milk production (USD)'
        ,'output_value_wool_2010usd':'Value of Wool production (USD)'

        ,'mortality_rate':'Mortality rate'
        ,'morbidity_rate':'Morbidity rate'

        ,'ideal_biomass_value_2010usd':'Value of ideal biomass (USD)'
        ,'ideal_output_value_eggs_2010usd':'Value of ideal egg production (USD)'
        ,'ideal_output_value_meat_2010usd':'Value of ideal meat production (USD)'
        ,'ideal_output_value_milk_2010usd':'Value of ideal milk production (USD)'
        ,'ideal_output_value_wool_2010usd':'Value of ideal wool production (USD)'

        ,'vetspend_biomass_farm_usdperkgbm':'Producers vet & med cost per kg biomass (USD)'
        # ,'vetspend_biomass_public_usdperkgbm':'Public vet & med cost per kg biomass (USD)'
        ,'vetspend_production_usdperkgprod':'Producers vet & med cost per kg production (USD)'
        ,'vetspend_farm_usd':'Total producers vet & med cost (USD)'
        # ,'vetspend_public_usd':'Total public vet & med cost (USD)'
        ,'antimicrobial_expenditure_usd':'Total expenditure on antimicrobials (USD)'

        ,'ahle_dueto_reducedoutput_2010usd':'Value of AHLE due to reduced output (USD)'
        ,'ahle_dueto_vetandmedcost_2010usd':'Value of AHLE due to vet & med cost (USD)'
        # ,'ahle_total_2010usd':'Total value of AHLE (USD)'
    }
    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places without comma
    input_df_filtered.update(input_df_filtered[[
        'year'
    ]].applymap('{:.0f}'.format))

    # Zero decimal places
    input_df_filtered.update(input_df_filtered[[
        'population'
        ,'biomass'
        ,'production_eggs_tonnes'
        ,'production_meat_tonnes'
        ,'production_milk_tonnes'
        ,'production_wool_tonnes'
    ]].applymap('{:,.0f}'.format))

    # One decimal place
    input_df_filtered.update(input_df_filtered[[
        'liveweight'
    ]].applymap('{:,.1f}'.format))

    # Two decimal places
    input_df_filtered.update(input_df_filtered[[
        'mortality_rate'
        ,'morbidity_rate'
    ]].applymap('{:,.2f}'.format))

    # Dollars
    input_df_filtered.update(input_df_filtered[[
        # 'producer_price_meat_live_usdpertonne_cnst2010'
        # ,'producer_price_eggs_usdpertonne_cnst2010'
        # ,'producer_price_meat_usdpertonne_cnst2010'
        # ,'producer_price_milk_usdpertonne_cnst2010'
        # ,'producer_price_wool_usdpertonne_cnst2010'

        'biomass_value_2010usd'
        ,'output_value_eggs_2010usd'
        ,'output_value_meat_2010usd'
        ,'output_value_milk_2010usd'
        ,'output_value_wool_2010usd'

        ,'ideal_biomass_value_2010usd'
        ,'ideal_output_value_eggs_2010usd'
        ,'ideal_output_value_meat_2010usd'
        ,'ideal_output_value_milk_2010usd'
        ,'ideal_output_value_wool_2010usd'

        ,'vetspend_biomass_farm_usdperkgbm'
        ,'vetspend_biomass_public_usdperkgbm'
        ,'vetspend_production_usdperkgprod'
        ,'vetspend_farm_usd'
        # ,'vetspend_public_usd'
        ,'antimicrobial_expenditure_usd'

        ,'ahle_dueto_reducedoutput_2010usd'
        ,'ahle_dueto_vetandmedcost_2010usd'
        # ,'ahle_total_2010usd'
    ]].applymap('${:,.2f}'.format))

    # ------------------------------------------------------------------------------
    # Hover-over text
    # ------------------------------------------------------------------------------
    column_tooltips = {
        'region':'World Bank region'
        ,'incomegroup':'World Bank income group'
        ,'population':'Source: FAO'
        ,'liveweight':'Source: FAO'

        ,'production_eggs_tonnes':'Source: FAO'
        ,'production_meat_tonnes':'Source: FAO'
        ,'production_milk_tonnes':'Source: FAO'
        ,'production_wool_tonnes':'Source: FAO'

        ,'producer_price_meat_live_usdpertonne_cnst2010':'Constant 2010 US dollars. Source: FAO'
        ,'producer_price_eggs_usdpertonne_cnst2010':'Constant 2010 US dollars. Source: FAO'
        ,'producer_price_meat_usdpertonne_cnst2010':'Constant 2010 US dollars. Source: FAO'
        ,'producer_price_milk_usdpertonne_cnst2010':'Constant 2010 US dollars. Source: FAO'
        ,'producer_price_wool_usdpertonne_cnst2010':'Constant 2010 US dollars. Source: FAO'

        ,'biomass_value_2010usd':'Constant 2010 US dollars'
        ,'output_value_eggs_2010usd':'Constant 2010 US dollars'
        ,'output_value_meat_2010usd':'Constant 2010 US dollars'
        ,'output_value_milk_2010usd':'Constant 2010 US dollars'
        ,'output_value_wool_2010usd':'Constant 2010 US dollars'

        # ,'mortality_rate':''
        # ,'morbidity_rate':''

        ,'ideal_biomass_value_2010usd':'Constant 2010 US dollars'
        ,'ideal_output_value_eggs_2010usd':'Constant 2010 US dollars'
        ,'ideal_output_value_meat_2010usd':'Constant 2010 US dollars'
        ,'ideal_output_value_milk_2010usd':'Constant 2010 US dollars'
        ,'ideal_output_value_wool_2010usd':'Constant 2010 US dollars'

        # ,'vetspend_biomass_farm_usdperkgbm':''
        # ,'vetspend_biomass_public_usdperkgbm':''
        # ,'vetspend_production_usdperkgprod':''
        # ,'vetspend_farm_usd':''
        # ,'vetspend_public_usd':''

        ,'ahle_dueto_reducedoutput_2010usd':'Constant 2010 US dollars'
        ,'ahle_dueto_vetandmedcost_2010usd':'Constant 2010 US dollars'
        # ,'ahle_total_2010usd':'Constant 2010 US dollars'
    }

    # !!!- Adjust header size based on the column name length
    # # custom width for each column as a workaround for this issue:
    # long_column_names = [{"if": {"column_id": column}, "min-width": "300px"} for column in df.columns if len(column) >= 30]
    # med_column_names = [{"if": {"column_id": column}, "min-width": "225px"} for column in df.columns if (len(column) > 15 and len(column)) < 30]
    # small_column_names = [{"if": {"column_id": column}, "min-width": "100px"} for column in df.columns if len(column) <= 15]

    # adjusted_columns = long_column_names + med_column_names + small_column_names
    return [
        html.H4(f"Detailed data for {print_selected_country}{print_selected_incgrp}"),
        dash_table.DataTable(
            columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
            fixed_rows={'headers': True, 'data': 0},
            data=input_df_filtered.to_dict('records'),
            export_format="csv",
            sort_action = 'native',
            style_cell={'font-family':'sans-serif',
                        'minWidth':200},
            style_table={'overflowX': 'scroll',
                         'height': '680px',
                         'overflowY': 'auto'
                          },

            # Hover-over for column headers
            tooltip_header=column_tooltips,
            tooltip_delay= 500,
            tooltip_duration=50000,

            # Underline columns with tooltips
            style_header_conditional=[{
                'if': {'column_id': col},
                'textDecoration': 'underline',
                'textDecorationStyle': 'dotted',
                } for col in list(column_tooltips)],
        )
    ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# Biomass Map
@gbadsDash.callback(
    Output('ga-map-or-line-select','figure'),
    Input('viz-radio-ga','value'),
    Input('select-species-ga','value'),
    Input('select-country-overview-ga', 'value'),
    Input('select-region-overview-ga', 'value'),
    Input('map-display-radio-ga','value'),
    Input('select-incomegrp-overview-ga','value'),
    # Input('select-currency-ecs','value'),
    Input('amu-regional-data', 'data'),
   )
def update_bio_ahle_visual_ga(
        viz_selection
        ,species
        ,country
        ,region
        ,display
        ,income
        ,amu_data_json
    ):
   # Data
   input_df = ga_countries_biomass.copy()
   input_df_amu = pd.read_json(amu_data_json, orient='split')

   # Add mortality, morbidity, and vetmed rate columns
   input_df = ga.add_mortality_rate(input_df)
   input_df = ga.add_morbidity_rate(input_df)
   input_df = ga.add_vetmed_rates(input_df)
   input_df = ga.add_antimicrobial_expenditure(input_df ,input_df_amu)

   # Apply AHLE calcs
   input_df = ga.ahle_calcs_adj_outputs(input_df)

   # Filter Region & country
   if region == "All":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in country_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "Sub-Saharan Africa":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_africa_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "East Asia & Pacific":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_eap_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "Europe & Central Asia":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_eca_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "Latin America & the Caribbean":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_lac_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "Middle East & North Africa":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_mena_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   elif region == "North America":
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_na_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]
   else:
        if country == 'All':
            selected = [[v for k,v in d.items()] for d in wb_southasia_options_ga]
            selected = [a[1] for a in selected]
            input_df = input_df[input_df['country'].isin(selected)]
        else:
            input_df=input_df.loc[(input_df['country'] == country)]

    # Filter Income Group
   if income == 'All':
        input_df = input_df
   else:
        input_df = input_df.loc[(input_df['incomegroup'] == income)]

    # Filter Species
   input_df = input_df.loc[(input_df['species'] == species)]


   if viz_selection == 'Map':
       # Set values from the data
       iso_alpha3 = input_df['country_iso3']
       country_col = input_df['country']
       year = input_df['year']

       # Establish AHLE
       input_df['ahle_total_2010usd'] = input_df['ahle_total_2010usd'].fillna(0)


       # Set value based on map display option
       if display == 'Biomass':
           display_title = 'Biomass (kg)'
           value = input_df['biomass']
       elif display == 'Live Weight':
           display_title = 'Average Live Weight (kg)'
           value = input_df['liveweight']
       elif display == 'Population':
           display_title = 'Population (head)'
           value = input_df['population']
       elif display == 'Animal Health Loss Envelope (AHLE)':
           display_title = 'AHLE (2010 USD)'
           value = input_df['ahle_total_2010usd']
       else:
           display = 'AHLE per kg biomass'
           display_title = 'AHLE (USD per kg biomass)'
           value = input_df['ahle_2010usd_perkgbm']

       # Set up map structure
       ga_biomass_ahle_visual = create_biomass_map_ga(input_df, iso_alpha3, value, country_col, display_title)

       # Add title
       if region == 'All':
           if country =='All':
               ga_biomass_ahle_visual.update_layout(title_text=f'Global {display_title} for {species}',
                                             font_size=15,
                                             margin=dict(t=100))
           else:
               ga_biomass_ahle_visual.update_layout(title_text=f'{country} {display_title} for {species}',
                                             font_size=15,
                                             margin=dict(t=100))
               ga_biomass_ahle_visual.update_coloraxes(showscale=False)
       else:
             if country =='All':
                 ga_biomass_ahle_visual.update_layout(title_text=f'{region} {display_title} for {species}',
                                               font_size=15,
                                               margin=dict(t=100))
             else:
                 ga_biomass_ahle_visual.update_layout(title_text=f'{country} {display_title} for {species}',
                                               font_size=15,
                                               margin=dict(t=100))
                 ga_biomass_ahle_visual.update_coloraxes(showscale=False)

   elif viz_selection == 'Line chart':
       # Specify which columns to keep forline chart
       input_df = input_df[['country', 'year', 'species', 'biomass', 'population', 'liveweight']]

       # Melt data to create facets for line chart
       input_df = input_df.melt(id_vars=['country', 'year', 'species'],
                                value_vars=['biomass', 'population', 'liveweight'],
                                var_name='facet',
                                value_name='value')

       # Set values from the data
       year = input_df['year']
       value = input_df['value']
       country = input_df['country']
       facet = input_df['facet']

       # Set up line plot structure
       ga_biomass_ahle_visual = create_line_chart_ga(input_df, year, value, country, facet)

   return ga_biomass_ahle_visual

# Global AHLE Waterfall
@gbadsDash.callback(
    Output('ga-ahle-waterfall','figure'),
    Input('amu-regional-data', 'data'),
    Input('select-region-detail-ga','value'),
    Input('select-incomegrp-detail-ga','value'),
    Input('select-country-detail-ga','value'),
    Input('select-year-ga','value'),
    Input('select-display-ga','value'),
    )
def update_ahle_waterfall_ga(
        amu_data_json
        ,selected_region
        ,selected_incgrp
        ,selected_country
        ,selected_year
        ,display
    ):
    # Read data
    input_df = ga_countries_biomass.copy()
    input_df_amu = pd.read_json(amu_data_json, orient='split')

    # Add mortality, morbidity, and vetmed rate columns
    input_df = ga.add_mortality_rate(input_df)
    input_df = ga.add_morbidity_rate(input_df)
    input_df = ga.add_vetmed_rates(input_df)
    input_df = ga.add_antimicrobial_expenditure(input_df ,input_df_amu)

    # Apply AHLE calcs
    input_df = ga.ahle_calcs_adj_outputs(input_df)

    # Prep the data
    prep_df = prep_ahle_forwaterfall_ga(input_df)

    # Make costs negative
    _vetmed_rows = (prep_df['item'].str.contains('COSTS' ,case=False ,na=False)\
                    | prep_df['item'].str.contains('EXPENDITURE' ,case=False ,na=False))
    prep_df.loc[_vetmed_rows ,'value_usd_current'] = -1 * prep_df.loc[_vetmed_rows ,'value_usd_current']

    # Apply user filters
    # There will always be a year filter
    prep_df_filtered = prep_df.query(f"year == {selected_year}")

    # Region, Country and Income group might not be filtered
    if selected_region == 'All':
        if selected_country == 'All':
            prep_df_filtered = prep_df_filtered
            # print_selected_country = 'All countries, '
            print_selected_country = 'Global, '

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                prep_df_filtered = prep_df_filtered
                print_selected_incgrp = 'all income groups, '
            else:
                prep_df_filtered = prep_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}, '
        else:
            prep_df_filtered = prep_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country} '
            print_selected_incgrp = ''
    else:
        if selected_country == 'All':
            prep_df_filtered = prep_df_filtered.query(f"region_label == '{selected_region}'")
            print_selected_country = f'All {selected_region} countries,'

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                prep_df_filtered = prep_df_filtered
                print_selected_incgrp = 'all income groups, '
            else:
                prep_df_filtered = prep_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}, '
        else:
            prep_df_filtered = prep_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country} '
            print_selected_incgrp = ''

    # Get sum for each item (summing over countries if multiple)
    prep_df_sums = prep_df_filtered.groupby('item')[['value_usd_current' ,'value_usd_ideal']].sum().reset_index()

    # Create AHLE differences bars (ideal - current)
    prep_df_sums['value_usd_ahle_diff'] = prep_df_sums['value_usd_ideal'] - prep_df_sums['value_usd_current']

    # Get total AHLE for printing
    total_ahle = prep_df_sums.query("item.str.upper() == 'NET VALUE'")['value_usd_ahle_diff'].values[0]

    if display =='Side by Side':
        # Create graph with current values
        name = 'Current'
        measure = ["relative", "relative", "relative", "relative", "relative", "relative", "relative", "total"]
        x = prep_df_sums['item']
        y = prep_df_sums['value_usd_current']
        ga_waterfall_fig = create_ahle_waterfall_ga(prep_df_sums, name, measure, x, y)

        # Add ideal values side-by-side
        ga_waterfall_fig.add_trace(go.Waterfall(
            name = 'Ideal',
            measure = measure,
            x = x,
            y = prep_df_sums['value_usd_ideal'],
            decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
            increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
            totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
            connector = {"line":{"dash":"dot"}},
            ))
        ga_waterfall_fig.update_layout(
            waterfallgroupgap = 0.5,    # Gap between bars
            )

        ga_waterfall_fig.update_layout(title_text=f'Compare Current values and costs | {print_selected_country}{print_selected_incgrp}{selected_year}<br><sup>Total animal health loss envelope: ${total_ahle :,.0f} in constant 2010 US dollars</sup><br>',
                                        yaxis_title='US Dollars (2010 constant)',
                                        font_size=15)
    else:
        # Create graph with differences
        name = 'AHLE'
        measure = ["relative", "relative", "relative", "relative", "relative", "relative", "relative", "total"]
        x = prep_df_sums['item']
        y = prep_df_sums['value_usd_ahle_diff']
        ga_waterfall_fig = create_ahle_waterfall_ga(prep_df_sums, name, measure, x, y)

        ga_waterfall_fig.update_layout(title_text=f'Ideal minus current values and costs | {print_selected_country}{print_selected_incgrp}{selected_year}<br><sup>Total animal health loss envelope: ${total_ahle :,.0f} in constant 2010 US dollars</sup><br>',
                                        yaxis_title='US Dollars (2010 constant)',
                                        font_size=15)

    return ga_waterfall_fig

# Global AHLE plot over time
@gbadsDash.callback(
    Output('ga-ahle-over-time','figure'),
    Input('select-region-detail-ga','value'),
    Input('select-incomegrp-detail-ga','value'),
    Input('select-country-detail-ga','value'),
    Input('select-item-ga','value'),
    Input('select-display-ga','value'),
    Input('amu-regional-data', 'data'),
    )
def update_ahle_lineplot_ga(
        selected_region
        ,selected_incgrp
        ,selected_country
        ,selected_item
        ,display
        ,amu_data_json
    ):
    # Read data
    input_df = ga_countries_biomass.copy()
    input_df_amu = pd.read_json(amu_data_json, orient='split')

    # Add mortality, morbidity, and vetmed rate columns
    input_df = ga.add_mortality_rate(input_df)
    input_df = ga.add_morbidity_rate(input_df)
    input_df = ga.add_vetmed_rates(input_df)
    input_df = ga.add_antimicrobial_expenditure(input_df ,input_df_amu)

    # Apply AHLE calcs
    input_df = ga.ahle_calcs_adj_outputs(input_df)

    # Prep the data
    # Initial data prep is same as waterfall!
    prep_df = prep_ahle_forwaterfall_ga(input_df)

    # Apply user filters
    # There will always be an item filter
    prep_df_filtered = prep_df.query(f"item == '{selected_item}'")
    if selected_item == 'Net value':
        print_selected_item = f'{selected_item} over time'
    else:
        print_selected_item = f'value of {selected_item} over time'

    # Region, Country and Income group might not be filtered
    if selected_region == 'All':
        if selected_country == 'All':
            prep_df_filtered = prep_df_filtered
            print_selected_country = 'Global, '

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                prep_df_filtered = prep_df_filtered
                print_selected_incgrp = 'all income groups'
            else:
                prep_df_filtered = prep_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}'
        else:
            prep_df_filtered = prep_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country}'
            print_selected_incgrp = ''
    else:
        if selected_country == 'All':
            prep_df_filtered = prep_df_filtered.query(f"region_label == '{selected_region}'")
            print_selected_country = f'All {selected_region} countries, '

            # Only need to filter income groups if no country selected
            if selected_incgrp == 'All':
                prep_df_filtered = prep_df_filtered
                print_selected_incgrp = 'all income groups'
            else:
                prep_df_filtered = prep_df_filtered.query(f"incomegroup == '{selected_incgrp}'")
                print_selected_incgrp = f'income group {selected_incgrp}'
        else:
            prep_df_filtered = prep_df_filtered.query(f"country == '{selected_country}'")
            print_selected_country = f'{selected_country}'
            print_selected_incgrp = ''

    # Create AHLE (difference) value
    prep_df_filtered['value_usd_ahle_diff'] = prep_df_filtered['value_usd_ideal'] - prep_df_filtered['value_usd_current']

    # Get sum for each year
    prep_df_sums = prep_df_filtered.groupby('year')[['value_usd_current' ,'value_usd_ideal', 'value_usd_ahle_diff']].sum()
    prep_df_sums = prep_df_sums.reset_index()


    if display == "Side by Side":
        # Plot current value
        plot_current_value = go.Scatter(
            x=prep_df_sums['year']
            ,y=prep_df_sums['value_usd_current']
            ,name='Current'
            ,line=dict(color='#0028CA')
            )
        # Overlay ideal value
        plot_ideal_value = go.Scatter(
            x=prep_df_sums['year']
            ,y=prep_df_sums['value_usd_ideal']
            ,name='Ideal'
            ,line=dict(color='#00CA0F')
            )

        ga_lineplot_fig = make_subplots()
        ga_lineplot_fig.add_trace(plot_ideal_value)
        ga_lineplot_fig.add_trace(plot_current_value)
        ga_lineplot_fig.update_layout(title_text=f'Current & ideal {print_selected_item} | {print_selected_country}{print_selected_incgrp}<br><sup></sup><br>',
                                      yaxis_title='US Dollars (2010 constant)',
                                      font_size=15,
                                      plot_bgcolor="#ededed",)

    else:
        # Change line color based on if AHLE or cost is selected
        costs = "costs"
        if selected_item == 'Net value':
            # Plot AHLE value
            plot_ahle_value = go.Scatter(
                x=prep_df_sums['year']
                ,y=prep_df_sums['value_usd_ahle_diff']
                ,name=f'{display}'
                ,line=dict(color='#F7931D')
                )
        elif costs in selected_item:
            # Plot AHLE value
            plot_ahle_value = go.Scatter(
                x=prep_df_sums['year']
                ,y=prep_df_sums['value_usd_ahle_diff']
                ,name=f'{display}'
                ,line=dict(color='#E84C3D')
                )
        else:
            # Plot AHLE value
            plot_ahle_value = go.Scatter(
                x=prep_df_sums['year']
                ,y=prep_df_sums['value_usd_ahle_diff']
                ,name=f'{display}'
                ,line=dict(color='#3598DB')
                )

        ga_lineplot_fig = make_subplots()
        ga_lineplot_fig.add_trace(plot_ahle_value)
        ga_lineplot_fig.update_layout(title_text=f'Ideal minus current {print_selected_item} | {print_selected_country}{print_selected_incgrp}<br><sup></sup><br>',
                                      yaxis_title='US Dollars (2010 constant)',
                                      font_size=15,
                                      plot_bgcolor="#ededed",)


    return ga_lineplot_fig


# ==============================================================================
#### UPDATE ETHIOPIA
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
# Update production system options based on species
@gbadsDash.callback(
    Output('select-prodsys-ecs', 'options'),
    Output('select-prodsys-ecs', 'value'),
    Input('select-species-ecs', 'value'),
    )
def update_prodsys_options_ecs(species):
    # Get unique production systems for selected species
    unique_prodsys = np.sort(ecs_ahle_summary.loc[ecs_ahle_summary['species'] == species ,'production_system'].unique())
    options = [{'label': i, 'value': i} for i in unique_prodsys]
    value = options[0]['value']  # Default is first one
    return options, value

# Longitudinal options
@gbadsDash.callback(
    Output('select-graph-ahle-ecs','options'),
    Output('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_longitudinal_options_ecs(species):
    options = [
        {'label': "Single Year", 'value': "Single Year", 'disabled': False},
        {'label': "Over Time", 'value': "Over Time", 'disabled': False}
        ]
    value='Single Year'

    # Disable option if species doesn't support it
    # if species.upper() != 'CATTLE':
    #     for d in options:
    #         d['disabled']=True
    return options, value

# Year selector
@gbadsDash.callback(
    Output('select-year-ecs','options'),
    Output('select-year-ecs','value'),
    Output('select-year-ecs','placeholder'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_year_select_ecs(graph, species):
    value=2021
    ecs_year_options=[]     # By default, list is blank
    placeholder = '2021'

    if graph == 'Over Time':   # Over time placeholder is (all)
        placeholder = '(all)'
    # Other years only available for Cattle
    # elif (graph == 'Single Year') & (species.upper() == 'CATTLE'):
    #     ecs_year_options=[]
    #     for i in np.sort(ecs_ahle_summary['year'].unique()):
    #         str(ecs_year_options.append({'label':i,'value':(i)}))
    # Have placeholder values for all species and years
    elif graph == 'Single Year':
        ecs_year_options=[]
        for i in np.sort(ecs_ahle_summary['year'].unique()):
            str(ecs_year_options.append({'label':i,'value':(i)}))
    else:
        None

    return ecs_year_options, value, placeholder

# Geographical options
@gbadsDash.callback(
    Output('select-geo-view-ecs','options'),
    Output('select-geo-view-ecs','value'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-year-ecs', 'value'),
    )
def update_geo_view_options_ecs(graph, species, year):
    options = [
        {'label': "National", 'value': "National", 'disabled': False},
        {'label': "Subnational", 'value': "Subnational", 'disabled': True}  # Update Aug 2023: disabling subnational views as these scenarios are incomplete and cause missing values in attribution
        ]
    value='National'

    # Disable controls if Over Time selected
    if graph.upper() == 'OVER TIME':
        for d in options:
            d['disabled']=True

    # Disable if any year outside 2021 is selected
    if year != 2021:
        for d in options:
            d['disabled']=True

    # Disable if any species other than cattle is selected
    if species.upper() != 'CATTLE':
        for d in options:
            d['disabled']=True
    return options, value

# Update agesex group options based on species
@gbadsDash.callback(
    Output('select-agesex-ecs', 'options'),
    Input('select-species-ecs', 'value'),
    )
def update_age_options_ecs(species):
    if species == "Cattle":
        options = ecs_agesex_options
    else:
        options = ecs_agesex_options.copy()
        for d in options:
            if d['value'] == 'Oxen':
                options.remove(d)
    return options

# Remove improvement option from scenario for cattle and poultry while those are misssing
# August 2023: updated scenarios do not include zero mortality or improvement
# @gbadsDash.callback(
#     Output('select-compare-ecs', 'options'),
#     Input('select-species-ecs', 'value'),
#     )
# def update_compare_options_ecs(species):
#     if species == "Cattle" or species == 'All Poultry' or species == 'Poultry hybrid' or species == 'Poultry indigenous':
#         options = ecs_compare_options.copy()
#         for d in options:
#             if d['value'] == 'Improvement':
#                 options.remove(d)
#     else:
#         options = ecs_compare_options
#     return options

# Update hierarchy dropdown filters to remove higher level selections from the options
# And change if displaying stacked bar
@gbadsDash.callback(
    Output('select-top-lvl-attr-ecs-title','children'),
    Input('select-graph-ahle-ecs','value'),
    )
def update_year_item_switch(graph):
    if graph == 'Single Year':
        title = 'Top Level'
    else:
        title = 'Segmentation'
    return title

@gbadsDash.callback(
    Output('select-dd-1-attr-ecs','options'),
    Output('select-dd-1-attr-ecs','value'),
    Output('select-dd-1-attr-ecs','style'),
    Output('select-dd-1-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    )
def update_dd1_options_ecs(graph, top_lvl_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] == top_lvl_hierarchy:
                d['disabled']=True
            else:
                d['disabled']=False
        display_style = {'display': 'block'}

    value='production_system'

    return options, value, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-2-attr-ecs','options'),
    Output('select-dd-2-attr-ecs','style'),
    Output('select-dd-2-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    )
def update_dd2_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-3-attr-ecs','options'),
    Output('select-dd-3-attr-ecs','style'),
    Output('select-dd-3-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    )
def update_dd3_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-4-attr-ecs','options'),
    Output('select-dd-4-attr-ecs','style'),
    Output('select-dd-4-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    Input('select-dd-3-attr-ecs','value'),
    )
def update_dd4_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy, dd3_hierarchy):
    options = ecs_hierarchy_dd_attr_options
    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy or d['value'] == dd3_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

# @gbadsDash.callback(
#     Output('select-dd-5-attr-ecs','options'),
#     Input('select-top-lvl-attr-ecs','value'),
#     Input('select-dd-1-attr-ecs','value'),
#     Input('select-dd-2-attr-ecs','value'),
#     Input('select-dd-3-attr-ecs','value'),
#     Input('select-dd-4-attr-ecs','value'),
#     )
# def update_dd5_options_ecs(top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy, dd3_hierarchy, dd4_hierarchy):
#     options = ecs_hierarchy_dd_attr_options
#     for d in options:
#         if d['value'] != 'None':
#             if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy or d['value'] == dd3_hierarchy or d['value'] == dd4_hierarchy:
#                 d['disabled']= True
#             else:
#                 d['disabled']=False
#     return options

@gbadsDash.callback(
    Output('select-region-ecs','style'),
    Output('select-region-ecs-title','style'),
    Output('select-region-ecs','value'),
    Output('select-region-ecs','options'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-geo-view-ecs','value'),
    )
def update_ahle_graph_controls(graph, geo_view):
    options2 = ecs_region_options.copy()

    for d in options2:
        if graph == 'Over Time':
            block = {'display': 'none'} # hide
            value = ''
            d['disabled']=True

        else:
            block = {'display': 'block'}
            if geo_view == 'National':
                value = ''
                d['disabled']=True
            else:
                value='Afar'
                d['disabled']=False

    return block, block, value, options2

# Show Item select when display is over time
@gbadsDash.callback(
    Output('select-item-ecs','options'),
    Output('select-item-ecs','style'),
    Output('select-item-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_item_dropdown_ecs(graph, species):
    # Filters Items to display based on species selected
    if species == "Cattle":     # Cattle have draught
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Draught',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Eggs consumed',
                        'Value of Eggs sold',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    else:
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    # Build dictionary
    options=[]
    for i in item_options:
        str(options.append({'label':i,'value':(i)}))
    display_style = {'display': 'block'}

    # Hide controls if Single Year selected
    if graph == 'Single Year':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    return options, display_style, display_style

# Enable the options for factor/improvement when 'Improvement' selected
@gbadsDash.callback(
    Output('select-factor-ecs','options'),
    Output('select-factor-ecs','style'),
    Output('select-factor-ecs-title','style'),
    Output('select-improve-ecs','options'),
    Output('select-improve-ecs','style'),
    Output('select-improve-ecs-title','style'),
    Input('select-compare-ecs','value'),
    )
def update_improvment_factors(compare):
    options1 = ecs_factor_options.copy()
    options2 = ecs_improve_options.copy()
    for d in options1:
        if compare == 'Improvement':
            block = {'display': 'block'}
            if d['value'] != 'Lactation':
                d['disabled']=False
        else:
            block = {'display': 'none'} # hide the improvement options
            d['disabled']=True
    for d in options2:
        if compare == 'Improvement':
            block = {'display': 'block'}
            d['disabled']=False
        else:
            block = {'display': 'none'} # hide the improvement options
            d['disabled']=True

    return options1, block, block, options2, block, block

# Display Item values for map display based on selections
@gbadsDash.callback(
    Output('select-map-display-ecs','options'),
    Input('select-species-ecs','value'),
    )
def update_map_display_options_ecs(species):
    # Filters Items to display based on species selected
    if 'CATTLE' in species.upper():    # Cattle have draught
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of draught',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        )
    elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Eggs consumed',
                        'Value of Eggs sold',
                        )
    else:
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        )
    # Build dictionary
    options=[]

    # Add options for AHLE and gross margin
    options += [{'label': i, 'value': i, 'disabled': False} for i in [
        "Animal Health Loss Envelope",
        "Ideal Gross Margin",
        ]]
    options += [{'label':"Current Gross Margin", 'value':"Gross Margin"}]

    # Add options for values using species-specific list from above
    for i in item_options:
        str(options.append({'label':'Current ' + i,'value':(i)}))

    # Add Expenditure values
    options += [{'label':"Current Expenditure on Feed", 'value':"Feed Cost"},
                {'label':"Current Expenditure on Labour", 'value':"Labour Cost"},
                {'label':"Current Expenditure on Health", 'value':"Health Cost"},
                # May 2023: Wudu does not want housing and captial expenses in waterfall chart or map
                # {'label':"Current Expenditure on Housing", 'value':"Infrastructure Cost"},
                # {'label':"Current Expenditure on Capital", 'value':"Capital Cost"},
                ]

    return options

# Hide waterfall specific footnote when waterfall is not showing
@gbadsDash.callback(
    Output('waterfall-footnote-ecs','style'),
    Input('select-graph-ahle-ecs','value'),
    )
def update_footnote(graph):
    if graph.upper() == 'SINGLE YEAR':
        block = {'display': 'block'}
    else:
        block = {'display': 'none'} # hide

    return block

# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# AHLE datatable below graphic
@gbadsDash.callback(
    Output('ecs-ahle-datatable', 'children'),
    Input('select-currency-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-agesex-ecs', 'value'),
)
def update_ecs_ahle_data(currency, species, prodsys, agesex):
    # Read in data and apply filters
    input_df = ecs_ahle_summary.copy()

    # Species filter
    input_df = input_df.loc[(input_df['species'] == species)]

    # Production System filter
    # Rename values to match filters
    input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})
    input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Age/sex filter
    input_df=input_df.loc[(input_df['group'] == agesex)]

    # If currency is USD, use USD columns
    display_currency = 'Birr'
    if currency == 'USD':
        display_currency = 'USD'

        input_df['mean_current'] = input_df['mean_current_usd']
        input_df['stdev_current'] = input_df['stdev_current_usd']
        # input_df['mean_mortality_zero'] = input_df['mean_mortality_zero_usd']
        # input_df['stdev_mortality_zero'] = input_df['stdev_mortality_zero_usd']
        input_df['mean_ideal'] = input_df['mean_ideal_usd']
        input_df['stdev_ideal'] = input_df['stdev_ideal_usd']

    # Format numbers
    input_df.update(input_df[['mean_current',
                              'mean_ideal',
                              # 'mean_mortality_zero',
                              'mean_diff_ideal',
                              # 'mean_diff_mortzero',
                              ]].applymap('{:,.0f}'.format))

    columns_to_display_with_labels = {
        'species':'Species'
        ,'production_system':'Production System'
        ,'region':'Region'
        ,'year':'Year'
        ,'item':'Value or Cost'
        ,'group':'Group'
        ,'mean_current':f'Current Mean ({display_currency})'
        ,'mean_ideal':f'Ideal Mean ({display_currency})'
        # ,'mean_mortality_zero':f'Mortality Zero Mean ({display_currency})'
        ,'mean_diff_ideal':'AHLE (Ideal - Current)'
        # ,'mean_diff_mortzero':'AHLE due to Mortality (Mortality Zero - Current)'
    }

    # Subset columns
    input_df = input_df[list(columns_to_display_with_labels)]

    # Keep only items for the waterfall
    waterfall_plot_items = ('Value of Offtake',
                             'Value of Herd Increase',
                             'Value of draught',
                             'Value of Milk',
                             'Value of Eggs consumed',
                             'Value of Eggs sold',
                             'Value of Manure',
                             'Value of Hides',
                             'Feed Cost',
                             'Labour Cost',
                             'Health Cost',
                             'Capital Cost',
                             'Gross Margin')
    waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
    input_df = input_df.loc[input_df['item'].str.upper().isin(waterfall_plot_items_upper)]


    return [
            dcc.Markdown(
                '''
                #### AHLE Data

                Showing the major production and cost values under current and ideal scenarios

                *Output of the compartmental population model*
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                             'height': '785px',},
            )
        ]

# Attribution datatable below graphic
@gbadsDash.callback(
    Output('ecs-attr-datatable', 'children'),
    Input('select-currency-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-year-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
    )
def update_ecs_attr_data(currency, prodsys, species, year, geo_view, region):
    # Read in data
    input_df = ecs_ahle_all_withattr

    # Production System filter
    # If All production systems, don't filter. Attribution data is not aggregated to that level.
    if prodsys == 'All Production Systems':
        input_df=input_df
    else:
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Species filter
    # Goat and Sheep do not appear separately. These get all small ruminants results.
    if species == 'Goat' or species == "Sheep":
        input_df=input_df.loc[(input_df['species'] == 'All Small Ruminants')]
    # Poultry subspecies do not appear separately. These get all poultry results.
    elif species == 'Poultry hybrid' or species == "Poultry indigenous":
        input_df=input_df.loc[(input_df['species'] == 'All Poultry')]
    else:
        input_df=input_df.loc[(input_df['species'] == species)]

    # Year filter
    input_df=input_df.loc[(input_df['year'] == year)]

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
    else:
        input_df = input_df.query("region == @region")

    # If currency is USD, use USD columns
    display_currency = 'Birr'
    if currency == 'USD':
        display_currency = 'USD'

    # Format numbers
    input_df.update(input_df[['mean',
                              'sd',
                              'lower95',
                              'upper95',
                              ]].applymap('{:,.0f}'.format))
    # input_df.update(input_df[['pct_of_total']].applymap('{:,.2f}%'.format))

    columns_to_display_with_labels = {
        'species':'Species'
        ,'production_system':'Production System'
        ,'region':'Region'
        ,'age_group':'Age'
        ,'sex':'Sex'
        ,'year':'Year'
        ,'ahle_component':'AHLE Component'
        ,'cause':'Attribution'
        ,'disease':'Disease'
        ,'mean':f'Mean ({display_currency})'
        ,'sd':'Std. Dev.'
        ,'lower95':'Lower 95%'
        ,'upper95':'Upper 95%'
        # ,'pct_of_total':'Percent of Total AHLE'
    }

    # Subset columns
    input_df = input_df[list(columns_to_display_with_labels)]

    return [
            dcc.Markdown(
                '''
                #### Attribution Data

                Attributing the AHLE components to infectious, non-infectious, and external causes

                *Based on expert opinion attribution proportions*
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '320px',
                              'overflowY': 'auto'},
                page_action='none',
            )
        ]

# Attribution expert opinion
@gbadsDash.callback(
    Output('ecs-attr-expert-opinion', 'children'),
    Input('select-species-ecs','value'),
    )
def update_ecs_attr_expert_data(species):
    # Read in data depending on species selected
    if species in ["All Small Ruminants", "Goat", "Sheep"]:
        input_df = ecs_expertattr_smallrum
        spec_label = "Small Ruminants"
    elif species == "Cattle":
        input_df = ecs_expertattr_cattle
        spec_label = "Cattle"
    elif species in ["All Poultry", "Poultry hybrid", "Poultry indigenous"]:
        input_df = ecs_expertattr_poultry
        spec_label = "Poultry"

    # Format numbers
    for COL in ['min' ,'avg' ,'max']:
        input_df[COL] = pd.to_numeric(input_df[COL] ,errors='coerce')  # Ensure numeric
    input_df[['min' ,'avg' ,'max']] = input_df[['min' ,'avg' ,'max']] / 100     # Convert to proportions
    input_df.update(input_df[['min', 'avg', 'max']].applymap('{:.0%}'.format))

    columns_to_display_with_labels = {
        'Expert':'Expert'
        ,'AHLE':'AHLE Component'
        ,'Production system':'Production system'
        ,'Age class':'Age class'
        ,'Cause':'Cause'
        ,'min':'Minimum'
        ,'avg':'Average'
        ,'max':'Max'
        }
    return [
            dcc.Markdown(
                f'''
                #### Expert Opinion Attribution Proportions

                {spec_label}
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '320px',
                              'overflowY': 'auto'},
                page_action='none',
            )
        ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# AHLE Waterfall or Longitudinal Graph
@gbadsDash.callback(
    Output('ecs-ahle-waterfall','figure'),
    Input('select-graph-ahle-ecs', 'value'),
    Input('select-agesex-ecs', 'value'),
    Input('select-species-ecs','value'),
    Input('select-display-ecs','value'),
    Input('select-compare-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-factor-ecs','value'),
    Input('select-improve-ecs','value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
    )
def update_ahle_value_and_cost_viz_ecs(
        graph_options,
        agesex,
        species,
        display,
        compare,
        prodsys,
        currency,
        impvmnt_factor,
        impvmnt_value,
        selected_year,
        selected_item,
        geo_view,
        region,
    ):
    # Read in data and apply filters
    input_df = ecs_ahle_summary

    # Species filter
    input_df = input_df.loc[(input_df['species'] == species)]

    # Production System filter
    input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Age/sex filter
    input_df=input_df.loc[(input_df['group'] == agesex)]

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
        reg_title = 'National'
    else:
        input_df = input_df.query("region == @region")
        reg_title = region

    # Prep the data
    prep_df = prep_ahle_forwaterfall_ecs(input_df)

    # If currency is USD, use USD columns
    display_currency = 'Ethiopian Birr'
    if currency == 'USD':
        display_currency = 'USD'

        prep_df['mean_current']                     = prep_df['mean_current_usd']
        # prep_df['mean_mortality_zero']              = prep_df['mean_mortality_zero_usd']
        prep_df['mean_ideal']                       = prep_df['mean_ideal_usd']
        prep_df['mean_diff_ideal']                  = prep_df['mean_diff_ideal_usd']
        # prep_df['mean_diff_mortzero']               = prep_df['mean_diff_mortzero_usd']
        # prep_df['mean_all_mort_25_imp']             = prep_df['mean_all_mort_25_imp_usd']
        # prep_df['mean_all_mort_50_imp']             = prep_df['mean_all_mort_50_imp_usd']
        # prep_df['mean_all_mort_75_imp']             = prep_df['mean_all_mort_75_imp_usd']
        # prep_df['mean_diff_mortimp25']              = prep_df['mean_diff_mortimp25_usd']
        # prep_df['mean_diff_mortimp50']              = prep_df['mean_diff_mortimp50_usd']
        # prep_df['mean_diff_mortimp75']              = prep_df['mean_diff_mortimp75_usd']
        # prep_df['mean_current_repro_25_imp']        = prep_df['mean_current_repro_25_imp_usd']
        # prep_df['mean_current_repro_50_imp']        = prep_df['mean_current_repro_50_imp_usd']
        # prep_df['mean_current_repro_75_imp']        = prep_df['mean_current_repro_75_imp_usd']
        # prep_df['mean_current_repro_100_imp']       = prep_df['mean_current_repro_100_imp_usd']
        # prep_df['mean_diff_reprimp25']              = prep_df['mean_diff_reprimp25_usd']
        # prep_df['mean_diff_reprimp50']              = prep_df['mean_diff_reprimp50_usd']
        # prep_df['mean_diff_reprimp75']              = prep_df['mean_diff_reprimp75_usd']
        # prep_df['mean_diff_reprimp100']             = prep_df['mean_diff_reprimp100_usd']
        # prep_df['mean_current_growth_25_imp_all']   = prep_df['mean_current_growth_25_imp_all_usd']
        # prep_df['mean_current_growth_50_imp_all']   = prep_df['mean_current_growth_50_imp_all_usd']
        # prep_df['mean_current_growth_75_imp_all']   = prep_df['mean_current_growth_75_imp_all_usd']
        # prep_df['mean_current_growth_100_imp_all']  = prep_df['mean_current_growth_100_imp_all_usd']
        # prep_df['mean_diff_growimp25']              = prep_df['mean_diff_growimp25_usd']
        # prep_df['mean_diff_growimp50']              = prep_df['mean_diff_growimp50_usd']
        # prep_df['mean_diff_growimp75']              = prep_df['mean_diff_growimp75_usd']
        # prep_df['mean_diff_growimp100']             = prep_df['mean_diff_growimp100_usd']

        prep_df['stdev_current']                     = prep_df['stdev_current_usd']
        # prep_df['stdev_mortality_zero']              = prep_df['stdev_mortality_zero_usd']
        prep_df['stdev_ideal']                       = prep_df['stdev_ideal_usd']
        prep_df['stdev_diff_ideal']                  = prep_df['stdev_diff_ideal_usd']
        # prep_df['stdev_diff_mortzero']               = prep_df['stdev_diff_mortzero_usd']
        # prep_df['stdev_all_mort_25_imp']             = prep_df['stdev_all_mort_25_imp_usd']
        # prep_df['stdev_all_mort_50_imp']             = prep_df['stdev_all_mort_50_imp_usd']
        # prep_df['stdev_all_mort_75_imp']             = prep_df['stdev_all_mort_75_imp_usd']
        # prep_df['stdev_diff_mortimp25']              = prep_df['stdev_diff_mortimp25_usd']
        # prep_df['stdev_diff_mortimp50']              = prep_df['stdev_diff_mortimp50_usd']
        # prep_df['stdev_diff_mortimp75']              = prep_df['stdev_diff_mortimp75_usd']
        # prep_df['stdev_current_repro_25_imp']        = prep_df['stdev_current_repro_25_imp_usd']
        # prep_df['stdev_current_repro_50_imp']        = prep_df['stdev_current_repro_50_imp_usd']
        # prep_df['stdev_current_repro_75_imp']        = prep_df['stdev_current_repro_75_imp_usd']
        # prep_df['stdev_current_repro_100_imp']       = prep_df['stdev_current_repro_100_imp_usd']
        # prep_df['stdev_diff_reprimp25']              = prep_df['stdev_diff_reprimp25_usd']
        # prep_df['stdev_diff_reprimp50']              = prep_df['stdev_diff_reprimp50_usd']
        # prep_df['stdev_diff_reprimp75']              = prep_df['stdev_diff_reprimp75_usd']
        # prep_df['stdev_diff_reprimp100']             = prep_df['stdev_diff_reprimp100_usd']
        # prep_df['stdev_current_growth_25_imp_all']   = prep_df['stdev_current_growth_25_imp_all_usd']
        # prep_df['stdev_current_growth_50_imp_all']   = prep_df['stdev_current_growth_50_imp_all_usd']
        # prep_df['stdev_current_growth_75_imp_all']   = prep_df['stdev_current_growth_75_imp_all_usd']
        # prep_df['stdev_current_growth_100_imp_all']  = prep_df['stdev_current_growth_100_imp_all_usd']
        # prep_df['stdev_all_current_growth_25_AHLE']  = prep_df['stdev_all_current_growth_25_AHLE_usd']
        # prep_df['stdev_all_current_growth_50_AHLE']  = prep_df['stdev_all_current_growth_50_AHLE_usd']
        # prep_df['stdev_all_current_growth_75_AHLE']  = prep_df['stdev_all_current_growth_75_AHLE_usd']
        # prep_df['stdev_all_current_growth_100_AHLE'] = prep_df['stdev_all_current_growth_100_AHLE_usd']

    # Create longitudinal chart
    if graph_options == "Over Time":
        # Apply user filters
        # Filter based on selected item
        prep_df = prep_df.query('item in @selected_item')

        # Sort data by year
        prep_df = prep_df.sort_values('year')

        # Establish x
        x = prep_df['year']

        # Match colors to waterfall values
        cost  = 'Expenditure'
        if 'Gross Margin' in selected_item:
            color = '#F7931D'
        elif cost in selected_item:
            color = '#E84C3D'
        else:
            color = '#3598DB'

        # Create AHLE (difference) value
        if display == "Difference":
            if compare == 'Ideal':
                y = prep_df['mean_diff_ideal']
                stdev = prep_df['stdev_diff_ideal']
            elif compare == 'Zero Mortality':
                y = prep_df['mean_diff_mortzero']
                stdev = prep_df['stdev_diff_mortzero']
            else:
                compare = impvmnt_factor + "- " + impvmnt_value
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_diff_mortimp25']
                    stdev = prep_df['stdev_diff_mortimp25']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_diff_mortimp50']
                    stdev = prep_df['stdev_diff_mortimp50']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_diff_mortimp75']
                    stdev = prep_df['stdev_diff_mortimp75']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_diff_mortzero']
                    stdev = prep_df['stdev_diff_mortzero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_reprimp{number_split}']
                    stdev = prep_df[f'stdev_diff_reprimp{number_split}']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_growimp{number_split}']
                    stdev = prep_df[f'stdev_diff_growimp{number_split}']

            # AHLE graph
            stdev = 1.96 * stdev    # Scale stdev to create 95% confidence
            plot_ahle_value = go.Scatter(
                x=x
                ,y=y
                ,error_y=dict(type='data' ,array=stdev)
                ,name='AHLE'
                ,line=dict(color=color)
                )
            ecs_waterfall_fig = make_subplots()
            ecs_waterfall_fig.add_trace(plot_ahle_value)
            ecs_waterfall_fig.update_layout(title=f'{reg_title} {selected_item} Over Time | {species}, {prodsys} <br><sup>Difference between Current and {compare} scenario</sup><br>',
                                            yaxis_title=display_currency,
                                            font_size=15,
                                            plot_bgcolor="#ededed",)
            ecs_waterfall_fig.update_xaxes(ticklabelmode="period", dtick = 1)

        elif display == "Side by Side":
            # Plot current value
            plot_current_value = go.Scatter(
                x=x
                ,y=prep_df['mean_current']
                ,error_y=dict(type='data' ,array=prep_df['stdev_current']*1.96)
                ,name='Current'
                ,line=dict(color=color)
                )
            if compare == 'Ideal':
                # Overlay ideal value
                plot_compare_value = go.Scatter(
                    x=x
                    ,y=prep_df['mean_ideal']
                    ,error_y=dict(type='data' ,array=prep_df['stdev_ideal']*1.96)
                    ,name=compare
                    ,line=dict(color='#00CA0F')
                    )
            elif compare == 'Zero Mortality':
                # Overlay zero mortality value
                plot_compare_value = go.Scatter(
                    x=x
                    ,y = prep_df['mean_mortality_zero']
                    ,error_y=dict(type='data' ,array=prep_df['stdev_mortality_zero']*1.96)
                    ,name=compare
                    ,line=dict(color='#00CA0F')
                    )
            else:
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_all_mort_25_imp']
                    stdev = prep_df['stdev_all_mort_25_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_all_mort_50_imp']
                    stdev = prep_df['stdev_all_mort_50_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_all_mort_75_imp']
                    stdev = prep_df['stdev_all_mort_75_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_mortality_zero']
                    stdev = prep_df['stdev_mortality_zero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_repro_{number_split}_imp']
                    stdev = prep_df[f'stdev_current_repro_{number_split}_imp']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_growth_{number_split}_imp_all']
                    stdev = prep_df[f'stdev_current_growth_{number_split}_imp_all']

                name = impvmnt_factor + "- " + impvmnt_value
                # Overlay zero mortality value
                stdev = 1.96 * stdev    # Scale stdev to create 95% confidence
                plot_compare_value = go.Scatter(
                    x=x
                    ,y=y
                    ,error_y=dict(type='data' ,array=stdev)
                    ,name=name
                    ,line=dict(color='#00CA0F')
                    )

            ecs_waterfall_fig = make_subplots()
            ecs_waterfall_fig.add_trace(plot_compare_value)
            ecs_waterfall_fig.add_trace(plot_current_value)
            ecs_waterfall_fig.update_layout(title=f'{reg_title} {selected_item} Over Time | {species}, {prodsys} <br><sup>Current and {compare} scenario</sup><br>',
                                            yaxis_title=display_currency,
                                            font_size=15,
                                            plot_bgcolor="#ededed",)
            ecs_waterfall_fig.update_xaxes(ticklabelmode="period", dtick = 1)

    # Create waterfall chart
    if graph_options == "Single Year":
        # Filter to a specific year
        prep_df = prep_df.query('year == @selected_year')

        # Select items to show - depends on species
        if species.upper() == "CATTLE":     # Cattle have draught
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Draught',
                                     'Value of Milk',
                                     'Value of Manure',
                                     'Value of Hides',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Eggs consumed',
                                     'Value of Eggs sold',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        else:   # Goats, Sheep, All Small Ruminants
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Milk',
                                     'Value of Manure',
                                     'Value of Hides',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
        prep_df = prep_df.loc[prep_df['item'].str.upper().isin(waterfall_plot_items_upper)]

        # Get list of items from data - may differ from list specified because not all items appear for all age/sex groups
        waterfall_plot_items_indata = list(prep_df['item'].unique())

        measure = ['relative'] * (len(waterfall_plot_items_indata) - 1) + ['total']
        x = prep_df['item']

        # Display and Compare filters
        if display == "Difference":
            # Applying the condition
            prep_df["item"] = np.where(prep_df["item"] == "Gross Margin", "Gross Margin (AHLE)", prep_df["item"])
            x = prep_df['item']
            if compare == 'Ideal':
                y = prep_df['mean_diff_ideal']
                stdev = prep_df['stdev_diff_ideal']
            elif compare == 'Zero Mortality':
                y = prep_df['mean_diff_mortzero']
                stdev = prep_df['stdev_diff_mortzero']
            else:
                compare = impvmnt_factor + "- " + impvmnt_value
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_diff_mortimp25']
                    stdev = prep_df['stdev_diff_mortimp25']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_diff_mortimp50']
                    stdev = prep_df['stdev_diff_mortimp50']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_diff_mortimp75']
                    stdev = prep_df['stdev_diff_mortimp75']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_diff_mortzero']
                    stdev = prep_df['stdev_diff_mortzero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_reprimp{number_split}']
                    stdev = prep_df[f'stdev_diff_reprimp{number_split}']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_growimp{number_split}']
                    stdev = prep_df[f'stdev_diff_growimp{number_split}']

            # Create graph
            name = 'Difference'
            ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x, y)

            # Add error bars
            # Reset indicies
            x = x.reset_index(drop=True)
            y = y.reset_index(drop=True)

            # Scale standard deviation to achieve 95% confidence
            stdev = 1.96 * stdev    # Simulation results are Normally distributed

            # Get cumulative sum value for Y unless Gross Margin
            y_error_sum=[]
            for i in x.values:
                if i != 'Gross Margin (AHLE)':
                    y_error_sum = np.cumsum(y)
                elif i == 'Gross Margin (AHLE)':
                    GM_index = x[x == 'Gross Margin (AHLE)'].index[0]
                    y_error_sum[GM_index] = y[GM_index]
            # Add trace for error
            ecs_waterfall_fig.add_trace(
                go.Scatter(
                     x=x,
                     y=y_error_sum,
                     marker=dict(color='black'),
                     customdata=np.stack((y, prep_df['item']), axis=-1),
                     error_y=dict(
                        type='data',
                        array=stdev
                        ),
                     mode="markers",
                     hoverinfo='none',
                     name='95% Confidence'
                ),
            )
            # Add title
            ecs_waterfall_fig.update_layout(
                title_text=f'{reg_title} Animal Health Loss Envelope | {species}, {prodsys} <br><sup>Difference between current and {compare} values for {agesex}, {selected_year}</sup><br>',
                yaxis_title=display_currency,
                font_size=15,
                margin=dict(t=100)
                )
        else:
            if compare == 'Ideal':
                y = prep_df['mean_ideal']
                stdev = prep_df['stdev_ideal']
                name = "Ideal (solid)"
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len-.3,
                         y=y_error_sum,
                         marker=dict(color='black'),
                         customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=stdev
                            ),
                         mode="markers",
                         hoverinfo='none',
                         showlegend=False
                    ),
                )

                # Add current with lag
                y = prep_df['mean_current']
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = y,
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((y, prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                         marker=dict(color='black'),
                         customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                             type='data',
                             array=prep_df['stdev_current']
                             ),
                         mode="markers",
                         hoverinfo='none',
                         name='95% Confidence'
                    ),
                )
                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     # scattermode="group",
                #     # scattergap=0.75
                #     )

            elif compare == 'Zero Mortality':
                y = prep_df['mean_mortality_zero']
                stdev = prep_df['stdev_mortality_zero']
                name = 'Zero Mortality (solid)'
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                        x=x_len-.3,
                        y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                        error_y=dict(
                            type='data',
                            array=stdev
                        ),
                        mode="markers",
                        hoverinfo='none',
                        showlegend=False
                    ),
                )

                # Add current with lag
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = prep_df['mean_current'],
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((prep_df['mean_current'], prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=prep_df['stdev_current']
                        ),
                        mode="markers",
                        hoverinfo='none',
                        name='95% Confidence'
                    ),
                )

                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     )

            else:
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_all_mort_25_imp']
                    stdev = prep_df['stdev_all_mort_25_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_all_mort_50_imp']
                    stdev = prep_df['stdev_all_mort_50_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_all_mort_75_imp']
                    stdev = prep_df['stdev_all_mort_75_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_mortality_zero']
                    y = prep_df['stdev_mortality_zero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_repro_{number_split}_imp']
                    stdev = prep_df[f'stdev_current_repro_{number_split}_imp']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_growth_{number_split}_imp_all']
                    stdev = prep_df[f'stdev_current_growth_{number_split}_imp_all']

                name = impvmnt_factor + "- " + impvmnt_value + " (solid)"
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len-.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=stdev
                        ),
                        mode="markers",
                        hoverinfo='none',
                        showlegend=False

                    ),
                )

                # Add current with lag
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = prep_df['mean_current'],
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((prep_df['mean_current'], prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=prep_df['stdev_current']
                        ),
                        mode="markers",
                        hoverinfo='none',
                        name='95% Confidence'
                    ),
                )

                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     )

            # Add title
            ecs_waterfall_fig.update_layout(
                title_text=f'{reg_title} Values and Costs | {species}, {prodsys} <br><sup>Current vs. {compare} scenario for {agesex}, {selected_year}</sup><br>',
                yaxis_title=display_currency,
                font_size=15,
                margin=dict(t=100),
                # legend=dict(orientation="v",
                #             xanchor="right",
                #             x=1,
                #             yanchor="bottom",
                #             y=1.02,)
                )

        # Add tooltip
        if currency == 'Birr':
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} Birr<extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} Birr'
                                            )
        elif currency == 'USD':
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} USD<extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} USD'
                                            )
        else:
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} <extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} '
                                            )

    return ecs_waterfall_fig


# Attribution Treemap
@gbadsDash.callback(
    Output('ecs-attr-treemap','figure'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    Input('select-dd-3-attr-ecs','value'),
    Input('select-dd-4-attr-ecs','value'),
    Input('select-graph-ahle-ecs', 'value'),
    # Input('select-year-item-switch-ecs', 'value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
)
def update_attr_treemap_ecs(
        prodsys,
        species,
        currency,
        top_lvl_hierarchy,
        dd1_hierarchy,
        dd2_hierarchy,
        dd3_hierarchy,
        dd4_hierarchy,
        graph_options,
        selected_year,
        selected_item,
        geo_view,
        region,
    ):
    # Data
    input_df = ecs_ahle_all_withattr

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
        reg_title = 'National'
    else:
        input_df = input_df.query("region == @region")
        reg_title = region

    # Production System filter
    # If All production systems, don't filter. Attribution data is not aggregated to that level.
    if prodsys == 'All Production Systems':
        input_df=input_df
    else:
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Species filter
    # Goat and Sheep do not appear separately. These get all small ruminants results.
    if species == 'Goat' or species == "Sheep":
        input_df=input_df.loc[(input_df['species'] == 'All Small Ruminants')]
        species_label = 'All Small Ruminants'

    # Poultry subspecies do not appear separately. These get all poultry results.
    elif species == 'Poultry hybrid' or species == "Poultry indigenous":
        input_df=input_df.loc[(input_df['species'] == 'All Poultry')]
        species_label = 'All Poultry'
    else:
        input_df=input_df.loc[(input_df['species'] == species)]
        species_label = species

    # If currency is USD, use USD columns
    if currency == 'USD':
        # input_df['median'] = input_df['median_usd']
        input_df['mean'] = input_df['mean_usd']
        input_df['sd'] = input_df['sd_usd']
        input_df['lower95'] = input_df['lower95_usd']
        input_df['upper95'] = input_df['upper95_usd']

    # Prep data
    input_df = prep_ahle_fortreemap_ecs(input_df)

    # Create treemap
    if graph_options == "Single Year":
        # Year filter
        input_df = input_df.query(f'year == {selected_year}')

        # Hiararchy structure
        path = [top_lvl_hierarchy]
        if dd1_hierarchy != 'None':
            path +=[dd1_hierarchy]
        if dd2_hierarchy != 'None':
            path +=[dd2_hierarchy]
        if dd3_hierarchy != 'None':
            path +=[dd3_hierarchy]
        if dd4_hierarchy != 'None':
            path +=[dd4_hierarchy]

        # Set up treemap structure
        ecs_treemap_fig = create_attr_treemap_ecs(input_df, path)

        # Add title
        ecs_treemap_fig.update_layout(
            title_text=f'{reg_title} AHLE Attribution | {species_label}, {prodsys}<br><sup>{selected_year}',
            font_size=15,
            margin=dict(t=100)
            )

        # Add % of total AHLE
        # ecs_treemap_fig.data[0].texttemplate = "%{label}<br>% of Total AHLE=%{customdata[0]:,.2f}%"

        # Add tooltip
        if currency == 'Birr':
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f} Birr<extra></extra>')

        elif currency == 'USD':
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f} USD<extra></extra>')
        else:
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f}<br><extra></extra>')

    # Create view over time
    # A stacked bar for each year, segmented by one of the hierarchy factors
    elif graph_options == "Over Time":
        segment_by = top_lvl_hierarchy   # For now, segment bars by selected top level component

        # Aggregate data to year and segment
        stackedbar_df = input_df.groupby(['year' ,segment_by])['mean'].sum().reset_index()

        ecs_treemap_fig = px.bar(
            stackedbar_df
            ,x='year'
            ,y='mean'
            ,color=segment_by
            ,barmode='relative'
            )
        ecs_treemap_fig.update_layout(
            title_text=f'{reg_title} AHLE Attribution over time | {species_label}, {prodsys}<br><sup>by {segment_by}',
            font_size=15,
            margin=dict(t=100)
            )
        ecs_treemap_fig.update_xaxes(title_text='')
        if currency == 'Birr':
            ecs_treemap_fig.update_yaxes(title_text='Ethiopian Birr')
        elif currency == 'USD':
            ecs_treemap_fig.update_yaxes(title_text='USD')

    # Adjust margins
    ecs_treemap_fig.update_layout(
        margin=dict(l=5, r=5, b=5),
        )

    return ecs_treemap_fig

# Update Stacked bar chart
@gbadsDash.callback(
    Output('ahle-stacked-bar-ecs','figure'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-compare-ecs','value'),
    Input('select-factor-ecs','value'),
    Input('select-improve-ecs','value'),
    Input('select-graph-ahle-ecs', 'value'),
    # Input('select-year-item-switch-ecs', 'value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    )
def update_stacked_bar_ecs(
        prodsys,
        species,
        currency,
        compare,
        impvmnt_factor,
        impvmnt_value,
        graph_options,
        selected_year,
        selected_item,
    ):
    # AHLE Summary 2 - for stacked bar
    input_df = ecs_ahle_summary2

    # Rename values to match filters
    input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})

    # Set columns for stacked bar based on selections
    # Change y based on selected currency value
    if compare == 'Ideal':
       cols_birr_costs = [
      'ahle_when_nm_ideal_mean'
      ,'ahle_when_nf_ideal_mean'
      ,'ahle_when_jm_ideal_mean'
      ,'ahle_when_jf_ideal_mean'
      ,'ahle_when_am_ideal_mean'
      ,'ahle_when_af_ideal_mean'
      ]
       cols_usd_costs = [
      'ahle_when_nm_ideal_mean_usd'
      ,'ahle_when_nf_ideal_mean_usd'
      ,'ahle_when_jm_ideal_mean_usd'
      ,'ahle_when_jf_ideal_mean_usd'
      ,'ahle_when_am_ideal_mean_usd'
      ,'ahle_when_af_ideal_mean_usd'
      ]
       pretty_ahle_cost_names = {
          'ahle_when_nm_ideal_mean':'Neonatal male'
          ,'ahle_when_nm_ideal_mean_usd':'Neonatal male'

          ,'ahle_when_nf_ideal_mean':'Neonatal female'
          ,'ahle_when_nf_ideal_mean_usd':'Neonatal female'

          ,'ahle_when_jm_ideal_mean':'Juvenile male'
          ,'ahle_when_jm_ideal_mean_usd':'Juvenile male'

          ,'ahle_when_jf_ideal_mean':'Juvenile female'
          ,'ahle_when_jf_ideal_mean_usd':'Juvenile female'

           ,'ahle_when_am_ideal_mean':'Adult male'
           ,'ahle_when_am_ideal_mean_usd':'Adult male'

          ,'ahle_when_af_ideal_mean':'Adult female'
          ,'ahle_when_af_ideal_mean_usd':'Adult female'
       }

    elif compare == 'Zero Mortality':
        cols_birr_costs = [
        'ahle_when_n_mort_imp100_mean'
        ,'ahle_when_j_mort_imp100_mean'
        ,'ahle_when_am_mort_imp100_mean'
        ,'ahle_when_af_mort_imp100_mean'
        ]
        cols_usd_costs = [
        'ahle_when_n_mort_imp100_mean_usd'
        ,'ahle_when_j_mort_imp100_mean_usd'
        ,'ahle_when_am_mort_imp100_mean_usd'
        ,'ahle_when_af_mort_imp100_mean_usd'
        ]
        pretty_ahle_cost_names = {
            'ahle_when_n_mort_imp100_mean':'Neonatal'
            ,'ahle_when_n_mort_imp100_mean_usd':'Neonatal'

            ,'ahle_when_j_mort_imp100_mean':'Juvenile'
            ,'ahle_when_j_mort_imp100_mean_usd':'Juvenile'

            ,'ahle_when_am_mort_imp100_mean':'Adult male'
            ,'ahle_when_am_mort_imp100_mean_usd':'Adult male'

            ,'ahle_when_af_mort_imp100_mean':'Adult female'
            ,'ahle_when_af_mort_imp100_mean_usd':'Adult female'
        }
    else:
        if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp25_mean'
            ,'ahle_when_j_mort_imp25_mean'
            ,'ahle_when_am_mort_imp25_mean'
            ,'ahle_when_af_mort_imp25_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp25_mean_usd'
            ,'ahle_when_j_mort_imp25_mean_usd'
            ,'ahle_when_am_mort_imp25_mean_usd'
            ,'ahle_when_af_mort_imp25_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp25_mean':'Neonatal'
                ,'ahle_when_n_mort_imp25_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp25_mean':'Juvenile'
                ,'ahle_when_j_mort_imp25_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp25_mean':'Adult male'
                ,'ahle_when_am_mort_imp25_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp25_mean':'Adult female'
                ,'ahle_when_af_mort_imp25_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp50_mean'
            ,'ahle_when_j_mort_imp50_mean'
            ,'ahle_when_am_mort_imp50_mean'
            ,'ahle_when_af_mort_imp50_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp50_mean_usd'
            ,'ahle_when_j_mort_imp50_mean_usd'
            ,'ahle_when_am_mort_imp50_mean_usd'
            ,'ahle_when_af_mort_imp50_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp50_mean':'Neonatal'
                ,'ahle_when_n_mort_imp50_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp50_mean':'Juvenile'
                ,'ahle_when_j_mort_imp50_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp50_mean':'Adult male'
                ,'ahle_when_am_mort_imp50_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp50_mean':'Adult female'
                ,'ahle_when_af_mort_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp75_mean'
            ,'ahle_when_j_mort_imp75_mean'
            ,'ahle_when_am_mort_imp75_mean'
            ,'ahle_when_af_mort_imp75_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp75_mean_usd'
            ,'ahle_when_j_mort_imp75_mean_usd'
            ,'ahle_when_am_mort_imp75_mean_usd'
            ,'ahle_when_af_mort_imp75_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp75_mean':'Neonatal'
                ,'ahle_when_n_mort_imp75_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp75_mean':'Juvenile'
                ,'ahle_when_j_mort_imp75_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp75_mean':'Adult male'
                ,'ahle_when_am_mort_imp75_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp75_mean':'Adult female'
                ,'ahle_when_af_mort_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp100_mean'
            ,'ahle_when_j_mort_imp100_mean'
            ,'ahle_when_am_mort_imp100_mean'
            ,'ahle_when_af_mort_imp100_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp100_mean_usd'
            ,'ahle_when_j_mort_imp100_mean_usd'
            ,'ahle_when_am_mort_imp100_mean_usd'
            ,'ahle_when_af_mort_imp100_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp100_mean':'Neonatal'
                ,'ahle_when_n_mort_imp100_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp100_mean':'Juvenile'
                ,'ahle_when_j_mort_imp100_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp100_mean':'Adult male'
                ,'ahle_when_am_mort_imp100_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp100_mean':'Adult female'
                ,'ahle_when_af_mort_imp100_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '25%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp25_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp25_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp25_mean':'Adult female'
                ,'ahle_when_af_repro_imp25_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '50%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp50_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp50_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp50_mean':'Adult female'
                ,'ahle_when_af_repro_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '75%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp75_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp75_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp75_mean':'Adult female'
                ,'ahle_when_af_repro_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '100%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp100_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp100_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp100_mean':'Adult female'
                ,'ahle_when_af_repro_imp100_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '25%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp25_mean'
           ,'ahle_when_nf_growth_imp25_mean'
           ,'ahle_when_jm_growth_imp25_mean'
           ,'ahle_when_jf_growth_imp25_mean'
           ,'ahle_when_am_growth_imp25_mean'
           ,'ahle_when_af_growth_imp25_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp25_mean_usd'
           ,'ahle_when_nf_growth_imp25_mean_usd'
           ,'ahle_when_jm_growth_imp25_mean_usd'
           ,'ahle_when_jf_growth_imp25_mean_usd'
           ,'ahle_when_am_growth_imp25_mean_usd'
           ,'ahle_when_af_growth_imp25_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp25_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp25_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp25_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp25_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp25_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp25_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp25_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp25_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp25_mean':'Adult male'
                ,'ahle_when_am_growth_imp25_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp25_mean':'Adult female'
               ,'ahle_when_af_growth_imp25_mean_usd':'Adult female'
            }

        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '50%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp50_mean'
           ,'ahle_when_nf_growth_imp50_mean'
           ,'ahle_when_jm_growth_imp50_mean'
           ,'ahle_when_jf_growth_imp50_mean'
           ,'ahle_when_am_growth_imp50_mean'
           ,'ahle_when_af_growth_imp50_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp50_mean_usd'
           ,'ahle_when_nf_growth_imp50_mean_usd'
           ,'ahle_when_jm_growth_imp50_mean_usd'
           ,'ahle_when_jf_growth_imp50_mean_usd'
           ,'ahle_when_am_growth_imp50_mean_usd'
           ,'ahle_when_af_growth_imp50_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp50_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp50_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp50_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp50_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp50_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp50_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp50_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp50_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp50_mean':'Adult male'
                ,'ahle_when_am_growth_imp50_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp50_mean':'Adult female'
               ,'ahle_when_af_growth_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '75%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp75_mean'
           ,'ahle_when_nf_growth_imp75_mean'
           ,'ahle_when_jm_growth_imp75_mean'
           ,'ahle_when_jf_growth_imp75_mean'
           ,'ahle_when_am_growth_imp75_mean'
           ,'ahle_when_af_growth_imp75_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp75_mean_usd'
           ,'ahle_when_nf_growth_imp75_mean_usd'
           ,'ahle_when_jm_growth_imp75_mean_usd'
           ,'ahle_when_jf_growth_imp75_mean_usd'
           ,'ahle_when_am_growth_imp75_mean_usd'
           ,'ahle_when_af_growth_imp75_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp75_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp75_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp75_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp75_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp75_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp75_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp75_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp75_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp75_mean':'Adult male'
                ,'ahle_when_am_growth_imp75_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp75_mean':'Adult female'
               ,'ahle_when_af_growth_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '100%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp100_mean'
           ,'ahle_when_nf_growth_imp100_mean'
           ,'ahle_when_jm_growth_imp100_mean'
           ,'ahle_when_jf_growth_imp100_mean'
           ,'ahle_when_am_growth_imp100_mean'
           ,'ahle_when_af_growth_imp100_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp100_mean_usd'
           ,'ahle_when_nf_growth_imp100_mean_usd'
           ,'ahle_when_jm_growth_imp100_mean_usd'
           ,'ahle_when_jf_growth_imp100_mean_usd'
           ,'ahle_when_am_growth_imp100_mean_usd'
           ,'ahle_when_af_growth_imp100_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp100_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp100_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp100_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp100_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp100_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp100_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp100_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp100_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp100_mean':'Adult male'
                ,'ahle_when_am_growth_imp100_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp100_mean':'Adult female'
               ,'ahle_when_af_growth_imp100_mean_usd':'Adult female'
            }

    # -----------------------------------------------------------------------------
    # Base plot
    # -----------------------------------------------------------------------------
    # Apply year filter
    if graph_options == "Single Year":
        input_df = input_df.loc[input_df['year'] == selected_year]
    else:
        input_df = input_df.loc[input_df['year'] == 2021]

    # Structure for plot
    stackedbar_df = prep_ahle_forstackedbar_ecs(input_df, cols_birr_costs, cols_usd_costs, pretty_ahle_cost_names)

    # Apply production system filter
    stackedbar_df = stackedbar_df.loc[stackedbar_df['production_system'] == prodsys]

    # Apply species filter
    stackedbar_df = stackedbar_df.loc[stackedbar_df['species'] == species]

    x = stackedbar_df['species']

    # Change y based on selected currency value
    if currency == 'Birr':
        yaxis_title = 'Ethiopian Birr'
        y = stackedbar_df['cost_birr']
        text = stackedbar_df['label_birr']
    elif currency == 'USD':
        yaxis_title = 'USD'
        y = stackedbar_df['cost_usd']
        text = stackedbar_df['label_usd']

    # Color
    color = stackedbar_df['AHLE Due To']

    # Create Stacked Bar
    ahle_bar_ecs_fig = create_stacked_bar_ecs(stackedbar_df, x, y, text, color, yaxis_title)

    if compare == 'Ideal' or compare == 'Zero Mortality':
        ahle_bar_ecs_fig.update_layout(
            title_text=f'AHLE contributions by Age Group | {species}, {prodsys} <br><sup>{compare} scenario</sup><br>',
            font_size=15
            )
    else:
        ahle_bar_ecs_fig.update_layout(
            title_text=f'AHLE contributions by Age Group | {species}, {prodsys} <br><sup>{impvmnt_factor} {impvmnt_value} improvement scenario</sup><br>',
            font_size=15
            )

    # # Add tooltip
    # if currency == 'Birr':
    #     ahle_bar_ecs_fig.update_traces(hovertemplate='Category=%{color}<br>Value=%{y:,.0f} Birr<extra></extra>')
    # elif currency == 'USD':
    #     ahle_bar_ecs_fig.update_traces(hovertemplate='Category=%{color}<br>Value=%{y:,.0f} USD<extra></extra>')

    return ahle_bar_ecs_fig

@gbadsDash.callback(
    Output('ecs-wei-chart-1','figure'),
    Output('ecs-wei-chart-2','figure'),
    Input('select-species-ecs','value'),    # Dummy input
    )
def update_wei_display_ecs(species):
    # Chart 1: GDP
    wei_chart_1 = create_wei_chart(
        input_df=wei_ethiopia_raw
        ,plot_xvar='production_change_pct'
        ,plot_yvar='gdp_change_pct'
        ,plot_color='blue'
        ,interpolation_kind='linear'
        )
    wei_chart_1.update_layout(
        title_text='GDP change due to productivity change by scenario <br><sup>Cattle and small ruminants combined</sup>'
        ,font_size=15

    	,xaxis_title='% Change in Production'
        ,xaxis_tickformat='.0%'

    	,yaxis_title='% GDP Change'
        ,yaxis_tickformat='.1%'

        ,plot_bgcolor="#ededed"
        )

    # Chart 2: Economic surplus
    wei_chart_2 = create_wei_chart(
        input_df=wei_ethiopia_raw
        ,plot_xvar='production_change_pct'
        ,plot_yvar='economic_surplus_mlnusd'
        ,plot_color='green'
        ,interpolation_kind='linear'
        )
    wei_chart_2.update_layout(
        title_text='Economic surplus due to productivity change by scenario <br><sup>Cattle and small ruminants combined</sup>'
        ,font_size=15

    	,xaxis_title='% Change in Production'
        ,xaxis_tickformat='.0%'

    	,yaxis_title='Economic Surplus (Million USD)'
        ,yaxis_tickformat='$,.1f'

        ,plot_bgcolor="#ededed"
        )
    return wei_chart_1 ,wei_chart_2

# Update subnational map
@gbadsDash.callback(
    Output('ecs-map','figure'),
    Input('select-species-ecs','value'),
    Input('select-agesex-ecs', 'value'),
    Input('select-prodsys-ecs','value'),
    Input('select-map-display-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-map-denominator-ecs','value'),
    )
def update_map_display_ecs(species, group, prodsys, item, currency, denominator):
    if species.upper() != 'CATTLE':
        ecs_map_fig = go.Figure()
        ecs_map_fig.update_layout(
               xaxis =  { "visible": False },
               yaxis = { "visible": False },
               annotations = [
                   {
                       "text": "Subnational estimates are currently only available for cattle.",
                       "xref": "paper",
                       "yref": "paper",
                       "showarrow": False,
                       "font": {
                           "size": 28
                       }
                   }
               ]
           )
    else:
        # Ethiopia subnational level map data from S3
        geojson_ecs_df = geojson_ecs.copy()
        # geojson_ecs_df = gpd.read_file('<filename>.geojson')

        # Set location based on the granularity level of data - currently Region
        featureid = 'ADM1_EN'
        location = 'region'

        # Set the featureid key needed for the choropleth mapbox map
        featurekey = (f'properties.{featureid}')

        # Read in data and apply filters
        input_df = ecs_ahle_summary

        # Filter based on species - Currently only have Cattle for 2021
        input_df = input_df.loc[(input_df['species'] == 'Cattle')]

        # Remove 'National' for regional view
        input_df = input_df.query("region != 'National'")

        # Production System filter
        # Rename values to match filters
        input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

        # Age/sex filter
        input_df=input_df.loc[(input_df['group'] == group)]

        if item == 'Ideal Gross Margin' or item == 'Animal Health Loss Envelope':
            item_filter = 'Gross Margin'
        else:
            item_filter = item
        input_df = input_df.query("item == @item_filter")

        # Set values based on selected currency and denominator values
        # If currency is USD, use USD columns
        display_currency = 'Ethiopian Birr'
        if denominator.upper() == 'PER KG BIOMASS':
            if currency == 'USD':
                display_currency = 'USD'
                input_df['mean_current'] = input_df['mean_current_perkgbiomass_usd']
                input_df['mean_ideal'] = input_df['mean_ideal_perkgbiomass_usd']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_perkgbiomass_usd']
            else:
                input_df['mean_current'] = input_df['mean_current_perkgbiomass']
                input_df['mean_ideal'] = input_df['mean_ideal_perkgbiomass']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_perkgbiomass']

        else:
            if currency == 'USD':
                display_currency = 'USD'
                input_df['mean_current'] = input_df['mean_current_usd']
                input_df['mean_ideal'] = input_df['mean_ideal_usd']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_usd']

        # Color scale by current, ideal or AHLE
        if item == 'Ideal Gross Margin':
            color_by = 'mean_ideal'
        elif item == 'Animal Health Loss Envelope':
            color_by = 'mean_diff_ideal'
        else:
            color_by = 'mean_current'

        input_df = input_df.sort_values(by=[f'{color_by}'])

        # Set color scale to match waterfall colors
        if "GROSS MARGIN" in item.upper() or "ANIMAL HEALTH LOSS ENVELOPE" in item.upper():
            color_scale = [(0, "#F7F9FB"), (0.5, "#F7C080"), (1, "#F7931D")]
        elif "VALUE" in item.upper():
            color_scale = [(0, "#ecf5fc"), (0.5, "#88c2ea"), (1, "#3598db")]
        elif "COST" in item.upper():
            color_scale = [(0, "#fdeeec"), (0.5, "#f08d83"), (1, "#E84C3D")]

        ecs_map_fig = create_map_display_ecs(input_df, geojson_ecs_df, location, featurekey, color_by, color_scale)

        # Set min to 0
        if min(input_df[f'{color_by}']) < 0:
            ecs_map_fig.update_layout(coloraxis=dict(cmax=max(input_df[f'{color_by}']), cmin=0))
        else:
            ecs_map_fig.update_layout(coloraxis=dict(cmax=max(input_df[f'{color_by}']), cmin=min(input_df[f'{color_by}'])))

        # Adjust margins
        ecs_map_fig.update_layout(
            margin=dict(l=5, r=5, b=5),
            )

        # Add title
        ecs_map_fig.update_layout(
            title_text=f'{item} in {currency} {denominator} by subnational state | {group} Cattle, {prodsys} in 2021',
            font_size=15
            )

        # Update legend title
        ecs_map_fig.update_layout(
            coloraxis_colorbar=dict(
                title=f"{display_currency}",
                )
            )

        # Disable mouse zooming at request of Ethiopia users
        #!!! Unknown why this does not work.
        ecs_map_fig.update_layout(dragmode=False)

        # TODO: Refine tooltip
        # # Update tooltip
        # if currency == 'Birr':
        #     ecs_map_fig.update_traces(hovertemplate='subnational state: %{location}'+
        #                                     '<br>%{featurekey}: %{y} Birr <extra></extra>',
        #                                     )
        #     # Tried x, color, item, color_by, text, featurekey, y
        # elif currency == 'USD':
        #     ecs_map_fig.update_traces(hovertemplate='subnational state: %{location}'+
        #                                     '<br>%{item}: %{color:,.0f} USD <extra></extra>'+
        #                                     ''
        #                                     )

    return ecs_map_fig

# ==============================================================================
#### UPDATE ANTIMICROBIAL USE
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
# Switch between Map Display and Drilldown
@gbadsDash.callback(
    Output('select-map-display-drilldown-amu','options'),
    Output('select-map-display-drilldown-amu','value'),
    Output('select-map-display-drilldown-amu-title','children'),
    Input('select-viz-switch-amu','value'),
    )
def update_map_display_drilldown_switch(viz_switch):
    if viz_switch == 'Map':
        options = amu_map_display_options
        value = 'Antimicrobial usage: tonnes'
        title = 'Map Display'
    else:
        options = ['Antimicrobial usage: tonnes', 'Antimicrobial usage: mg per kg biomass']
        value = 'Antimicrobial usage: mg per kg biomass'
        title = 'Drill Down Display'

    return options, value, title

# Switch between Importance categories and Antimicrobial class options
@gbadsDash.callback(
    Output('select-antimicrobial-importance-class-amu','options'),
    Output('select-antimicrobial-importance-class-amu','value'),
    Output('select-antimicrobial-importance-class-amu-title','children'),
    Output('select-antimicrobial-importance-class-amu','style'),
    Output('select-antimicrobial-importance-class-amu-title','style'),
    Input('select-map-display-drilldown-amu','value'),
    Input('select-viz-switch-amu','value'),
    )
def update_antimicrobial_importance_class_switch(display_option, viz_switch):
    if viz_switch == 'Drill Down':
        options =['OneHealth Importance Categories', 'WHO Importance Categories', 'WOAH Importance Categories']
        value = 'WOAH Importance Categories'
        title = 'Importance Categories'
        block = {'display': 'block'}
        # d['disabled']=False
    else:
        options = amu_antimicrobial_class_options.copy()
        for d in options:
            if display_option == 'Antimicrobial Resistance (country level)':
                block = {'display': 'block'}
                d['disabled']=False
                value = 'Aminoglycosides'
                title = 'Antimicrobials'
            else:
                block = {'display': 'none'} # hide antimicrobial class dropdown
                d['disabled']=True
                value = ''
                title = ''

    return options, value, title, block, block

# Enable the options for antibotics/pathogens when 'AMR' is selected
@gbadsDash.callback(
    # Output('select-antimicrobial-importance-class-amu','options'),
    # Output('select-antimicrobial-importance-class-amu','style'),
    # Output('select-antimicrobial-importance-class-amu-title','style'),
    Output('select-pathogens-amu','options'),
    Output('select-pathogens-amu','style'),
    Output('select-pathogens-amu-title','style'),
    Input('select-map-display-drilldown-amu','value'),
    Input('select-antimicrobial-importance-class-amu', 'value'),
    )
def update_map_amr_options(display_option, antimicrobial_class):
    # options1 = amu_antimicrobial_class_options.copy()
    options2 = amu_pathogen_options.copy()
    # for d in options1:
    #     if display_option == 'AMR':
    #         block = {'display': 'block'}
    #         d['disabled']=False
    #     else:
    #         block = {'display': 'none'} # hide antimicrobial class dropdown
    #         d['disabled']=True

    # Pathogen options
    for d in options2:

        if display_option == 'Antimicrobial Resistance (country level)':
            # Filter data based on antimicrobial class selected
            input_df=amr_withsmry.query(f"antimicrobial_class == '{antimicrobial_class}'")
            options2 = []
            for i in input_df['pathogen'].unique():
                str(options2.append({'label':i,'value':(i)}))

            block = {'display': 'block'}
            d['disabled']=False
        else:
            block = {'display': 'none'} # hide pathogen dropdown
            d['disabled']=True

    # return options1, block, block, options2, block, block
    return options2, block, block


# Output('select-pathogens-amu', 'options'),
#     Input('select-antimicrobial-importance-class-amu', 'value'),
#     )
# def update_pathogens_options_ga(antimicrobial_class):
#     input_df=amr_withsmry.query(f"antimicrobial_class == '{antimicrobial_class}'")
#     # Set options for pathogens based on the antimicrobial class selected
#     options = []
#     for i in input_df['pathogens'].unique():
#         str(options.append({'label':i,'value':(i)}))


# Usage and Price sliders
# am-usage-slider-africa
@gbadsDash.callback(
    Output('am-usage-slider-africa', 'min'),
    Output('am-usage-slider-africa', 'max'),
    Output('am-usage-slider-africa', 'value'),
    Output('am-usage-slider-africa', 'step'),
    Output('am-usage-slider-africa', 'marks'),

    Output('am-price-slider-africa', 'min'),
    Output('am-price-slider-africa', 'max'),
    Output('am-price-slider-africa', 'value'),
    Output('am-price-slider-africa', 'step'),
    Output('am-price-slider-africa', 'marks'),

    Output('am-usage-slider-americas', 'min'),
    Output('am-usage-slider-americas', 'max'),
    Output('am-usage-slider-americas', 'value'),
    Output('am-usage-slider-americas', 'step'),
    Output('am-usage-slider-americas', 'marks'),

    Output('am-price-slider-americas', 'min'),
    Output('am-price-slider-americas', 'max'),
    Output('am-price-slider-americas', 'value'),
    Output('am-price-slider-americas', 'step'),
    Output('am-price-slider-americas', 'marks'),

    Output('am-usage-slider-asia', 'min'),
    Output('am-usage-slider-asia', 'max'),
    Output('am-usage-slider-asia', 'value'),
    Output('am-usage-slider-asia', 'step'),
    Output('am-usage-slider-asia', 'marks'),

    Output('am-price-slider-asia', 'min'),
    Output('am-price-slider-asia', 'max'),
    Output('am-price-slider-asia', 'value'),
    Output('am-price-slider-asia', 'step'),
    Output('am-price-slider-asia', 'marks'),

    Output('am-usage-slider-europe', 'min'),
    Output('am-usage-slider-europe', 'max'),
    Output('am-usage-slider-europe', 'value'),
    Output('am-usage-slider-europe', 'step'),
    Output('am-usage-slider-europe', 'marks'),

    Output('am-price-slider-europe', 'min'),
    Output('am-price-slider-europe', 'max'),
    Output('am-price-slider-europe', 'value'),
    Output('am-price-slider-europe', 'step'),
    Output('am-price-slider-europe', 'marks'),

    Output('am-usage-slider-mideast', 'min'),
    Output('am-usage-slider-mideast', 'max'),
    Output('am-usage-slider-mideast', 'value'),
    Output('am-usage-slider-mideast', 'step'),
    Output('am-usage-slider-mideast', 'marks'),

    Output('am-price-slider-mideast', 'min'),
    Output('am-price-slider-mideast', 'max'),
    Output('am-price-slider-mideast', 'value'),
    Output('am-price-slider-mideast', 'step'),
    Output('am-price-slider-mideast', 'marks'),

    Input('reset-sliders-amu','n_clicks'),
    )
def update_usage_price_sliders(reset_button):
    regional_usage_price_data = amu_combined_regional.copy()


    # Steps will be the same for all
    usage_step = 1
    price_step = 1

    # Africa
    usage_africa_min = regional_usage_price_data.query("region == 'Africa'")['terr_amu_tonnes_reporting_2020'].values[0].astype(int)
    usage_africa_mid = regional_usage_price_data.query("region == 'Africa'")['terr_amu_tonnes_region_2020'].values[0].astype(int)
    usage_africa_max = regional_usage_price_data.query("region == 'Africa'")['terr_amu_tonnes_mulch_2020'].values[0].astype(int)
    usage_africa_marks = {
        usage_africa_min.astype(str):'A*',
        usage_africa_mid.astype(str):'B*',
        usage_africa_max.astype(str):'C*',
        # 'style':{'fontWeight': 'bold'}
        }

    price_africa_min = regional_usage_price_data.query("region == 'Africa'")['am_price_usdpertonne_low'].values[0].astype(int)
    price_africa_mid = regional_usage_price_data.query("region == 'Africa'")['am_price_usdpertonne_mid'].values[0].astype(int)
    price_africa_max = regional_usage_price_data.query("region == 'Africa'")['am_price_usdpertonne_high'].values[0].astype(int)
    price_africa_marks = {
        price_africa_min.astype(str):'Low'
        ,price_africa_mid.astype(str):'Med'
        ,price_africa_max.astype(str):'High'
        }

    # Americas
    usage_americas_min = regional_usage_price_data.query("region == 'Americas'")['terr_amu_tonnes_reporting_2020'].values[0].astype(int)
    usage_americas_mid = regional_usage_price_data.query("region == 'Americas'")['terr_amu_tonnes_region_2020'].values[0].astype(int)
    usage_americas_max = regional_usage_price_data.query("region == 'Americas'")['terr_amu_tonnes_mulch_2020'].values[0].astype(int)
    usage_americas_marks = {
        usage_americas_min.astype(str):'A*'
        ,usage_americas_mid.astype(str):'B*'
        ,usage_americas_max.astype(str):'C*'
        }

    price_americas_min = regional_usage_price_data.query("region == 'Americas'")['am_price_usdpertonne_low'].values[0].astype(int)
    price_americas_mid = regional_usage_price_data.query("region == 'Americas'")['am_price_usdpertonne_mid'].values[0].astype(int)
    price_americas_max = regional_usage_price_data.query("region == 'Americas'")['am_price_usdpertonne_high'].values[0].astype(int)
    price_americas_marks = {
        price_americas_min.astype(str):'Low'
        ,price_americas_mid.astype(str):'Med'
        ,price_americas_max.astype(str):'High'
        }

    # Asia, Far East and Oceania
    usage_asia_min = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['terr_amu_tonnes_reporting_2020'].values[0].astype(int)
    usage_asia_mid = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['terr_amu_tonnes_region_2020'].values[0].astype(int)
    usage_asia_max = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['terr_amu_tonnes_mulch_2020'].values[0].astype(int)
    usage_asia_marks = {
        usage_asia_min.astype(str):'A*'
        ,usage_asia_mid.astype(str):'B*'
        ,usage_asia_max.astype(str):'C*'
        }

    price_asia_min = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['am_price_usdpertonne_low'].values[0].astype(int)
    price_asia_mid = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['am_price_usdpertonne_mid'].values[0].astype(int)
    price_asia_max = regional_usage_price_data.query("region == 'Asia, Far East and Oceania'")['am_price_usdpertonne_high'].values[0].astype(int)
    price_asia_marks = {
        price_asia_min.astype(str):'Low'
        ,price_asia_mid.astype(str):'Med'
        ,price_asia_max.astype(str):'High'
        }

    # Europe
    usage_europe_min = regional_usage_price_data.query("region == 'Europe'")['terr_amu_tonnes_reporting_2020'].values[0].astype(int)
    usage_europe_mid = regional_usage_price_data.query("region == 'Europe'")['terr_amu_tonnes_region_2020'].values[0].astype(int)
    usage_europe_max = regional_usage_price_data.query("region == 'Europe'")['terr_amu_tonnes_mulch_2020'].values[0].astype(int)
    usage_europe_marks = {
        usage_europe_min.astype(str):'A*'
        ,usage_europe_mid.astype(str):'B*'
        ,usage_europe_max.astype(str):'C*'
        }

    price_europe_min = regional_usage_price_data.query("region == 'Europe'")['am_price_usdpertonne_low'].values[0].astype(int)
    price_europe_mid = regional_usage_price_data.query("region == 'Europe'")['am_price_usdpertonne_mid'].values[0].astype(int)
    price_europe_max = regional_usage_price_data.query("region == 'Europe'")['am_price_usdpertonne_high'].values[0].astype(int)
    price_europe_marks = {
        price_europe_min.astype(str):'Low'
        ,price_europe_mid.astype(str):'Med'
        ,price_europe_max.astype(str):'High'
        }

    # Middle East
    usage_mideast_min = regional_usage_price_data.query("region == 'Middle East'")['terr_amu_tonnes_reporting_2020'].values[0].astype(int)
    usage_mideast_mid = regional_usage_price_data.query("region == 'Middle East'")['terr_amu_tonnes_region_2020'].values[0].astype(int)
    usage_mideast_max = regional_usage_price_data.query("region == 'Middle East'")['terr_amu_tonnes_mulch_2020'].values[0].astype(int)
    usage_mideast_marks = {
        usage_mideast_min.astype(str):'A*'
        ,usage_mideast_mid.astype(str):'B*'
        ,usage_mideast_max.astype(str):'C*'
        }

    price_mideast_min = regional_usage_price_data.query("region == 'Middle East'")['am_price_usdpertonne_low'].values[0].astype(int)
    price_mideast_mid = regional_usage_price_data.query("region == 'Middle East'")['am_price_usdpertonne_mid'].values[0].astype(int)
    price_mideast_max = regional_usage_price_data.query("region == 'Middle East'")['am_price_usdpertonne_high'].values[0].astype(int)
    price_mideast_marks = {
        price_mideast_min.astype(str):'Low'
        ,price_mideast_mid.astype(str):'Med'
        ,price_mideast_max.astype(str):'High'
        }

    return usage_africa_min ,usage_africa_max ,usage_africa_mid ,usage_step ,usage_africa_marks \
        ,price_africa_min ,price_africa_max ,price_africa_mid ,price_step ,price_africa_marks \
        ,usage_americas_min ,usage_americas_max ,usage_americas_mid ,usage_step ,usage_americas_marks \
        ,price_americas_min ,price_americas_max ,price_americas_mid ,price_step ,price_americas_marks \
        ,usage_asia_min ,usage_asia_max ,usage_asia_mid ,usage_step ,usage_asia_marks \
        ,price_asia_min ,price_asia_max ,price_asia_mid ,price_step ,price_asia_marks \
        ,usage_europe_min ,usage_europe_max ,usage_europe_mid ,usage_step ,usage_europe_marks \
        ,price_europe_min ,price_europe_max ,price_europe_mid ,price_step ,price_europe_marks \
        ,usage_mideast_min ,usage_mideast_max ,usage_mideast_mid ,usage_step ,usage_mideast_marks \
        ,price_mideast_min ,price_mideast_max ,price_mideast_mid ,price_step ,price_mideast_marks

# # Update species options based on region and country selections
# @gbadsDash.callback(
#     Output('select-pathogens-amu', 'options'),
#     Input('select-antimicrobial-importance-class-amu', 'value'),
#     )
# def update_pathogens_options_ga(antimicrobial_class):
#     input_df=amr_withsmry.query(f"antimicrobial_class == '{antimicrobial_class}'")
#     # Set options for pathogens based on the antimicrobial class selected
#     options = []
#     for i in input_df['pathogens'].unique():
#         str(options.append({'label':i,'value':(i)}))

#     return options


# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# Update regional data
@gbadsDash.callback(
    Output('amu-regional-data', 'data'),
    Input('am-usage-slider-africa', 'value'),
    Input('am-price-slider-africa', 'value'),
    Input('am-usage-slider-americas', 'value'),
    Input('am-price-slider-americas', 'value'),
    Input('am-usage-slider-asia', 'value'),
    Input('am-price-slider-asia', 'value'),
    Input('am-usage-slider-europe', 'value'),
    Input('am-price-slider-europe', 'value'),
    Input('am-usage-slider-mideast', 'value'),
    Input('am-price-slider-mideast', 'value'),
    )
def update_regional_table_amu(
        usage_africa ,price_africa
        ,usage_americas ,price_americas
        ,usage_asia ,price_asia
        ,usage_europe ,price_europe
        ,usage_mideast ,price_mideast
    ):
    df = amu_combined_regional.copy()

    # Add selected usage and price values as columns
    df.loc[df['region'].str.contains('africa' ,case=False) ,['amu_terrestrial_tonnes_selected' ,'am_price_usdpertonne_selected']] = \
       [usage_africa ,price_africa]
    df.loc[df['region'].str.contains('americas' ,case=False) ,['amu_terrestrial_tonnes_selected' ,'am_price_usdpertonne_selected']] = \
        [usage_americas ,price_americas]
    df.loc[df['region'].str.contains('asia' ,case=False) ,['amu_terrestrial_tonnes_selected' ,'am_price_usdpertonne_selected']] = \
        [usage_asia ,price_asia]
    df.loc[df['region'].str.contains('europe' ,case=False) ,['amu_terrestrial_tonnes_selected' ,'am_price_usdpertonne_selected']] = \
        [usage_europe ,price_europe]
    df.loc[df['region'].str.contains('middle' ,case=False) ,['amu_terrestrial_tonnes_selected' ,'am_price_usdpertonne_selected']] = \
        [usage_mideast ,price_mideast]

    # Calculate expenditure based on usage and price slider input
    df['am_expenditure_usd_selected'] = df['amu_terrestrial_tonnes_selected'] * df['am_price_usdpertonne_selected']
    df['am_expenditure_usd_perkg_selected'] = df['am_expenditure_usd_selected'] / df['biomass_terr_kg_region']

    return df.to_json(date_format='iso', orient='split')

# Datatable below graphics
@gbadsDash.callback(
    Output('amu-2018-combined-tall-todisplay', 'children'),
    Input('select-species-ga','value'),
    )
def update_table_display_amu(dummy_input):
    display_data = amu2018_combined_tall.copy()

    # Filter out AGP
    display_data = display_data.query("scope != 'AGP'")

    columns_to_display_with_labels = {
       'region':'Region'
       ,'scope':'Scope'
       ,'number_of_countries':'Number of Countries Reporting'
       ,'biomass_total_kg_reporting':'Total Biomass in Countries Reporting (kg)'
       ,'biomass_total_kg_region':'Total Biomass in Region (kg)'
       ,'biomass_prpn_reporting':'Percent of Region Biomass in Countries Reporting'
       ,'antimicrobial_class': 'Antimicrobial Class'
       ,'who_importance_ctg':'WHO Importance Category'
       ,'woah_importance_ctg':'WOAH Importance Category'
       ,'onehealth_importance_ctg':'OneHealth Importance Category'
       ,'amu_tonnes': 'Total AM Usage (tonnes)'
       ,'amu_mg_perkgbiomass':'AM Usage (mg per kg biomass)'
    }

    # ------------------------------------------------------------------------------
    # Hover-over text
    # ------------------------------------------------------------------------------
    column_tooltips = {
        'who_importance_ctg':'Source: World Health Organization'
        ,'woah_importance_ctg':'Source: WOAH'
        ,'onehealth_importance_ctg':'Source: Venkateswaran et al., 2023'
        }

    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places
    display_data.update(display_data[[
        'biomass_total_kg_reporting'
        ,'biomass_total_kg_region'
    ]].applymap('{:,.0f}'.format))

    # One decimal place
    display_data.update(display_data[[
        'amu_tonnes'
    ]].applymap('{:,.1f}'.format))

    # Percent
    display_data.update(display_data[[
        'biomass_prpn_reporting'
    ]].applymap('{:,.1%}'.format))

    # Two decimal places
    display_data.update(display_data[[
        'amu_mg_perkgbiomass'
    ]].applymap('{:,.2f}'.format))

    return [
            html.H4("WOAH Antimicrobial Data 2018"),
            html.A("Source: WOAH 2018"
                   ,href='https://www.woah.org/app/uploads/2022/06/a-sixth-annual-report-amu-final.pdf'
                   ,style={'font-style':'italic'}),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                # fixed_rows={'headers': True, 'data': 0},
                data=display_data.to_dict('records'),
                export_format="csv",
                sort_action='native',
                style_cell={
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '350px',
                              'overflowY': 'auto'},
                page_action='none',

                # Hover-over for column headers
                tooltip_header=column_tooltips,
                tooltip_delay= 500,
                tooltip_duration=50000,

                # Underline columns with tooltips
                style_header_conditional=[{
                    'if': {'column_id': col},
                    'textDecoration': 'underline',
                    'textDecorationStyle': 'dotted',
                    } for col in list(column_tooltips)],
            )
        ]

# Regional data with Usage and Price
@gbadsDash.callback(
    Output('amu-regional-todisplay', 'children'),
    Input('amu-regional-data', 'data'),
    )
def update_regional_display_amu(input_json):
    display_data = pd.read_json(input_json, orient='split')

    columns_to_display_with_labels = {
        'region':'Region'
        ,'number_of_countries':'Number of Countries'
        ,'total_antimicrobials_tonnes':'Total Antimicrobials for countries reporting (tonnes)'
        ,'biomass_total_kg_reporting':'Total Biomass for countries reporting'
        ,'biomass_total_kg_region':'Total Biomass for region'
        ,'biomass_terr_kg_reporting':'Terrestrial Biomass for countries reporting'
        ,'biomass_terr_kg_region':'Terrestrial Biomass for region'
        ,'biomass_terr_prpn_reporting':'Proportion of terrestrial biomass in countries reporting'
        ,'terr_amu_tonnes_reporting':'Estimated antimicrobials for terrestrial species in countries reporting 2018 (tonnes)'
        ,'prpn_change_2018to2020':'AM Usage Trend 2016 to 2018'
        ,'terr_amu_tonnes_reporting_2020':'Estimated antimicrobials for terrestrial species in countries reporting 2020 (tonnes)'
        ,'biomass_terr_reporting_prpnofregion':'Proportion of regional biomass'
        ,'terr_amu_tonnes_region_2020':'Estimated antimicrobials for terrestrial species in whole region 2020 (tonnes)'
        ,'terr_amu_tonnes_mulch_2020':'Estimated antimicrobials for terrestrial species from Mulchandani 2020 (tonnes)'
        ,'am_price_usdpertonne_low':'Average price of antimicrobials - Low (euros per tonne)'
        ,'am_price_usdpertonne_mid':'Average price of antimicrobials - Mid (euros per tonne)'
        ,'am_price_usdpertonne_high':'Average price of antimicrobials - High (euros per tonne)'

        ,'amu_terrestrial_tonnes_selected':'Antimicrobial usage - Selected (tonnes)'
        ,'am_price_usdpertonne_selected':'Average price of antimicrobials - Selected (USD per tonne)'
        ,'am_expenditure_usd_selected':'Expenditure on antimicrobials (USD)'

        ,'resistance_rate_wtavg':'Average antimicrobial resistance rate'
        ,'drug_resistance_index':'Drug resistance index'
        }

    # ------------------------------------------------------------------------------
    # Hover-over text
    # ------------------------------------------------------------------------------
    column_tooltips = {
        'terr_amu_tonnes_mulch_2020':'Source: Mulchandani et al., 2023'
        }

    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places
    display_data.update(display_data[[
        'number_of_countries'
        ,'biomass_total_kg_reporting'
        ,'biomass_total_kg_region'
        ,'biomass_terr_kg_reporting'
        ,'biomass_terr_kg_region'
        ,'total_antimicrobials_tonnes'
        ,'terr_amu_tonnes_reporting'
        ,'terr_amu_tonnes_reporting_2020'
        ,'terr_amu_tonnes_region_2020'
        ,'terr_amu_tonnes_mulch_2020'
    ]].applymap('{:,.0f}'.format))

    # One decimal place
    # display_data.update(display_data[[
    # ]].applymap('{:,.1f}'.format))

    # Two decimal places
    display_data.update(display_data[[
        'drug_resistance_index'
        ,'biomass_terr_prpn_reporting'
        ,'biomass_terr_reporting_prpnofregion'
    ]].applymap('{:,.2f}'.format))

    # Percent
    display_data.update(display_data[[
        'prpn_change_2018to2020'
        ,'resistance_rate_wtavg'
    ]].applymap('{:,.0%}'.format))

    # Euro currency
    # display_data.update(display_data[[
    #     'am_price_eurospertonne_low'
    #     ,'am_price_eurospertonne_mid'
    #     ,'am_price_eurospertonne_high'
    #     ,'am_expenditure_euros_selected'
    # ]].applymap('€ {:,.0f}'.format))

    # USD currency
    display_data.update(display_data[[
        'am_price_usdpertonne_low'
        ,'am_price_usdpertonne_mid'
        ,'am_price_usdpertonne_high'
        ,'am_expenditure_usd_selected'
    ]].applymap('$ {:,.0f}'.format))

    return [
            html.H4("Extended Regional Data"),
            # html.P("Including regional estimates from Mulchandani et al., 2023. Contact the authors for national estimates." ,style={'font-style':'italic'}),
            # html.P(children=[
            #     html.P("Including regional estimates from Mulchandani et al., 2023. Contact the authors for national estimates."),
            #     html.A("Source: Mulchandani et al., 2023.", href='https://doi.org/10.1371/journal.pgph.0001305'),
            #     ],style={'font-style':'italic'}),

            html.Label(['Displaying antimicrobial usage as reported to ',
                        html.A('Mulchandani et al., 2023.',
                        href='https://doi.org/10.1371/journal.pgph.0001305'),
                        html.Label("Contact the authors for national estimates.")],
                        style={'font-style':'italic',
                               'margin-bottom':0,}),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                # fixed_rows={'headers': True, 'data': 0},
                data=display_data.to_dict('records'),
                export_format="csv",
                sort_action='native',
                style_cell={
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX':'scroll',
                              'overflowY': 'auto'},
                page_action='none',

                # Hover-over for column headers
                tooltip_header=column_tooltips,
                tooltip_delay= 500,
                tooltip_duration=50000,

                # Underline columns with tooltips
                style_header_conditional=[{
                    'if': {'column_id': col},
                    'textDecoration': 'underline',
                    'textDecorationStyle': 'dotted',
                    } for col in list(column_tooltips)],
            )
        ]

# Antimicrobial Resistance data
@gbadsDash.callback(
    Output('amr-todisplay', 'children'),
    Input('amu-regional-data', 'data'),
    )
def update_amr_display_amu(dummy_input):
    display_data = amr_withsmry.copy()

    columns_to_display_with_labels = {
        'woah_region':'Region'
        ,'location_name':'Country'
        ,'antimicrobial_class':'Antimicrobial Class'
        ,'pathogen':'Pathogen'
        ,'sum_isolates':'Number of Isolates'
        ,'overall_prev':'Percent Isolates Resistant'
        ,'reporting_year':'Reporting Year'
        }

    # ------------------------------------------------------------------------------
    # Format data to display in the table
    # ------------------------------------------------------------------------------
    # Order does not matter in these lists
    # Zero decimal places
    display_data.update(display_data[[
        'sum_isolates'
    ]].applymap('{:,.0f}'.format))

    # One decimal place
    # display_data.update(display_data[[
    # ]].applymap('{:,.1f}'.format))

    # Two decimal places
    # display_data.update(display_data[[
    # ]].applymap('{:,.2f}'.format))

    # Percent
    display_data.update(display_data[[
        'overall_prev'
    ]].applymap('{:,.1%}'.format))

    return [
            html.H4("Antimicrobial Resistance Data"),
            dcc.Markdown(
                '''
                *Source: [resistancebank.org](https://resistancebank.org) and [Venkateswaran et al., 2023](https://ssrn.com/abstract=4346767)*
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                # fixed_rows={'headers': True, 'data': 0},
                data=display_data.to_dict('records'),
                export_format="csv",
                sort_action='native',
                style_cell={
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX':'scroll',
                             'height': '350px',
                              'overflowY': 'auto'},
                page_action='none',
            )
        ]

# Usage and Price uncertainty data
# @gbadsDash.callback(
#     Output('amu-uncertainty-todisplay', 'children'),
#     Input('select-species-ga','value'),
#     )
# def update_uncertainty_display_amu(dummy_input):
#     display_data = amu_uncertainty_data.copy()

#     columns_to_display_with_labels = {
#        'region':'Region',
#        'n_countries':'Number of Countries',
#        'biomass_total_kg':'Total Biomass (kg)',
#        'biomass_total_terr_kg':'Terrestrial Livestock Biomass (kg)',

#        'amu_terrestrial_tonnes_min':'AMU tonnes (min)',
#        'amu_terrestrial_tonnes_mostlikely':'AMU tonnes (most likely)',
#        'amu_terrestrial_tonnes_max':'AMU tonnes (max)',
#        'tonnes_ci95_low':'AMU tonnes CI lower',
#        'tonnes_ci95_high':'AMU tonnes CI upper',
#        # 'amu_terrestrial_tonnes_distr':'',
#        # 'amu_terrestrial_tonnes_distr_lambda':'',
#        'amu_eurospertonne_min':'Euros per tonne (min)',
#        'amu_eurospertonne_mostlikely':'Euros per tonne (most likely)',
#        'amu_eurospertonne_max':'Euros per tonne (max)',
#        'price_ci95_low':'Euros per tonne CI lower',
#        'price_ci95_high':'Euros per tonne CI upper',
#        # 'amu_eurospertonne_distr':'',
#        # 'amu_eurospertonne_distr_lambda':'',
#        # 'amu_terrestrial_tonnes_errorlow':'',
#        # 'amu_terrestrial_tonnes_errorhigh':'',
#        # 'amu_eurospertonne_errorlow':'',
#        # 'amu_eurospertonne_errorhigh':'',
#        'expenditure_ci95_low':'Expenditure euros CI lower',
#        # 'expenditure_ci95_mid':'',
#        'expenditure_ci95_high':'Expenditure euros CI upper',
#        # 'amu_terrestrial_expenditure_midpoint':'',
#        # 'amu_terrestrial_expenditure_errorlow':'',
#        # 'amu_terrestrial_expenditure_errorhigh':''
#        }

#     # ------------------------------------------------------------------------------
#     # Format data to display in the table
#     # ------------------------------------------------------------------------------
#     # Order does not matter in these lists
#     # Zero decimal places
#     display_data.update(display_data[[
#         'n_countries'
#         ,'biomass_total_kg'
#         ,'biomass_total_terr_kg'
#         ,'amu_terrestrial_tonnes_min'
#         ,'amu_terrestrial_tonnes_mostlikely'
#         ,'amu_terrestrial_tonnes_max'
#         ,'tonnes_ci95_low'
#         ,'tonnes_ci95_high'
#     ]].applymap('{:,.0f}'.format))

#     # One decimal place
#     display_data.update(display_data[[
#     ]].applymap('{:,.1f}'.format))

#     # Two decimal places
#     display_data.update(display_data[[
#        'amu_eurospertonne_min'
#        ,'amu_eurospertonne_mostlikely'
#        ,'amu_eurospertonne_max'
#        ,'price_ci95_low'
#        ,'price_ci95_high'
#        ,'expenditure_ci95_low'
#        ,'expenditure_ci95_high'
#     ]].applymap('€ {:,.2f}'.format))

#     # ------------------------------------------------------------------------------
#     # Hover-over text
#     # ------------------------------------------------------------------------------
#     column_tooltips = {
#         # 'amu_terrestrial_tonnes_min':'Estimated from WOAH region total AMU based on terrestrial biomass as proportion of total biomass.'
#         # ,'amu_terrestrial_tonnes_mostlikely':'Source: Mulchandani et. al.'
#         # ,'amu_terrestrial_tonnes_max':'Estimated as 10% higher than most likely value'
#         'tonnes_ci95_low':'Based on PERT distribution'
#         ,'tonnes_ci95_high':'Based on PERT distribution'

#         # ,'amu_eurospertonne_min':'Source:'
#         # ,'amu_eurospertonne_mostlikely':'Source:'
#         # ,'amu_eurospertonne_max':'Source:'
#         ,'price_ci95_low':'Based on PERT distribution'
#         ,'price_ci95_high':'Based on PERT distribution'
#         }

#     return [
#             html.H4("Terrestrial Livestock Estimates"),
#             dash_table.DataTable(
#                 columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
#                 # fixed_rows={'headers': True, 'data': 0},
#                 data=display_data.to_dict('records'),
#                 export_format="csv",
#                 sort_action='native',
#                 style_cell={
#                     'font-family':'sans-serif',
#                     },
#                 style_table={'overflowX':'scroll',
#                               'overflowY': 'auto'},
#                 page_action='none',

#                 # Hover-over for column headers
#                 tooltip_header=column_tooltips,
#                 tooltip_delay= 500,
#                 tooltip_duration=50000,

#                 # Underline columns with tooltips
#                 style_header_conditional=[{
#                     'if': {'column_id': col},
#                     'textDecoration': 'underline',
#                     'textDecorationStyle': 'dotted',
#                     } for col in list(column_tooltips)],
#             )
#         ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# AMU Map or Tree Map by regions
@gbadsDash.callback(
    Output('amu-map', 'figure'),
    Input('select-viz-switch-amu','value'),
    Input('select-map-display-drilldown-amu','value'),
    Input('select-antimicrobial-importance-class-amu','value'),
    Input('select-pathogens-amu','value'),
    Input('amu-regional-data', 'data'),
    )
def update_map_amu (viz_switch, quantity, antimicrobial_class, pathogens, input_json):
    input_df = amu2018_combined_tall.copy()
    input_df_amr = amr_withsmry.copy()
    input_df_am_expend = pd.read_json(input_json, orient='split')

    # Filter scope to All and remove nulls from importance category
    input_df = input_df.query("scope == 'All'")

    # Filter AMR to just 2018, selected antimicrobial class and pathogen, and sort data by region
    # input_df_amr = input_df_amr.query("reporting_year == 2018").query(f"antimicrobial_class == '{antimicrobial_class}'").query(f"pathogen == '{pathogens}'")
    # Update: AMR data now includes only a single year selected for each region based on the most data available
    input_df_amr = input_df_amr.query(f"antimicrobial_class == '{antimicrobial_class}'").query(f"pathogen == '{pathogens}'")
    input_df_amr = input_df_amr.sort_values(by=['woah_region'])

    # Fix antimicrobial class names
    input_df = input_df.replace(['aggregated_class_data',
                                 'other_important',
                                 'sulfonamides__including_trimethoprim',
                                 'cephalosporins__all_generations',
                                 '1_2_gen__cephalosporins',
                                 '3_4_gen_cephalosporins',
                                 'other_quinolones'],
                                ['aggregated class data',
                                 'other (important)',
                                 'sulfonamides (with trimethoprim)',
                                 'cephalosporins (all gens)',
                                 'cephalosporins (1 & 2 gen)',
                                 'cephalosporins (3 & 4 gen)',
                                 'other quinolones'])

    # Convert antimicrobial classes to title case
    input_df.antimicrobial_class = input_df.antimicrobial_class.str.title()
    input_df.antimicrobial_class_group = input_df.antimicrobial_class_group.str.title()
    input_df.antimicrobial_class_group2 = input_df.antimicrobial_class_group2.str.title()

    # Use selected quantity value (AMU & AMR)
    if quantity == 'Antimicrobial usage: tonnes':
        value = input_df['amu_tonnes']
        map_value = input_df['amu_tonnes_by_region'] = input_df['amu_tonnes'].groupby(input_df['region']).transform('sum')
    elif quantity == 'Antimicrobial usage: mg per kg biomass':
        value = input_df['amu_mg_perkgbiomass']
        map_value = input_df['amu_mg_perkgbiomass_by_region'] = input_df['amu_mg_perkgbiomass'].groupby(input_df['region']).transform('sum')
    elif quantity == 'Biomass':
        map_value = input_df['biomass_total_kg_reporting']
    elif quantity == 'Antimicrobial Resistance (country level)':
        map_value = input_df_amr['overall_prev']
    elif quantity == 'Drug Resistance Index (region level)':
        map_value = input_df_am_expend['drug_resistance_index']
    elif quantity == 'Antimicrobial expenditure: total':
        map_value = input_df_am_expend['am_expenditure_usd_selected']
    elif quantity == 'Antimicrobial expenditure: per kg biomass':
        map_value = input_df_am_expend['am_expenditure_usd_perkg_selected']



    # Visualization switch between map and tree map
    if viz_switch == 'Map':

        # Create Map for AMR prevalence
        if quantity == 'Antimicrobial Resistance (country level)':
            if len(input_df_amr):
               amu_map_fig = px.scatter_geo(input_df_amr,
                                            locations="location_name",
                                            locationmode='country names',
                                            color="woah_region",
                                            hover_name="woah_region",
                                            size=map_value,
                                            projection="natural earth",
                                            custom_data=['woah_region',
                                                         map_value,
                                                         'location_name',
                                                         'antimicrobial_class',
                                                         'pathogen',
                                                         'sum_isolates'],
                                            color_discrete_map={"Asia, Far East and Oceania": 'rgb(102,197,204)',
                                                                "Americas": 'rgb(248,156,116)',
                                                                "Europe": 'rgb(220,176,242)',
                                                                "Africa": 'rgb(135,197,95)',
                                                                "Middle East": 'rgb(254,136,177)'}
                                            )

            else:
                amu_map_fig = go.Figure()
                amu_map_fig.update_layout(
                       xaxis =  { "visible": False },
                       yaxis = { "visible": False },
                       annotations = [
                           {
                               "text": "No data available, please choose a different antimicrobial or pathogen",
                               "xref": "paper",
                               "yref": "paper",
                               "showarrow": False,
                               "font": {
                                   "size": 28
                               }
                           }
                       ]
                   )

        elif quantity == 'Antimicrobial expenditure: total'\
            or quantity == 'Antimicrobial expenditure: per kg biomass'\
                or quantity == 'Drug Resistance Index (region level)':
            # Use create map defined above for AM expenditure
            amu_map_fig = create_map_display_amu(input_df_am_expend, map_value)
        else:
            # Use create map defined above for AMU
            amu_map_fig = create_map_display_amu(input_df, map_value)



        # Add title
        if quantity == 'Antimicrobial Resistance (country level)':
            amu_map_fig.update_layout(title_text=f'Global {quantity}<br><sup>{pathogens} pathogen(s) resistance to {antimicrobial_class} antimicrobials</sup>',
                                          font_size=15,
                                          plot_bgcolor="#ededed",)
        elif quantity == 'Drug Resistance Index (region level)':
            amu_map_fig.update_layout(title_text=f'{quantity}',
                                          font_size=15,
                                          plot_bgcolor="#ededed",)
        elif quantity == 'Antimicrobial expenditure: total':
            amu_map_fig.update_layout(title_text='Total Antimicrobial Expenditure by Region',
                                          font_size=15,
                                          plot_bgcolor="#ededed",)
        elif quantity == 'Antimicrobial expenditure: per kg biomass':
            amu_map_fig.update_layout(title_text= 'Antimicrobial Expenditure per kg Biomass by Region',
                                          font_size=15,
                                          plot_bgcolor="#ededed",)
        else:
            amu_map_fig.update_layout(title_text=f'Global {quantity}',
                                          font_size=15,
                                          plot_bgcolor="#ededed",)

        # Update legend title and location
        amu_map_fig.update_layout(legend=dict(
            title="Region",
            orientation="h",
            font=dict(size=12)
            ))

        # Update hoverover
        if quantity == 'Antimicrobial usage: tonnes':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "AMU: %{customdata[1]:,.0f} tonnes<br>" +
                                      "# of countries reporting: %{customdata[2]}" +
                                      "<extra></extra>",)
        elif quantity == 'Antimicrobial usage: mg per kg biomass':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "AMU: %{customdata[1]:,.0f} mg per kg biomass<br>" +
                                      "# of countries reporting: %{customdata[2]}" +
                                      "<extra></extra>",)
        elif quantity == 'Biomass':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "Biomass: %{customdata[1]:,.0f}<br>" +
                                      "# of countries reporting: %{customdata[2]}" +
                                      "<extra></extra>",)
        elif quantity == 'Antimicrobial Resistance (country level)':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "Country: %{customdata[2]}<br>" +
                                      "Overall prevalence: %{customdata[1]:,.1%}<br>" +
                                      "Total isolates: %{customdata[5]}<br>"
                                      'Antimicrobial Class: %{customdata[3]}<br>'+
                                      'Pathogen: %{customdata[4]}'
                                      "<extra></extra>",)
        elif quantity == 'Drug Resistance Index (region level)':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "Drug Resistance Index: %{customdata[1]:,.2f}" +
                                      "<extra></extra>",)
        elif quantity == 'Antimicrobial expenditure: total':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "Expenditure (USD): $%{customdata[1]:,.0f}" +
                                      "<extra></extra>",)
        elif quantity == 'Antimicrobial expenditure: per kg biomass':
            amu_map_fig.update_traces(hovertemplate=
                                      "<b>%{customdata[0]}</b><br>" +
                                      "Expenditure (USD): $%{customdata[1]:,.0f} per kg biomass" +
                                      "<extra></extra>",)


    else:
        # Add custom data for hoverover
        if quantity == 'Antimicrobial usage: tonnes':
            customdata = list(pd.DataFrame(['amu_tonnes']).to_numpy())
        elif quantity == 'Antimicrobial usage: mg per kg biomass':
            customdata = list(pd.DataFrame(['amu_mg_perkgbiomass_by_region']).to_numpy())

        # Determine which categorization to use
        if antimicrobial_class.upper() == 'WHO IMPORTANCE CATEGORIES':
            categories = 'who_importance_ctg'
            category_title = 'WHO importance categories'
        elif antimicrobial_class.upper() == 'ONEHEALTH IMPORTANCE CATEGORIES':
            categories = 'onehealth_importance_ctg'
            category_title = 'OneHealth importance categories'
        else:   # Default: WOAH categories
            categories = 'woah_importance_ctg'
            category_title = 'WOAH importance categories'

        # Use create map defined above
        amu_map_fig = create_tree_map_amu(input_df, value, categories)

        # treemap_hierarchy = ['region_with_countries_reporting', categories, 'antimicrobial_class']
        # if quantity == 'Antimicrobial usage: tonnes':
        #     amu_map_fig = create_treemap_withagg(
        #         input_df
        #         ,HIERARCHY=treemap_hierarchy
        #         ,COLOR_BY='region_with_countries_reporting'
        #         ,VALUE_VAR='amu_tonnes'
        #         )
        # elif quantity == 'Antimicrobial usage: mg per kg biomass':
        #     amu_map_fig = create_treemap_withagg(
        #         input_df
        #         ,HIERARCHY=treemap_hierarchy
        #         ,COLOR_BY='region_with_countries_reporting'
        #         ,VALUE_VAR='amu_mg_perkgbiomass'
        #         ,AGGREGATION='mean'
        #         ,WEIGHT_VAR='biomass_total_kg_reporting'
        #         )

        # Add title
        amu_map_fig.update_layout(title_text=f'{quantity} drill down by region and {category_title} | Countries reporting to WOAH',
                                  font_size=15,
                                  plot_bgcolor="#ededed",
                                  )

        # Update hoverover
        if quantity == 'Antimicrobial usage: tonnes':
            amu_map_fig.update_traces(customdata=customdata,
                hovertemplate=
                "<b>%{label}</b><br>" +
                "AMU total =  %{value:,.0f} tonnes<br>" +
                "Parent = %{parent}" +
                "<extra></extra>",)

        else:
            amu_map_fig.update_traces(customdata=customdata,
                hovertemplate=
                "<b>%{label}</b><br>" +
                "AMU total =  %{value:,.0f} mg per kg biomass<br>" +
                "Parent = %{parent}" +
                "<extra></extra>",)

        # Display value on box
        amu_map_fig.data[0].texttemplate = "%{label}<br>%{value:,.0f}"

    # Adjust margins
    amu_map_fig.update_layout(
        margin=dict(l=10, r=10, b=10),
        )


    return amu_map_fig


#AMU Stacked Bar by Tonnes
@gbadsDash.callback(
    Output('amu-stacked-bar', 'figure'),
    Input('select-classification-amu','value'),
    Input('select-quantity-amu-tonnes', 'value'),
    Input('select-amu-graph', 'value'),
    )

def update_stacked_bar_amu (classification, quantity, select_amu_graph):
    stackedbar_df = amu2018_combined_tall.copy()
    stackedbar_df = stackedbar_df.query("scope == 'All'").query("antimicrobial_class != 'total_antimicrobials'")

    # Workaround to fix names in legend
    stackedbar_df = stackedbar_df.replace(['aggregated_class_data', 'other_important', 'sulfonamides__including_trimethoprim'],
                                          ['aggregated class data', 'other (important)', 'sulfonamides (with trimethoprim)'])

    # Convert antimicrobial classes to title case
    stackedbar_df.antimicrobial_class = stackedbar_df.antimicrobial_class.str.title()
    stackedbar_df.antimicrobial_class_group = stackedbar_df.antimicrobial_class_group.str.title()
    stackedbar_df.antimicrobial_class_group2 = stackedbar_df.antimicrobial_class_group2.str.title()

    # Create region labels with proportion of biomass represented in countries reporting and adding a break
    stackedbar_df["region_with_countries_reporting"] = stackedbar_df['region'] \
            + '<br>' \
            + " (" + round(stackedbar_df['number_of_countries'] ,0).astype(int).astype(str) \
            + " | " + round(stackedbar_df['biomass_prpn_reporting'] * 100 ,1).astype(str) + "%)"

    x_var = 'region_with_countries_reporting'

    if quantity.upper() == 'TONNES':
        y_var = 'amu_tonnes'
    elif quantity.upper() == 'MG PER KG BIOMASS':
        y_var = 'amu_mg_perkgbiomass'

    # Define color sets
    color_map_impctg = {
        # WHO and WOAH categories
        "A: Critically Important": '#EF553B',
        "B: Highly Important": '#00CC96',
        "C: Other": '#636EFA',
        "D: Unknown": '#AB63FA',

        # OneHealth categories
        "Important": '#EF553B',
        "Other": '#636EFA',
        "Unknown": '#AB63FA'
        }
    color_map_indiv = {
        # Individual classes/top classes
        "Aggregated Class Data": '#636EFA',
        "Aminoglycosides": '#EF553B',
        "Amphenicols": '#00CC96',
        "Fluoroquinolones": '#AB63FA',
        "Macrolides": '#AAFFE1',
        "Other": '#C6CAFD',
        "Others": '#C6CAFD',
        "Other (Important)": '#FF6692',
        "Penicillins": '#FECB52',
        "Pleuromutilins": '#F7A799',
        "Polypeptides": '#FFA15A',
        "Sulfonamides (With Trimethoprim)": '#B6E880',
        "Tetracyclines": '#FF97FF',
        }

    if classification.upper() == 'WHO IMPORTANCE CATEGORIES':
        color = 'who_importance_ctg'
        color_map = color_map_impctg
        stackedbar_df['id'] = stackedbar_df.groupby(['who_importance_ctg']).ngroup()
    elif classification.upper() == 'WOAH IMPORTANCE CATEGORIES':
        color = 'woah_importance_ctg'
        color_map = color_map_impctg
        stackedbar_df['id'] = stackedbar_df.groupby(['woah_importance_ctg']).ngroup()
    elif classification.upper() == 'ONEHEALTH IMPORTANCE CATEGORIES':
        color = 'onehealth_importance_ctg'
        color_map = color_map_impctg
        stackedbar_df['id'] = stackedbar_df.groupby(['onehealth_importance_ctg']).ngroup()
    elif classification.upper() == 'INDIVIDUAL CLASSES':
        color = 'antimicrobial_class_group'
        color_map = color_map_indiv
        stackedbar_df['id'] = stackedbar_df.groupby(['antimicrobial_class']).ngroup()
        # stackedbar_df['id'] = stackedbar_df.groupby(['antimicrobial_class_group']).ngroup()
    elif classification.upper() == 'TOP GLOBAL CLASSES':
        color = 'antimicrobial_class_group2'
        color_map = color_map_indiv
        stackedbar_df['id'] = stackedbar_df.groupby(['antimicrobial_class_group2']).ngroup()

    # Options to change between graphs
    if select_amu_graph.upper() == 'TOTAL':
        amu_bar_fig = px.histogram(stackedbar_df,
                                   x=x_var,
                                   y=y_var,
                                   color=color,
                                   color_discrete_map=color_map,
                                   labels={
                                       x_var: "",
                                       "who_importance_ctg": "WHO Importance Category",
                                       "woah_importance_ctg": "WOAH Importance Category",
                                       "onehealth_importance_ctg": "OneHealth Importance Category",
                                       "antimicrobial_class_group": "Antimicrobial Class",
                                       "antimicrobial_class_group2": "Antimicrobial Class"
                                       }
                                   )

        # Add title
        amu_bar_fig.update_layout(title_text=f'Regional AMU {quantity} by {classification}<br><sup>for countries reporting to WOAH</sup>',
                                  font_size=15,
                                  plot_bgcolor="#ededed",
                                  )
        amu_bar_fig.update_yaxes(title_text=f"AMU {quantity}")

        # # TODO: WIP for layout adjustments
        # amu_bar_fig = go.Figure()

        # amu_bar_fig.add_trace(go.Bar(
        #                       x=stackedbar_df['region'],
        #                       y=stackedbar_df['amu_tonnes'],
        #                       marker=dict(color = stackedbar_df['id']),
        #                       ))

        # amu_bar_fig.update_layout({'title' : 'Stacked Bar'})

        # amu_bar_fig.layout.update(
        #    updatemenus = [
        #       go.layout.Updatemenu(
        #          type = "buttons", direction = "left", buttons=list(
        #             [
        #                dict(args = [{"type":"bar"},
        #                             {"title":"Stacked Bar"}], label = "Bar", method = "update"),
        #                dict(args = [{"type":"violin"},
        #                             {"title":"Violin"}], label = "Violin", method = "update")
        #             ]
        #          ),
        #          pad = {"r": 10, "t": 10},
        #          showactive = True,
        #          x = 0.19,
        #          xanchor = "left",
        #          y = 1.12,
        #          yanchor = "top"
        #       ),
        #    ]
        # )

        # # Add annotation
        # amu_bar_fig.update_layout(
        #     annotations=[
        #         dict(text="Graph type:", showarrow=False,
        #                               x=0, y=1.08, yref="paper", align="left")
        #     ]
        # )

    elif select_amu_graph.upper() == 'PERCENT':
         amu_bar_fig = px.histogram(
             stackedbar_df,
             x=x_var,
             y=y_var,
             color=color,
             color_discrete_map=color_map,
             barnorm='percent',
             text_auto='.1f',
             labels={
                x_var: "",
                "antimicrobial_class_group": "Antimicrobial Class"
                }
             )

         # Add titles
         amu_bar_fig.update_layout(title_text=f'Regional Percent of AMU {quantity} by {classification}<br><sup>for countries reporting to WOAH</sup>',
                                   font_size=15,
                                   plot_bgcolor="#ededed",
                                   )
         amu_bar_fig.update_yaxes(title_text=f"% of AMU {quantity}")

    # Remove legend (share with donut chart)
    amu_bar_fig.update_layout(showlegend=False)

    # Adjust margins
    amu_bar_fig.update_layout(
        margin=dict(l=20, r=20, b=20),
        )

    return amu_bar_fig

# AMU Donut chart
@gbadsDash.callback(
    Output('amu-donut-chart', 'figure'),
    Input('select-quantity-amu-tonnes','value'),
    Input('select-region-amu','value'),
    Input('select-classification-amu', 'value'),
    )
def update_donut_chart_amu (quantity, region, classification):
    input_df = amu2018_combined_tall.copy()

    # Workaround to fix names in legend
    input_df = input_df.replace(['aggregated_class_data', 'other_important', 'sulfonamides__including_trimethoprim'],
                                ['Aggregated Class Data', 'Other (Important)', 'Sulfonamides (With Trimethoprim)'])

    # Convert antimicrobial classes to title case
    input_df.antimicrobial_class_group = input_df.antimicrobial_class_group.str.title()
    input_df.antimicrobial_class_group2 = input_df.antimicrobial_class_group2.str.title()

    # Filter scope to All and remove nulls from importance category
    # Filter by region selected
    if region == 'All':
        selected_region = 'Global'
    else:
        selected_region = f'{region}'
        input_df = input_df.loc[(input_df['region'] == region)]

    # Use selected classification value
    if classification == 'Individual Classes':
        summarize_df = input_df.query("scope == 'All'").groupby('antimicrobial_class_group')[['amu_tonnes' ,'biomass_total_kg_reporting']].sum().reset_index()
        sort_by = 'antimicrobial_class'
        legend_title = 'Antimicrobial Class'
        names = summarize_df['antimicrobial_class_group']
        # Set colors to sync across visuals
        colors = {
        "Aggregated Class Data": '#636EFA',
        "Aminoglycosides": '#EF553B',
        "Amphenicols": '#00CC96',
        "Fluoroquinolones": '#AB63FA',
        "Macrolides": '#AAFFE1',
        "Other": '#C6CAFD',
        "Other (Important)": '#FF6692',
        "Penicillins": '#FECB52',
        "Pleuromutilins": '#F7A799',
        "Polypeptides": '#FFA15A',
        "Sulfonamides (With Trimethoprim)": '#B6E880',
        "Tetracyclines": '#FF97FF',
        }
        summarize_df['Color']= summarize_df['antimicrobial_class_group'].map(colors)

    elif classification == 'WHO Importance Categories':
        summarize_df = input_df.query("scope == 'All'").groupby('who_importance_ctg')[['amu_tonnes' ,'biomass_total_kg_reporting']].sum().reset_index()
        sort_by = 'who_importance_ctg'
        legend_title = 'WHO Importance Category'
        names = summarize_df['who_importance_ctg']
        # Set colors to sync across visuals
        colors = {
        "A: Critically Important": "#EF553B",
        "B: Highly Important": "#00CC96",
        "C: Other": "#636EFA",
        "D: Unknown": "#AB63FA",
        }
        summarize_df['Color']= summarize_df['who_importance_ctg'].map(colors)

    elif classification == 'WOAH Importance Categories':
        summarize_df = input_df.query("scope == 'All'").groupby('woah_importance_ctg')[['amu_tonnes' ,'biomass_total_kg_reporting']].sum().reset_index()
        sort_by = 'woah_importance_ctg'
        legend_title = 'WOAH Importance Category'
        names = summarize_df['woah_importance_ctg']
        # Set colors to sync across visuals
        colors = {
        "A: Critically Important": "#EF553B",
        "B: Highly Important": "#00CC96",
        "C: Other": "#636EFA",
        "D: Unknown": "#AB63FA",
        }
        summarize_df['Color']= summarize_df['woah_importance_ctg'].map(colors)

    elif classification == 'OneHealth Importance Categories':
        summarize_df = input_df.query("scope == 'All'").groupby('onehealth_importance_ctg')[['amu_tonnes' ,'biomass_total_kg_reporting']].sum().reset_index()
        sort_by = 'onehealth_importance_ctg'
        legend_title = 'OneHealth Importance Category'
        names = summarize_df['onehealth_importance_ctg']
        # Set colors to sync across visuals
        colors = {
        "Important": "#EF553B",
        "Other": "#636EFA",
        "Unknown": "#AB63FA",
        }
        summarize_df['Color']= summarize_df['onehealth_importance_ctg'].map(colors)

    elif classification == 'Top Global Classes':
        summarize_df = input_df.query("scope == 'All'").groupby('antimicrobial_class_group2')[['amu_tonnes' ,'biomass_total_kg_reporting']].sum().reset_index()
        sort_by = 'antimicrobial_class_group2'
        legend_title = 'Top Global Classes'
        names = summarize_df['antimicrobial_class_group2']
        # Set colors to sync across visuals
        colors = {
        "Macrolides": '#AAFFE1',
        "Penicillins": '#FECB52',
        "Tetracyclines": '#FF97FF',
        "Others": '#C6CAFD'
        }
        summarize_df['Color']= summarize_df['antimicrobial_class_group2'].map(colors)

    # Use selected quantity value
    if quantity == 'Tonnes':
        value = summarize_df['amu_tonnes']
    else:
        summarize_df['amu_mg_perkgbiomass'] = (summarize_df['amu_tonnes'] / summarize_df['biomass_total_kg_reporting']) * 1e9
        value = summarize_df['amu_mg_perkgbiomass']


    # Sort the data by classification to sync the legends across the visualizations
    input_df = input_df.sort_values(by=sort_by)

    # Use create donut chart defined above
    amu_donut_fig = create_donut_chart_amu(summarize_df, value, names)

    # Add title and legend title
    amu_donut_fig.update_layout(title_text=f'{selected_region} AMU {quantity} by {classification}<br><sup>for countries reporting to WOAH</sup>',
                                  font_size=15,
                                  plot_bgcolor="#ededed",
                                  # Add annotations in the center of the donut pies.
                                  annotations=[dict(text=f'{quantity}',
                                                    x=0.5,
                                                    y=0.5,
                                                    font_size=15,
                                                    showarrow=False),
                                              ],
                                  legend_title_text=f'{legend_title}'
                                  )

    # Sync colors across visuals
    amu_donut_fig.update_traces(marker=dict(colors=summarize_df['Color']))

    # Standardize number of decimal places displayed
    amu_donut_fig.update_traces(texttemplate='%{percent:.1%}')

    # Legend font smaller to not touch the graph
    amu_donut_fig.update_layout(legend=dict(
        font=dict(size=14),
        bgcolor='rgba(0,0,0,0)', # makes legend background transparent
        ))

    # Adjust margins and move legend to left
    amu_donut_fig.update_layout(
        margin=dict(l=20, r=20, b=20),
        legend_x=-.5,
        )

    return amu_donut_fig

# Comparing usage estimates
@gbadsDash.callback(
    Output('am-usage-comparison','figure'),
    Input('amu-regional-data', 'data'),
    Input('select-usage-units-amu' ,'value'),
    )
def update_am_usage_comparison(input_json, units):
    input_df = pd.read_json(input_json, orient='split')

    # Recalculate units if needed
    if units == 'mg per kg biomass':
        input_df['terr_amu_tonnes_reporting_2020'] = 1e9 * input_df['terr_amu_tonnes_reporting_2020'] / input_df['biomass_terr_kg_region']
        input_df['terr_amu_tonnes_region_2020'] = 1e9 * input_df['terr_amu_tonnes_region_2020'] / input_df['biomass_terr_kg_region']
        input_df['terr_amu_tonnes_mulch_2020'] = 1e9 * input_df['terr_amu_tonnes_mulch_2020'] / input_df['biomass_terr_kg_region']

        yaxis_title = 'Antimicrobial Usage (mg per kg biomass)'
    else:   # Otherwise use columns as they are
        yaxis_title = 'Antimicrobial Usage (tonnes)'

    # Rename columns to plot
    # Workaround to fix names in legend
    rename_plot_cols = {
        'terr_amu_tonnes_reporting_2020':'A*'
        ,'terr_amu_tonnes_region_2020':'B*'
        ,'terr_amu_tonnes_mulch_2020':'C*'
        }
    input_df = input_df.rename(columns=rename_plot_cols)

    # Set custom colors to sync across all visuals
    colors = {"Asia, Far East and Oceania": 'rgb(102,197,204)',
              "Americas": 'rgb(248,156,116)',
              "Europe": 'rgb(220,176,242)',
              "Africa": 'rgb(135,197,95)',
              "Middle East": 'rgb(254,136,177)'}
    input_df['Color']= input_df['region'].map(colors)

    bar_fig = go.Figure(data=[
        go.Bar(name='A*', x=input_df['region'], y=input_df["A*"], marker_pattern_shape="x", marker_color="black",text=input_df["A*"]),
        go.Bar(name='B*', x=input_df['region'], y=input_df["B*"], marker_pattern_shape=".",text=input_df["B*"]),
        go.Bar(name='C*', x=input_df['region'], y=input_df["C*"], marker_pattern_shape="+",text=input_df["C*"]),
    ])
    # Change the bar mode
    bar_fig.update_layout(barmode='group')

    # Sync colors across visuals and update text
    bar_fig.update_traces(marker=dict(color=input_df['Color'],
                                       pattern_fgcolor='black',
                                       pattern_bgcolor='white',
                                      ),
                          texttemplate='%{text:,.0f}',
                          textposition="outside",
                          textfont = {'size': 11,},
                          cliponaxis=False)

    bar_fig.update_layout(title_text='Comparing reported antimicrobial usage to other estimates<br><sup>Terrestrial Livestock',
                          font_size=15,
                          legend=dict(
                              title="",
                              orientation="h",
                              # Top
                                x=0.7,
                                y=1.20,
                              font=dict(size=15)
                              )
                          )

    bar_fig.update_xaxes(title_text=''
                         ,tickangle=20
                         )
    bar_fig.update_yaxes(title_text=yaxis_title)

    return bar_fig

# Comparing price estimates
@gbadsDash.callback(
    Output('am-price-comparison','figure'),
    Input('amu-regional-data', 'data'),
    )
def update_am_price_comparison(input_json):
    input_df = pd.read_json(input_json, orient='split')

    # Set custom colors to sync across all visuals
    colors = {"Asia, Far East and Oceania": 'rgb(102,197,204)',
              "Americas": 'rgb(248,156,116)',
              "Europe": 'rgb(220,176,242)',
              "Africa": 'rgb(135,197,95)',
              "Middle East": 'rgb(254,136,177)'}
    # colors_list_for_errors = ['rgb(135,197,95)', 'rgb(248,156,116)', 'rgb(102,197,204)', 'rgb(220,176,242)', 'rgb(254,136,177)']
    input_df['Color']= input_df['region'].map(colors)

    # Calculate errors as difference between endpoints and midpoint
    input_df['am_price_usdpertonne_high_err'] = input_df['am_price_usdpertonne_high'] - input_df['am_price_usdpertonne_mid']
    input_df['am_price_usdpertonne_low_err'] = input_df['am_price_usdpertonne_mid'] - input_df['am_price_usdpertonne_low']

    # Create figure with secondary y-axis
    fig = make_subplots()

    # Plot Price
    fig.add_trace(
        go.Scatter(
             x=input_df['region']
             ,y=input_df['am_price_usdpertonne_mid']
            ,marker=dict(color=input_df['Color'])
             ,error_y=dict(
                type='data'
                ,symmetric=False
                ,array=input_df['am_price_usdpertonne_high_err']
                ,arrayminus=input_df["am_price_usdpertonne_low_err"]
            ),
            mode="markers+text",
        )
    )

    # Set size of points
    fig.update_traces(marker_size=10)

    # Add plot title and axis labels
    fig.update_layout(title_text='Comparing antimicrobial price estimates'
                      ,font_size=15
                      )
    fig.update_xaxes(title_text=""
                     ,tickangle=20
                     )
    fig.update_yaxes(title_text="Average Price (USD per tonne)")
    return fig

# Expenditure based on usage and price sliders
@gbadsDash.callback(
    Output('amu-expenditure','figure'),
    Input('amu-regional-data', 'data'),
    Input('select-expenditure-units-amu', 'value'),
    )
def update_expenditure_amu(input_json, expenditure_units):
    input_df = pd.read_json(input_json, orient='split')

    # Set the units based on the expenditure selected
    if expenditure_units == 'per kg biomass':
        y='am_expenditure_usd_perkg_selected'
    else:
        y='am_expenditure_usd_selected'

    bar_fig = px.bar(
        input_df,
        x='region',
        y=y,
        text_auto='$,.5r',
        labels={
            'am_expenditure_usd_selected':'Expenditure (USD)',
            'am_expenditure_usd_perkg_selected':'Expenditure per kg biomass (USD)',
            },
        color="region",
        color_discrete_map={"Asia, Far East and Oceania": 'rgb(102,197,204)',
                            "Americas": 'rgb(248,156,116)',
                            "Europe": 'rgb(220,176,242)',
                            "Africa": 'rgb(135,197,95)',
                            "Middle East": 'rgb(254,136,177)'}
        )

    # Add title and hide legend
    bar_fig.update_layout(title_text='Estimated Antimicrobial Expenditure<br><sup>Terrestrial Livestock',
                          showlegend=False)

    # Adjust margins
    bar_fig.update_layout(
        margin=dict(l=20, r=20, b=10),
        )

    bar_fig.update_xaxes(title_text=""
                     ,tickangle=20
                     )

    return bar_fig

# AMU for terrestrial animals, with uncertainty
# @gbadsDash.callback(
#     Output('amu-terr-error-usage','figure'),
#     Input('select-region-amu','value'),
#     )
# def update_terrestrial_usage_amu(dummy_input):
#     # Prep data
#     # This is a hack to get the Usage and Price scatterplots separated
#     usage_cols = ['amu_terrestrial_tonnes_min' ,'amu_terrestrial_tonnes_mostlikely' ,'amu_terrestrial_tonnes_max']
#     price_cols = ['amu_eurospertonne_min' ,'amu_eurospertonne_mostlikely' ,'amu_eurospertonne_max']
#     amu_regions = list(amu_uncertainty_data['region'])

#     amu_uncertainty_data_toplot_usage = amu_uncertainty_data.copy()
#     amu_uncertainty_data_toplot_usage[price_cols] = np.nan

#     amu_uncertainty_data_toplot_price = amu_uncertainty_data.copy()
#     amu_uncertainty_data_toplot_price[usage_cols] = np.nan
#     amu_uncertainty_data_toplot_price['region'] = amu_uncertainty_data_toplot_price['region'] + '_price'

#     amu_uncertainty_data_toplot = pd.concat([amu_uncertainty_data_toplot_usage ,amu_uncertainty_data_toplot_price] ,axis=0 ,ignore_index=True)
#     amu_uncertainty_data_toplot = amu_uncertainty_data_toplot.sort_values(by='region')

#     # Create figure with secondary y-axis
#     fig = make_subplots(specs=[[{"secondary_y": True}]])

#     # Plot Usage
#     fig.add_trace(
#         go.Scatter(
#              x=amu_uncertainty_data_toplot['region']
#              ,y=amu_uncertainty_data_toplot['amu_terrestrial_tonnes_mostlikely']
#              ,error_y=dict(
#                 type='data'
#                 ,symmetric=False
#                 ,array=amu_uncertainty_data_toplot['amu_terrestrial_tonnes_errorhigh']
#                 ,arrayminus=amu_uncertainty_data_toplot["amu_terrestrial_tonnes_errorlow"]
#             )
#             ,mode='markers'
#             ,name='Usage'
#             ,marker_color='blue'
#         )
#         ,secondary_y=False
#     )

#     # Plot Price
#     fig.add_trace(
#         go.Scatter(
#              x=amu_uncertainty_data_toplot['region']
#              ,y=amu_uncertainty_data_toplot['amu_eurospertonne_mostlikely']
#              ,error_y=dict(
#                 type='data'
#                 ,symmetric=False
#                 ,array=amu_uncertainty_data_toplot['amu_eurospertonne_errorhigh']
#                 ,arrayminus=amu_uncertainty_data_toplot["amu_eurospertonne_errorlow"]
#             )
#             ,mode='markers'
#             ,name='Price'
#             ,marker_color='green'
#         )
#         ,secondary_y=True
#     )

#     # Set size of points
#     fig.update_traces(marker_size=10)

#     # Add plot title and axis labels
#     fig.update_layout(
#         title_text='Antimicrobial Usage and Price for Terrestrial Livestock<br><sup>with 95% confidence intervals</sup>'
#         ,font_size=15
#         ,legend_y=1.1
#         ,legend_x=0.6
#         ,legend_orientation='h'
#     )
#     fig.update_xaxes(title_text="Region"
#                      ,tickangle=45
#                      ,tickmode='array'
#                      ,tickvals=amu_regions  # Only show ticks for base regions, not dummy price regions
#                      )
#     fig.update_yaxes(title_text="Antimicrobial Usage (tonnes)"
#                       ,color='blue'
#                       ,secondary_y=False
#                       )
#     fig.update_yaxes(title_text="Antimicrobial Price (euros per tonne)"
#                       ,color='green'
#                       ,secondary_y=True
#                       ,showgrid=False
#                       )

#     return fig

# AM expenditure for terrestrial animals, with uncertainty
# @gbadsDash.callback(
#     Output('amu-terr-error-expenditure','figure'),
#     Input('select-region-amu','value'),
#     )
# def update_terrestrial_expenditure_amu(dummy_input):
#     fig = px.scatter(
#         amu_uncertainty_data
#          ,x='region'
#          ,y='amu_terrestrial_expenditure_midpoint'
#          ,error_y='amu_terrestrial_expenditure_errorhigh', error_y_minus="amu_terrestrial_expenditure_errorlow"
#         ,labels={"amu_terrestrial_expenditure_midpoint":"Total Expenditure on Antimicrobials (Euros)"}
#     )
#     fig.update_traces(marker_size=10 ,marker_color='red')

#     # Add title
#     fig.update_layout(
#         title_text='Antimicrobial Expenditure for Terrestrial Livestock<br><sup>with 95% confidence intervals</sup>'
#         ,font_size=15
#         ,plot_bgcolor="#ededed"
#     )
#     fig.update_xaxes(title_text="Region"
#                       ,tickangle=45
#                       )

#     return fig

#%% 6. RUN APP
#############################################################################################################

if __name__ == "__main__":
   # NOTE: These statements are not executed when in gunicorn, because in gunicorn this program is loaded as module

   # use_port = fa.get_open_port()  # selects first unused port >= 8050
   use_port = 8050                 # set to fixed fixed number

   fa.run_server(app, use_port, debug=True)

def returnApp():
    """
    This function is used to create the app and return it to waitress in the docker container
    """
    # If DASH_BASE_URL is set, use DispatcherMiddleware to serve the app from that path
    if 'DASH_BASE_URL' in os.environ:
        from werkzeug.middleware.dispatcher import DispatcherMiddleware
        app.wsgi_app = DispatcherMiddleware(Flask('dummy_app'), {
            os.environ['DASH_BASE_URL']: app.server
        })
        # Added redirect to new path
        @app.wsgi_app.app.route('/')
        def redirect_to_dashboard():
            return redirect(os.environ['DASH_BASE_URL'])
        return app.wsgi_app

    # If no DASH_BASE_URL is set, just return the app server
    return app.server
